# IFC OpenShell API Documentation

## Metadata

- **Source Repository**: https://github.com/IfcOpenShell/IfcOpenShell/tree/v0.8.0
- **Fetched Date**: September 13, 2025
- **Fetched Time**: 13:21:56 UTC
- **Repository Description**: Open source IFC library and geometry engine
- **License**: LGPL-3.0, GPL-3.0
- **Owner**: IfcOpenShell
- **Stars**: 2.2k
- **Forks**: 814
- **Version**: v0.8.0
- **Generated by**: Automated crawler script (generate_ifcopenshell_docs.py)
- **Purpose**: LLM-ready documentation of IFC OpenShell Python API

This document contains the API documentation for IFC OpenShell, organized by module.
Each module has a description, list of available functions, and their docstrings where available.

## Module: root

### Description
Create, copy, or remove physical elements such as walls, doors, slabs, etc

This is one of the most used API modules and should be used any time you want
to create, remove, copy, or change a physical or spatial element. See
:func:`create_entity` to get started.

This module should also be used to create types. To then associate types with
elements, see :mod:`ifcopenshell.api.type`.

### Available Functions
- copy_class
- create_entity
- reassign_class
- remove_product

### Function Docstrings
#### copy_class
Copies a product

The following relationships are also duplicated:

* The copy will have the same object placement coordinates as the
  original.
* The copy will have duplicated property sets, properties, and quantities
* The copy will have all nested distribution ports copied too
* The copy will be part of the same aggregate
* The copy will be contained in the same spatial structure
* The copy, if it is an occurrence, will have the same type
* Voids are duplicated too
* The copy will have the same material as the original. Parametric
  material set usages will be copied.
* The copy will be part of the same groups as the original.

Be warned that:

* Representations are _not_ copied. Copying representations is an
  expensive operation so for now the user is responsible for handling
  representations.
* Filled voids are not copied, as there is no guarantee that the filling
  will also be copied.
* Path connectivity is not copied, as there is no guarantee that the
  connections are still valid.

:param product: The IfcProduct to copy.
:return: The copied product

Example:

.. code:: python

    # We have a wall
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # And now we have two
    wall_copy = ifcopenshell.api.root.copy_class(model, product=wall)

#### create_entity
Create a new rooted product

This is a critical function used to create almost any rooted product or
product type. If you want to create walls, spaces, buildings, wall
types, and so on, use this function.

Just specify the class you want to create, as well as the predefined
type and name. It will handle the storage of the predefined type and
check whether the predefined type is built-in or custom. It will also
generate a valid GlobalId and store ownership history. It will also
handle some edge cases for default validity where users might forget to
populate some mandatory attributes. For example, doors must define an
operation type but many people forget.

:param ifc_class: Any rooted IFC class.
:param predefined_type: Any built-in or user-defined predefined type that
    is applicable to that IFC class. For user-defined predefined types
    just enter in any value and the API will handle it automatically.
:param name: The name of the new element.
:return: The newly created element based on the specified IFC class.

Example:

.. code:: python

    # We have a project.
    ifcopenshell.api.root.create_entity(model, ifc_class="IfcProject")

    # We have a building.
    ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuilding")

    # We have a wall.
    ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # We have a wall type.
    ifcopenshell.api.root.create_entity(model, ifc_class="IfcWallType")

#### reassign_class
Changes the class of a product

If you ever created a wall then realised it's meant to be something
else, this function lets you change the IFC class whilst retaining all
other geometry and relationships.

This is especially useful when dealing with poorly classified data from
proprietary software with limited IFC capabilities.

If you are reassigning a type, the occurrence classes are also
reassigned to maintain validity.

Vice versa, if you are reassigning an occurrence, the type is also
reassigned in IFC4 and up. In IFC2X3, this may not occur if the type
cannot be unambiguously derived, so you are required to manually check
this.

Reassigning type class to occurrence (and vice versa) is supported.

:param product: The IfcProduct that you want to change the class of.
:param ifc_class: The new IFC class you want to change it to.
:param predefined_type: In case you want to change the predefined type
    too. User defined types are also allowed, just type what you want.
:param occurrence_class: IFC class to assign to occurrences in case
    if provided ``ifc_class`` is IfcTypeProduct.
    If omitted, class will be deduced automatically from the type.
    Only really needed in IFC2X3, since in IFC4+ there is no ambiguity on
    what class to assign to occurrences.
:return: The newly modified product.

Example:

.. code:: python

    # We have a wall.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # Oh, did I say wall? I meant slab.
    slab = ifcopenshell.api.root.reassign_class(model, product=wall, ifc_class="IfcSlab")

    # Warning: this will crash since wall doesn't exist any more.
    print(wall) # Kaboom.

#### remove_product
Removes a product

This is effectively a smart delete function that not only removes a
product, but also all of its relationships. It is always recommended to
use this function to prevent orphaned data in your IFC model.

This is intended to be used for removing:

- IfcAnnotation
- IfcElement
- IfcElementType
- IfcSpatialElement
- IfcSpatialElementType

For example, geometric representations are removed. Placement
coordinates are also removed. Properties are removed. Material, type,
containment, aggregation, and nesting relationships are removed (but
naturally, the materials, types, containers, etc themselves remain).

:param product: The element to remove.
:return: None

Example:

.. code:: python

    # We have a wall.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # No we don't.
    ifcopenshell.api.root.remove_product(model, product=wall)

## Module: aggregate

### Description
Aggregates is the concept of breaking down larger wholes into smaller parts.

For example, spatial elements such as sites are broken down into one or more
buildings, and a building is broken down into storeys. Another example is for
physical elements, such as how a wall is made out of members and coverings.

### Available Functions
- assign_object
- unassign_object

### Function Docstrings
#### assign_object
Assigns object as an aggregate to the products

All physical IFC model elements must be part of a hierarchical tree
called the "spatial decomposition", where large things are made up of
smaller things. This tree always begins at an "IfcProject" and is then
broken down using "decomposition" relationships, of which aggregation is
the first relationship you will use.

Typically used when you want to describe how large spaces are made up of
smaller spaces. For example large spatial elements (e.g. sites,
buidings) can be made out of smaller spatial elements (e.g. storeys,
spaces).

The largest space (typically the IfcSite) can then be aggregated in a
project. It is requirement for all spatial structures to be directly or
indirectly aggregated back to the IfcProject to create a hierarchy of
spaces.

The other common usecase is when larger physical products are made up of
smaller physical products. For example, a stair might be made out of a
flight, a landing, a railing and so on. Or a wall might be made out of
stud members, and coverings.

As a product may only have a single location in the "spatial
decomposition" tree, assigning an aggregate relationship will remove any
previous aggregation, containment, or nesting relationships it may have.

IFC placements follow a convention where the placement is relative to
its parent in the spatial hierarchy. If your product has a placement,
its placement will be recalculated to follow this convention.

:param products: The list of parts of the aggregate, typically of IfcElement or
    IfcSpatialStructureElement subclass
:param relating_object: The whole of the aggregate, typically an
    IfcElement or IfcSpatialStructureElement subclass
:return: The IfcRelAggregate relationship instance
    or `None` if `products` was empty list.

Example:

.. code:: python

    project = ifcopenshell.api.root.create_entity(model, ifc_class="IfcProject")
    element = ifcopenshell.api.root.create_entity(model, ifc_class="IfcSite")
    subelement = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuilding")

    # The project contains a site (note that project aggregation is a special case in IFC)
    ifcopenshell.api.aggregate.assign_object(model, products=[element], relating_object=project)

    # The site has a building
    ifcopenshell.api.aggregate.assign_object(model, products=[subelement], relating_object=element)

#### unassign_object
Unassigns products from their aggregate

A product (i.e. a smaller part of a whole) may be aggregated into zero
or one larger space or element. This function will remove that
aggregation relationship.

As all physical IFC model elements must be part of a hierarchical tree
called the "spatial decomposition", using this function will remove the
product from that tree. This is a dangerous operation and may result in
the product no longer being visible in IFC applications.

If the product is not part of an aggregation relationship, nothing will
happen.

:param products: The list of parts of the aggregate, typically of IfcElements or
    IfcSpatialStructureElement subclass
:return: None

Example:

.. code:: python

    element = ifcopenshell.api.root.create_entity(model, ifc_class="IfcSite")
    subelement1 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuilding")
    subelement2 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuilding")
    ifcopenshell.api.aggregate.assign_object(model, products=[subelement1], relating_object=element)
    ifcopenshell.api.aggregate.assign_object(model, products=[subelement2], relating_object=element)
    # nothing is returned
    ifcopenshell.api.aggregate.unassign_object(model, products=[subelement1])
    # nothing is returned, relationship is removed
    ifcopenshell.api.aggregate.unassign_object(model, products=[subelement2])

## Module: alignment

### Description
Manages alignment layout (semantic definition) and alignment geometry (geometric definition).

This API is defined in terms of the semantic definition of an alignment. The corresponding geometric definition
is created and maintained automatically. The manditory zero length segment for the semantic and geometric definitions
are automatically created and maintained.

Alignments are created with stationing referents. Each layout segment is assigned a position referent that informs about
the start point of the segment. An example is the point of curvature of a horizontal circular curve. The referent is
nested to the segment representing the circular arc and is named with a indicator of the position and the station, e.g. "P.C. (145+98.32)"

This API does not determine alignment parameters based on rules, such as minimum curve radius as a function of design speed or sight distance.

This API is under development and subject to code breaking changes in the future.

Presently, this API supports:
    1. Creating alignments, both horizontal and vertical, using the PI method. Alignment definition can be read from a CSV file.
    2. Creating alignments segment by segment.
    3. Automatic creation of geometric definitions (IfcCompositeCurve, IfcGradientCurve, IfcSegmentedReferenceCurve)
    4. Automatic definition of stationing
    5. Automatic definition of alignment transition point referents
    6. Utility functions for printing business logical and geometric representations, as well as minimal geometry evaluations

Future versions of this API may support:
    1. Defining alignments using the PI method, including transition spirals
    2. Updating horizontal curve definitions by revising transition spiral parameters and circular curve radii
    3. Updating vertical curve definitions by revising horizontal length of curves
    4. Removing a segment at any location along a curve
    5. Adding a segment at any location along a curve

### Available Functions
- add_stationing_referent
- add_vertical_layout
- add_zero_length_segment
- create
- create_as_offset_curve
- create_as_polyline
- create_by_pi_method
- create_from_csv
- create_layout_segment
- create_representation
- create_segment_representations
- distance_along_from_station
- get_alignment
- get_alignment_layout_nest
- get_alignment_layouts
- get_alignment_segment_nest
- get_alignment_start_station
- get_axis_subcontext
- get_basis_curve
- get_cant_layout
- get_child_alignments
- get_curve
- get_curve_segment_transition_code
- get_horizontal_layout
- get_layout_curve
- get_layout_segments
- get_parent_alignment
- get_referent_nest
- get_vertical_layout
- has_zero_length_segment
- layout_horizontal_alignment_by_pi_method
- layout_vertical_alignment_by_pi_method
- name_segments
- register_referent_name_callback
- update_fallback_position

### Function Docstrings
#### add_stationing_referent
Adds an IfcReferent to the alignment with the Pset_Stationing property set.

:param alignment: the alignment to receive the referent
:param distance_along: distance along the alignment basis curve
:param station: station value
:param name: name to assign to IfcReferent.Name, typically a stringized version of the station value
:param positioned_product: the product whose position is informed by the referent
:return: referent

Example:

.. code:: python

    alignment = model.by_type("IfcAlignment")[0]
    ifcopenshell.api.alignment.add_stationing_referent(model,alignment=alignment,distance_along=0.0,station=100.0)

#### add_vertical_layout
Adds a vertical layout to a previously created alignment.

If this is the first vertical layout assigned to the parent_alignment the IFC CT 4.1.4.4.1.1 Alignment Layout - Horizontal, Vertical and Cant
is followed. If this is the second or subsequent vertical layout assigned to the parent_alignment the
IFC CT 4.1.4.4.1.2 Alignment Layout - Reusing Horizontal Layout is followed.

When the second vertical layout is added, the structure of the IFC model must transition from one concept template to the other.
Specifically, the following occurs:

1) The first child IfcAlignment is created and is IfcRelAggregates with the parent alignment.
2) The first vertical layout is unassigned from the IfcRelNests of the parent alignment and is IfcRelNests to the new child alignment.
3) A second child IfcAlignment is created and it is IfcRelAggregates with the parent alignment.
4) The vertical layout is IfcRelNests to the second child alignment

For the third and subsequent vertical layouts, a new child alignment is created and aggregated to the parent alignment.

A zero segment length terminated IfcGradientCurve is created for the new vertical layout

:param parent_alignment: The parent alignment
:return: The new vertical layout, including the manditory zero length segment

#### add_zero_length_segment
Adds a zero length segment to the end of a layout.

If the layout already has a zero length segment, nothing is changed.

:param layout: An IfcAlignmentHorizontal, IfcAlignmentVertical, IfcAlignmentCant, IfcCompositeCurve, IfcGradientCurve, IfcSegmentedReferenceCurve
:param include_referent: If True, an IfcReferent representing the ending point of the layout is included for IfcLinearElement layouts (i.e. business logic)
:return: True if segment is added

#### create
Creates a new alignment with a horizontal layout. Optionally, vertical and cant layouts can be created as well.
The geometric representations are created as well, unless they are explicitly excluded.
Zero length segments are added at the end of the layouts and geometric representations.
The alignment is automatically aggreated to the project if it exists.

Use get_horizontal_layout(alignment), get_vertical_layout(alignment) and get_cant_layout(alignment) to get the
 corresponding IfcAlignmentHorizontal, IfcAlignmentVertical, and IfcAlignmentCant layout entities.

If the alignment has Viennese Bend transition curves, create the segments in the cant layout before the horizontal layout using create_layout_segment().
The horizontal geometry in the Viennese Bend transition curves depends on the Viennese Bend cant parameters. create_layout_segment() automatically creates
the geometric representation from the semantic definition. The horizontal segment geometric representation will fail if the cant segment is not defined.

If geometric representations are created, the alignment stationing referent is also created using the start_station value. IfcReferent.ObjectPlacement
is required for linear positiion elements and IfcLinearPlacement is defined relative to alignment curve geometry.

:param file:
:param name: name assigned to IfcAlignment.Name
:param include_vertical: If True, IfcAlignmentVertical is created. IfcGradientCurve is created if include_geometry is True
:param include_cant: If True, IfcAlignmentCant is created. IfcSegmentedReferenceCurve is created if include_geometry is True
:param include_geometry: If True, the geometric representations are added
:param start_station: station value at the start of the alignment.
:return: Returns an IfcAlignment

#### create_as_offset_curve
Creates a new IfcAlignment with an IfcOffsetCurveByDistances representation.

The IfcAlignment is aggreated to IfcProject

:param file:
:param name: name assigned to IfcAlignment.Name
:param offsets: offsets from the basis curve that defines the offset curve, expected to be IfcOffsetCurveByDistances.
:param start_station: station value at the start of the alignment
:return: Returns an IfcAlignment

#### create_as_polyline
Creates a new IfcAlignment with an IfcPolyline representation.

The IfcAlignment is aggreated to IfcProject

:param file:
:param name: name assigned to IfcAlignment.Name
:param points: sequence of points defining the polyline
:param start_station: station value at the start of the alignment
:return: Returns an IfcAlignment

#### create_by_pi_method
Create an alignment using the PI layout method for both horizontal and vertical alignments.
If vpoints and lengths are omitted, only a horizontal alignment is created.

:param name: value for Name attribute
:param points: (X,Y) pairs denoting the location of the horizontal PIs, including start and end
:param radii: radii values to use for transition
:param vpoints: (distance_along, Z_height) pairs denoting the location of the vertical PIs, including start and end.
:param lengths: parabolic vertical curve horizontal length values to use for transition
:return: Returns an IfcAlignment

#### create_from_csv
Creates an alignment from PI data stored in a CSV file.

The format of the file is:

    X1,Y1,R1,X2,Y2,R2 ... Xn-1,Yn-1,Rn-1,Xn,Yn

    D1,Z1,L1,D2,Z2,L2 ... Dn-1,Zn-1,Ln-1,Dn,Zn

    D1,Z1,L1,D2,Z2,L2 ... Dn-1,Zn-1,Ln-1,Dn,Zn

    ...

where:
    X,Y are PI coordinates

    R is the horizontal circular curve radius

    D,Z are VPI coordinates as "Distance Along","Elevation"

    L is the horizontal length of a parabolic vertical transition curve

    R1 and Rn, as well as L1 and Ln are placeholders and not used. They are recommended to have values of 0.0.

    R2 and Rn-2 are the radii of the first and last horizontal curves.

    L2 and Ln-2 are the length of the first and last vertical curves.

The CSV file contains one horizontal alignment, zero, one, or more vertical alignments

:param filepath: path the to CSV file
:return: IfcAlignment

#### create_layout_segment
Creates a new IfcAlignmentSegment using the IfcAlignmentParameterSegment design parameters.
The new segment is appended to the layout alignment and the corresponding IfcCurveSegment is created in the geometric representation if it exists.

:param layout: The layout to receive the new layout segment. This parameter is expected to be IfcAlignmentHorizontal, IfcAlignmentVertical or IfcAlignmentCant
:param design_parameters: The parameters defining the segment. Expected to be the appropreate subclass of IfcAlignmentParameterSegment
:return: 4x4 matrix at end of segment as np.array intended to be used as the start point geometry for the next segment or None if there is the geometric representation is not defined.

#### create_representation
Creates the geometric representation of an alignment if it does not already exist.
This function is intended to be used when a model has only the semantic definition of an alignment
and you want to add the geometric representation.

If the alignments are complete, it is recommended that add_zero_length_segment is called after this method to ensure
the proper structure of the semantic and geometric definitions of the alignment

:param alignment: The alignment to create the representation.

#### create_segment_representations
Creates curve segment representations for the alignment for IFC CT 4.1.7.1.1.4. The alignment is expected to have representations
for "Axis/Curve2D" (horizontal only) or "FootPrint/Curve2D" and "Axis/Curve3D" (horizontal + vertical/cant). There is the additional
expectation that there is a 1-to-1 relationship between IfcAlignmentSegment and IfcCurveSegment.
That is, no Helmert curves in the alignment which have a 1-to-2 relationship

:param alignment: The alignment to create segment representations.

#### distance_along_from_station
Given a station, returns the distance along the horizontal alignment.

If the alignment does not have stationing defined with an IfcReferent, the start of the alignment is assumed
to be at station 0.0. That is, the station is the distance along.

.. note:: The current implementation does not account for station equations and assumes stationing is increasing along the alignment.

:param alignment: the alignment
:param station: station value
:return: distance along the horizontal alignment

Example:

.. code:: python

    alignment = model.by_type("IfcAlignment")[0] # alignment with start station 1+00.00
    dist_along = ifcopenshell.api.alignment.distance_along_from_station(model,alignment=alignment,station=200.0)
    print(dist_along) # 100.00

#### get_alignment
Returns the alignment that nests this layout

#### get_alignment_layout_nest
Searches for the IfcRelNest that contains IfcAlignmentHorizontal, IfcAlignmentVertical, or IfcAlignmentCant

:param alignment: the alignment
:return: Returns the IfcRelNests containing the alignment layout

#### get_alignment_layouts
Returns the layout alignments nested to this alignment

#### get_alignment_segment_nest
Searches for the IfcRelNest that contains IfcAlignmentSegment

:param layout: an alignment layout, expected to be one of IfcAlignmentHorizontal, IfcAlignmentVertical, or IfcAlignmentCant
:return: Returns the IfcRelNests

#### get_alignment_start_station
Returns the start station of the alignment. The starting station is defined by the first nested IfcReferent.
This is interpreted to mean the first IfcReferent with an occurance of Pset_Stationing.Station,
otherwise returns 0.0.

#### get_axis_subcontext
Returns the IfcGeometricRepresentationSubContext for Model, Axis, MODEL_VIEW. If one does not exist, it is created.

#### get_basis_curve
Returns the basis curve for an alignment. This curve is the geometric representation that is used
as the basis curve for vertical and cant alignments.

:param alignment: The alignment
:return: The geometric representation that is used as a basis curve, typically an IfcCompositeCurve, or None if the alignment does not have a representation

Example:

.. code:: python
    alignment = model.by_type("IfcAlignment")[0]
    composite_curve = ifcopenshell.api.alignment.get_basis_curve(alignment)

#### get_cant_layout
Returns the IfcAlignmentCant assocated with this alignment

#### get_child_alignments
Returns the aggregated child alignments to this alignment per CT 4.1.4.4.1.2 Alignment Layout - Reusing Horizontal Layout

Example:

.. code:: python

    alignment = model.by_type("IfcAlignment")[0]
    children = ifcopenshell.api.alignment.get_child_alignments(alignment)

#### get_curve
Returns the geometric representation curve for an alignment.
An alignment without layouts will have a curve of type IfcPolyLine or IfcIndexedPolyCurve
A horizontal only will have a curve of type IfcCompositeCurve
A horizontal+vertical will have a curve of type IfcGradientCurve
A horizontal+vertical+cant will have a curve of tyep IfcSegmentedReferenceCurve

:param alignment: The alignment
:return: The geometric representation of the alignemnt or None if the alignment does not have a representation

Example:

.. code:: python
    alignment = model.by_type("IfcAlignment")[0]
    gradient_curve = ifcopenshell.api.alignment.get_curve(alignment)

#### get_curve_segment_transition_code
Returns the IfcCurveSegment.Transition of segment based on a comparison of
the position, ref. direction, and curvature at the end of the segment and the start of next_segment.

:param segment: segment for which the position curve is being being determined
:param next_segment: next segment
:param position_tolerance: tolerance used for evaluation positions. The default is 1mm
:return: the transition code

#### get_horizontal_layout
Returns the IfcAlignmentHorizontal assocated with this alignment

#### get_layout_curve
Returns the representation curve for the layout. This will be an IfcCompositeCurve, IfcGradientCurve, or IfcSegmentReferenceCurve
for IfcAlignmentHorizontal, IfcAlignmentVertical, or IfcAlignmentCant, respectively.

:param layout: An alignment layout
:return: The geometric representation curve

Example:

.. code:: python
    alignment = model.by_type("IfcAlignment")[0]
    layout = ifcopenshell.api.get_horizontal_layout(alignment)
    composite_curve = ifcopenshell.api.alignment.get_layout_curve(layout)

#### get_layout_segments
Returns the IfcAlignmentSegment nested to this alignment layout

Example:

.. code:: python

    horizontal = model.by_type("IfcAlignmentHorizontal")[0]
    segments = ifcopenshell.api.alignment.get_layout_segments(horizontal)

#### get_parent_alignment
Returns the parent alignment. When multiple vertical alignments share a horizontal alignment
the horizontal alignment is nested to the parent alignment, a child alignment is aggregated
to the parent alignment for each vertical alignment, and the vertical alignment is nested with
its child alignment.

Example:

.. code:: python
    alignment = model.by_type("IfcAlignment")[0]
    parent = ifcopenshell.api.alignment.get_parent_alignment(alignment)

#### get_referent_nest
Searches for the IfcRelNest that contains IfcReferent. If one is not found, a empty IfcRelNests is created.

:param file:
:param alignment: The IfcAlignment which hosts IfcReferent
:return: Returns the IfcRelNests.

#### get_vertical_layout
Returns the IfcAlignmentVertical assocated with this alignment

#### has_zero_length_segment
Returns true if the layout ends with a zero length segment.

:param layout: An IfcAlignmentHorizontal, IfcAlignmentVertical, IfcAlignmentCant, IfcCompositeCurve, IfcGradientCurve, or IfcSegmentedReferenceCurve
:return: True if the zero length segment is present

#### layout_horizontal_alignment_by_pi_method
Appends IfcAlignmentHorizontalSegment to a previously defined IfcAlignmentHorizontal using the PI layout method.
The zero length segment is updated.

:param file: file
:param layout: An IfcAlignmentHorizontal layout
:param hpoints: (X, Y) pairs denoting the location of the horizontal PIs, including start (POB) and end (POE).
:param radii: radius values to use for transition
:return: None

#### layout_vertical_alignment_by_pi_method
Appends IfcAlignmentVerticalSegment to a previously defined IfcAlignmentVertical using the PI layout method.
The zero length segment is updated.

:param file: file
:param layout: An IfcAlignmentVertical layout
:param vpoints: (distance_along, Z_height) pairs denoting the location of the vertical PIs, including start and end.
:param lengths: horizontal length of parabolic vertical curves
:return: None

#### name_segments
Sets the IfcAlignmentSegment.Name attribute using a prefix and sequence number (e.g. "H1" for horizontal, "V1" for vertical, "C1" for cant)

:param prefix: The naming prefix
:param layout: The layout alignment whose segments are to be named. This should be a IfcAlignmentHorizontal, IfcAlignmentVertical or IfcAlignmentCant

#### register_referent_name_callback
Error fetching: HTTP Error 404: Not Found

#### update_fallback_position
Updates the IfcLinearPlacement.CartesianPoint fallback position.

If the CartesianPosition is not assigned to the IfcLinearPlacement, one will be created

:param lp: The linear placement
:return: None

## Module: attribute

### Description
Basic modification of the attributes of an element.

All IFC entities have attributes. Some of these attributes contain rules about
inheritance and what they are allowed to contain. These usecases make sure that
any editing complies with these rules.

### Available Functions
- edit_attributes

### Function Docstrings
#### edit_attributes
Edit the attributes of a product

All IFC entities have attributes. Normally they can be edited directly,
by simply assigning a new value to them. In some scenarios, you may wish
to also ensure that ownership history is updated. This function provides
that convenience.

The method will maintain consistency for PredefinedType attribute
based on whether ElementType/ObjectType and whether occurrence is typed:

- PredefinedType and ObjectType to be `None` if occurrence is typed
- PredefinedType to be "NOTDEFINED" if ElementType/ObjectType is None
- PredefinedType to be "USERDEFINED" if ElementType/ObjectType is not None

:param product: The product you want to edit. This may be any rooted IFC
    entity.
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    element = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")
    ifcopenshell.api.attribute.edit_attributes(model,
        product=element, attributes={"Name": "Waldo"})

## Module: boundary

### Description
Boundaries are primarily used for representing virtual interfaces between
spaces for energy analysis.

Boundaries may be associated with spaces or physical elements that enclose
spaces such as walls, doors, and windows.

### Available Functions
- assign_connection_geometry
- copy_boundary
- edit_attributes
- remove_boundary

### Function Docstrings
#### assign_connection_geometry
Create and assign a connection geometry to a space boundary relationship

A space boundary may optionally have a plane that represents how that
space is adjacent to another space, known as the connection geometry.
You may specify this plane in terms of an outer boundary polyline, zero
or more inner boundaries (such as for windows), and a positional matrix
for the orientation of the plane.

:param rel_space_boundary: The space boundary relationship to assign the
    connection geometry to.
:param outer_boundary: A list of 2D points representing an open
    polyline.  The last point will connect to the first point. Each
    point is represented by an interable of 2 floats. The coordinates of
    the points are relative to the positional matrix arguments.
:param inner_boundaries: A list of zero or more inner boundaries to use
    for the plane. Each boundary is represented by an open polyline, as
    defined by the outer_boundary argument.
:param location: The local origin of the connection geometry, defined as
    an XYZ coordinate relative to the placement of the space that is
    being bounded.
:param axis: The local X axis of the connection geometry, defined as an
    XYZ vector relative to the placement of the space that is being
    bounded.
:param ref_direction: The local Z axis of the connection geometry,
    defined as an XYZ vector relative to the placement of the space that
    is being bounded. The Y vector is automatically derived using the
    right hand rule.
:param unit_scale: The unit scale as calculated by
    ifcopenshell.util.unit.calculate_unit_scale. If not provided, it
    will be automatically calculated for you.
:return: None

Example:

.. code:: python

    ifcopenshell.api.boundary.assign_connection_geometry(model,
        rel_space_boundary=element,
        outer_boundary=[(0., 0.), (1., 0.), (1., 1.), (0., 1.)],
        location=[0., 0., 0.], axis=[1., 0., 0.], ref_direction=[0., 0., 1.],
        )

#### copy_boundary
Copies a space boundary

:param boundary: The IfcRelSpaceBoundary you want to copy.
:return: Duplicate of the IfcRelSpaceBoundary

Example:

    # A boring boundary with no geometry. Note that this boundary is
    # invalid and does not relate to any space or building element.
    boundary = ifcopenshell.api.root.create_entity(model, ifc_class="IfcRelSpaceBoundary")

    # And now we have two
    boundary_copy = ifcopenshell.api.boundary.copy_boundary(model, boundary=boundary)

#### edit_attributes
Modify the relationships of a space boundary relationship

Currently this function is quite minimal and offers no advantage to
manual assignment of the space boundary attributes.

:param entity: The IfcRelSpaceBoundary to modify
:param relating_space: The IfcSpace or IfcExternalSpatialElement that
    the space boundary is related to.
:param related_building_element: The IfcElement that defines the
    boundary, typically an IfcWall.
:param parent_boundary: A parent IfcRelSpaceBoundary, only provided if
    this is an inner boundary. This can apply to 1st and 2nd level
    boundaries.
:param corresponding_boundary: The other IfcRelSpaceBoundary on the
    other side of the related element. The pair together represents a
    thermal boundary. This only applies to 2nd level boundaries.
:return: None

#### remove_boundary
Removes a space boundary

The relating space or related building element is untouched. Only the
boundary and its connection geometry is removed.

:param boundary: The IfcRelSpaceBoundary you want to remove.
:return: None

Example:

    # A boring boundary with no geometry. Note that this boundary is
    # invalid and does not relate to any space or building element.
    boundary = ifcopenshell.api.root.create_entity(model, ifc_class="IfcRelSpaceBoundary")

    # Let's remove it!
    ifcopenshell.api.boundary.remove_boundary(model, boundary=boundary)

## Module: classification

### Description
Classification systems are a way of categorising objects

Although IFC itself comes with a built-in classification hierarchy (e.g.
IfcWall and its predefined types of PARTITIONING, etc), there are many external
or custom classification systems such as Uniclass, Omniclass and more. IFC is
able to integrate with any external classification system.

This API allows you to manage and assign external classification systems and
references.

### Available Functions
- add_classification
- add_reference
- edit_classification
- edit_reference
- remove_classification
- remove_reference

### Function Docstrings
#### add_classification
Adds a new classification system to the project

External classification systems such as Uniclass or Omniclass are
ways of categorising elements in the AEC industry, typically
standardised or nominated by governments or companies. A system
typically contains a series of hierarchical reference codes and labels
like Pr_12_23_34.

Classifications may be applied to many things, not just physical
elements, such as doors and windows, spatial elements, tasks, cost
items, or even resources.

Prior to assigning classificaion references, you need to add the name
and metadata of the classification system that you will use in your
project. Classification systems may be revised over time, so this
metadata includes the edition date.

Common classification systems are provided as an IFC library which may
be downloaded from https://github.com/Moult/IfcClassification for your
convenience. It is advised to use these to ensure that the
classification metadata is standardised.

Adding a classification system will not add the entire hierarchy of
references available in the classification. References need to be added
separately. Typically, you'd only add the references that you use in
your project, see ifcopenshell.api.classification.add_reference for more
information.

:param classification: If a string is provided, it is assumed to be the
    name of your classification system. This is necessary if you are
    creating your own custom classification system. Alternatively, you
    may provide an entity_instance of an IfcClassification from an IFC
    classification library. The latter approach is preferred if you are
    using a commonly known system such as Uniclass, as this will ensure
    all metadata is added correctly.
:return: The added IfcClassification element

Example:

.. code:: python

    # Option 1: adding a custom clasification from scratch
    ifcopenshell.api.classification.add_classification(model,
        classification="MyCustomClassification")

    # Option 2: adding a popular classification from a library
    library = ifcopenshell.open("/path/to/Uniclass.ifc")
    classification = library.by_type("IfcClassification")[0]
    ifcopenshell.api.classification.add_classification(model,
        classification=classification)

#### add_reference
Adds a new classification reference and assigns it to the list of products

A classification reference is a single entry such as "Pr_12_23_34" that
is part of an external classification system (such as Uniclass or
Omniclass).

References can be added to almost any object in IFC, including physical
objects, object types, properties, tasks, costs, resources, or even
resources such as profiles, documents, libraries, and so on.

Classification references can be added in two ways. Option 1) specify  a
custom arbitrary reference, where you have to manually specify the
identification (e.g. "Pr_12_23_45") and name (e.g. "Door Products").
Option 2) add a reference from an IFC classification library. The latter
is preferred if you are using a common classification system such as
Uniclass, as the library will be prepopulated with all the valid
classifications already.

Objects are allowed to have multiple classification references from
multiple classification systems. This means that adding a new reference
will not remove existing references.

References can be inherited from types. This means that if an
IfcWallType has a classification reference of Pr_12_23_34, then all
IfcWall occurrences of that type automatically get the same
classification of Pr_12_23_34. This means that it is more efficient to
assign to types where possible. If a classification reference is
assigned to both the type and an occurrence, then the assignment at the
occurrence will override the type classification.

:param product: The list of IFC objects, properties, or resources you want to
    associate the classification reference to.
:param reference: The classification reference entity taken from an
    IFC classification library. If you supply this parameter, you will
    use option 2.
:param identification: If you choose option 1 and do not specify a
    reference, you may manually specify an identification code. The code
    is typically a short identifier and may have punctuation to separate
    the levels of hierarchy in the classificaion (e.g. Pr_12_23_34).
:param name: If you choose option 1 and do not specify a reference, you
    may manually specify a name. The name is typically human readable.
:param classification: The IfcClassification entity in your IFC model
    (not the library, if you are doing option 2) that the reference is
    part of.
:param is_lightweight: If you are doing option 2, choose whether or not
    to only add that particular reference (lighweight) or also add all
    of its parent references in the classification hierarchy (not
    lighweight). For example, adding a lightweight reference to
    Pr_12_23_34 will only add Pr_12_23_34, but adding a heavy reference
    to Pr_12_23_34 will also add Pr_12_23 and Pr_12. These parent
    references merely help describe the "tree" of classifications, but
    is generally unnecessary. Using lightweight classifications are
    recommended and is the default.

:raises TypeError: If file is IFC2X3 and `products` has non-IfcRoot elements.

:return: The newly added IfcClassificationReference
    or `None` if `products` was empty list.

Example:

.. code:: python

    # Option 1: adding and assigning a new reference from scratch
    wall_type = model.by_type("IfcWallType")[0]
    classification = ifcopenshell.api.classification.add_classification(
        model, classification="MyCustomClassification")
    ifcopenshell.api.classification.add_reference(model,
        products=[wall_type], classification=classification,
        identification="W_01", name="Interior Walls")

    # Option 2: adding a popular classification from a library
    library = ifcopenshell.open("/path/to/Uniclass.ifc")
    lib_classification = library.by_type("IfcClassification")[0]
    classification = ifcopenshell.api.classification.add_classification(
        model, classification=lib_classification)
    reference = [r for r in library.by_type("IfcClassificationReference")
        if r.Identification == "XYZ"][0]
    ifcopenshell.api.classification.add_reference(model,
        products=[wall_type], classification=classification,
        reference=reference)

#### edit_classification
Edits the attributes of an IfcClassification

For more information about the attributes and data types of an
IfcClassification, consult the IFC documentation.

:param classification: The IfcClassification entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    classification = model.by_type("IfcClassification")[0]
    # Change the name of the classification system to "Foo"
    ifcopenshell.api.classification.edit_classification(model,
        classification=classification, attributes={"Name": "Foo"})

#### edit_reference
Edits the attributes of an IfcClassificationReference

For more information about the attributes and data types of an
IfcClassificationReference, consult the IFC documentation.

:param reference: The IfcClassificationReference entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    reference = model.by_type("IfcClassification")[0]
    # Change the name of the reference to "Foo"
    ifcopenshell.api.classification.edit_reference(model,
        reference=reference, attributes={"Name": "Foo"})

#### remove_classification
Removes an IfcClassification from the project and all references

The classification and all of its relationships, children references,
and relationships between objects and child references are completely
removed from a project.

:param classification: The IfcClassification entity you want to remove
:return: None

Example:

.. code:: python

    classification = model.by_type("IfcClassification")[0]
    ifcopenshell.api.classification.remove_classification(model,
        classification=classification)

#### remove_reference
Removes a classification reference from the list of products

If the classification reference is no longer associated to any products,
the classification reference itself is also removed.

:param reference: The IfcClassificationReference entity of the
    relationship you want to remove.
:param product: The list fo object entities of the relationship you want to
    remove.

:raises TypeError: If file is IFC2X3 and `products` has non-IfcRoot elements.

:return: None

Example:

.. code:: python

    wall_type = model.by_type("IfcWallType")[0]
    classification = ifcopenshell.api.classification.add_classification(
        model, classification="MyCustomClassification")
    reference = ifcopenshell.api.classification.add_reference(model,
        products=[wall_type], classification=classification,
        identification="W_01", name="Interior Walls")
    ifcopenshell.api.classification.remove_reference(model,
        reference=reference, products=[wall_type])

## Module: cogo

### Description
Coordinate Geometry (cogo) functions primarily for survey points and control monument for layout, parcels, etc.

### Available Functions
- add_survey_point
- assign_survey_point
- bearing2dd
- edit_survey_point

### Function Docstrings
#### add_survey_point
Adds a single survey point to the model based on IFC Concept Template 4.1.7.1.2.5.
Survey points are located relative to IfcRepresentationContext.WorldCoordinateSystem

:param survey_point: The survey point
:return: an IfcAnnotation entity

Example:

.. code:: python

    annotation = ifcopenshell.api.cogo.add_survey_point(file,file.createIfcCartesianPoint(4000.0,3500.0)))

#### assign_survey_point
Assigns a coordinate point to a survey point annotation

:param annotaton: The survey point annotation
:param survey_point: The survey point
:return: None

Example:

.. code:: python

    annotation = ifcopenshell.api.cogo.add_survey_point(file,file.createIfcCartesianPoint(4000.0,3500.0)))
    ifcopenshell.api.cogo.assign_surve_point(annotation,file.createIfcCartesianPoint(4000.0,3500.0,100.0))

#### bearing2dd
Converts a quadrant bearing string to decimal degrees

The format of the string is "N|S dd (mm (ss.s)) E|W"
where:
N|S is N or S for North or South
dd is degree (required)
mm is minute (optional, but required if second is provided)
ss.s is second (required)
E|W is E or W for East or West

:param str: the bearing string
:return: Angle in radian

#### edit_survey_point
Edits the location of a previously defined survey point

:param survey_point: The survey point
:return: None

Example:

.. code:: python

    annotation = ifcopenshell.api.cogo.add_survey_point(file,file.createIfcCartesianPoint(4000.0,3500.0)))
    ifcopenshell.api.cogo.edit_surve_point(annotation,3500.0,2000.0)

## Module: constraint

### Description
Constraints are an advanced feature allowing you to specify parametric
limits on properties

Warning: usage of constraints are mostly untested in real life applications.

### Available Functions
- add_metric
- add_metric_reference
- add_objective
- assign_constraint
- edit_metric
- edit_objective
- remove_constraint
- remove_metric
- unassign_constraint

### Function Docstrings
#### add_metric
Add a new metric benchmark

Qualitative constraints may have a series of quantitative benchmarks
linked to it known as metrics. Metrics may be parametrically linked to
computed model properties or quantities. Metrics need to be satisfied
to meet the objective of the constraint.

:param objective: The IfcObjective that this metric is a benchmark of.
:return: The newly created IfcMetric entity

Example:

.. code:: python

    objective = ifcopenshell.api.constraint.add_objective(model)
    metric = ifcopenshell.api.constraint.add_metric(model,
        objective=objective)

#### add_metric_reference
Adds a chain of references to a metric. The reference path is a string of the form "attribute.attribute.attribute"
Used to reference a value of an attribute of an instance through a metric objective entity.

#### add_objective
Add a new objective constraint

Parametric constraints may be defined by the user. The constraint is defined
by first creating an objective describing the purpose of the constraint and
whether it is a hard or soft constraint. Later on, metrics may be added to
check whether the constraint has been met by connecting it to properties and
quantities. See ifcopenshell.api.constraint.add_metric for more information.

:return: The newly created IfcObjective entity

Example:

.. code:: python

    # Create a new objective for code compliance requirements
    objective = ifcopenshell.api.constraint.add_objective(model)
    objective.ConstraintGrade = "ADVISORY"
    objective.ObjectiveQualifier = "CODECOMPLIANCE"
    # Note: the objective right now is purely qualitative and for
    # information purposes. You may wish to add quantiative metrics.

#### assign_constraint
Assigns a constraint to a list of products

This assigns a relationship between a product and a constraint, so that
when a product's properties and quantities do not match the requirements
of the constraint's metrics, results can be flagged.

It is assumed (but not explicit in the IFC documentation) that
constraints are inherited from the type. This way, it is not necessary
to create lots of constraint assignments.

:param products: The list of products the constraint applies to. This is anything
    which can have properties or quantities.
:param constraint: The IfcObjective constraint
:return: The new or updated IfcRelAssociatesConstraint relationship
    or `None` if `products` was an empty list.

#### edit_metric
Edit the attributes of a metric

For more information about the attributes and data types of an
IfcMetric, consult the IFC documentation.

:param metric: The IfcMetric you want to edit.
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    objective = ifcopenshell.api.constraint.add_objective(model)
    metric = ifcopenshell.api.constraint.add_metric(model,
        objective=objective)
    ifcopenshell.api.constraint.edit_metric(model,
        metric=metric, attributes={"ConstraintGrade": "HARD"})

#### edit_objective
Edit the attributes of a objective

For more information about the attributes and data types of an
IfcObjective, consult the IFC documentation.

:param objective: The IfcObjective you want to edit.
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    objective = ifcopenshell.api.constraint.add_objective(model)
    ifcopenshell.api.constraint.edit_objective(model,
        objective=objective, attributes={"ConstraintGrade": "HARD"})

#### remove_constraint
Remove a constraint (typically an objective)

Removes a constraint definition and all of its associations to any
products. Typically this would be an IfcObjective, although technically
you can associate IfcMetrics ith products too, though the meaning may be
unclear.

:param constraint: The IfcObjective you want to remove.
:return: None

Example:

.. code:: python

    objective = ifcopenshell.api.constraint.add_objective(model)
    ifcopenshell.api.constraint.remove_constraint(model,
        constraint=objective)

#### remove_metric
Remove a metric benchmark

Removes a metric benchmark and all of its associations to any products
and objectives.

:param metric: The IfcMetric you want to remove.
:return: None

Example:

.. code:: python

    objective = ifcopenshell.api.constraint.add_objective(model)
    metric = ifcopenshell.api.constraint.add_metric(model,
        objective=objective)
    ifcopenshell.api.constraint.remove_metric(model,
        metric=metric)

#### unassign_constraint
Unassigns a constraint from a list of products

The constraint will not be deleted and is available to be assigned to
other products.

:param products: The list of products the constraint applies to.
:param constraint: The IfcObjective constraint
:return: None

## Module: context

### Description
Contexts allow you to classify when geometry should be used in different
purposes

For example, a door may have many geometries assigned to it: a 3D body
geometry, a clearance zone for disabled access and egress, and a 2D top down
plan view representation annotating swing extents. Each geometry is assigned to
a context to distinguish its purpose and level of detail.

### Available Functions
- add_context
- edit_context
- remove_context

### Function Docstrings
#### add_context
Adds a new geometric representation context

In IFC, physical objects may have zero, one, or multiple geometric
representations associated with it. For example, a building storey might
not have any geometry, but simply be a coordinate in space.
Alternatively, a wall might have a 3D body representation in the form of
a cuboid. As a final example, a door might also have a 3D body
representation of a 3D door panel and door frame, but may additionally
have a 2D door plan view representation of the door swing, and even a 2D
elevation view of the door, a 3D box representing the disabled clearance
zone of the door, a 2D profile representing the profile of the door to
cut out in a wall, and so on. In this situation, a door will have
multiple geometric representations.

To distinguish between the different purposes of multiple geometric
representations, each geometric representation must belong to a
geometric representation "context". There are typically always 2
contexts, one for 3D representations and one for 2D representations.
These 2 contexts then have subcontexts for things like the 3D body
representation, clearance representations, annotation representations,
and so on. Each representation of a physical IFC product (e.g. a door)
must be assigned to one of these subcontexts. Therefore setting up
appropriate contexts is critical prior to authoring any IFC model which
contains geometry.

There are two steps to setting up appropriate subcontexts. First, a 2D
and/or 3D context must be added. These must be always called the "Model"
context for 3D and the "Plan" context for 2D (even if the 2D geometry is
not a plan view). Then, one or more subcontexts are added using either
the "Model" or "Plan" as their parent. These subcontexts are further
distinguished using an "identifier" and "target view". The "identifier"
describes the purpose of the representation, and the "target view"
describes the typical diagrammatic presentation that context's geometry
should be viewed in. The most common identifiers you might use are:

- Body: for the actual shape of the object
- Box: the bounding box of the object (useful for shape analytics)
- Axis: the parametric line determining the shape of the object
- Profile: the elevation silhouette of the object, useful for cutting
      out holes for the object to fit into host elements
- Footprint: the plan view silhouette of the object, useful for certain
      quantity take-off rules
- Clearance: the clearance zone of the object
- Annotation: symbolic annotations typically used in diagrams or
      drawings

The most common "target views" you might use are:

- MODEL_VIEW: for 3D geometry you might see in a BIM viewer
- PLAN_VIEW: for 2D geometry you might see in a plan representation
- ELEVATION_VIEW: for 2D geometry you might see in an elevation representation
- SECTION_VIEW: for 2D geometry you might see in a section representation
- GRAPH_VIEW: for 2D or 3D line or frame or path connectivity diagrams
      you might use for structural frame analysis, axis-based parametric
      modeling
- SKETCH_VIEW: for viewing abstract high-level representations such as
      in bubble diagrams of spatial topology

This may sound like a lot, but after a few typical contexts are set up
at the beginning, it becomes easy to navigate and isolate geometry for
different purposes. There is also the concept of a target scale, which
represents the zoom level detail of geometry, but this is not currently
supported by this API. Setting up all these contexts are also optional,
and you may only use a single Model context and Body subcontext for
simple models, but this simplification sacrifices the ability of more
parametric or analytical usecases.

:param context_type: The type of the context, must be one of "Model" or
    "Plan" only.
:param context_identifier: The identifier of the context, chosen from
    one of the common identifiers above or consult the IFC documentation
    (under the IfcShapeRepresentation page) for more details. Optional
    for contexts, but mandatory for subcontexts.
:param target_view: the target view of the context, chosen from one of
    the common target views above or consult the IFC documentation
    (under the IfcShapeRepresentation page) for more details. Optional
    for contexts, but mandatory for subcontexts.
:param target_scale: It defines the intended scale at which the representation
    is designed to be viewed or printed
:param parent: the parent context. Must be left as None (the default)
    for contexts, and only set for subcontexts. Note that there are only
    contexts and subcontexts, a subcontext cannot have any children.
:return: the newly created IfcGeometricRepresentationContext or
    IfcGeometricRepresentationSubContext entity

Example:

.. code:: python

    # If we plan to store 3D geometry in our IFC model, we have to setup
    # a "Model" context.
    model3d = ifcopenshell.api.context.add_context(model, context_type="Model")

    # And/Or, if we plan to store 2D geometry, we need a "Plan" context
    plan = ifcopenshell.api.context.add_context(model, context_type="Plan")

    # Now we setup the subcontexts with each of the geometric "purposes"
    # we plan to store in our model. "Body" is by far the most important
    # and common context, as most IFC models are assumed to be viewable
    # in 3D.
    body = ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Body", target_view="MODEL_VIEW", parent=model3d)

    # The 3D Axis subcontext is important if any "axis-based" parametric
    # geometry is going to be created. For example, a beam, or column
    # may be drawn using a single 3D axis line, and for this we need an
    # Axis subcontext.
    ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Axis", target_view="GRAPH_VIEW", parent=model3d)

    # The 3D Box subcontext is useful for clash detection or shape
    # analysis, or even lazy-loading of large models.
    ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Box", target_view="MODEL_VIEW", parent=model3d)

    # It's also important to have a 2D Axis subcontext for things like
    # walls and claddings which can be drawn using a 2D axis line.
    ifcopenshell.api.context.add_context(model,
        context_type="Plan", context_identifier="Axis", target_view="GRAPH_VIEW", parent=plan)

    # A 2D annotation subcontext for plan views are important for door
    # swings, window cuts, and symbols for equipment like GPOs, fire
    # extinguishers, and so on.
    ifcopenshell.api.context.add_context(model,
        context_type="Plan", context_identifier="Annotation", target_view="PLAN_VIEW", parent=plan)

    # You may also create 2D annotation subcontexts for sections and
    # elevation views.
    ifcopenshell.api.context.add_context(model,
        context_type="Plan", context_identifier="Annotation", target_view="SECTION_VIEW", parent=plan)
    ifcopenshell.api.context.add_context(model,
        context_type="Plan", context_identifier="Annotation", target_view="ELEVATION_VIEW", parent=plan)

    # Let's create a new wall. The wall does not have any geometry yet.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # Let's use the "3D Body" representation we created earlier to add a
    # new wall-like body geometry, 5 meters long, 3 meters high, and
    # 200mm thick
    representation = ifcopenshell.api.geometry.add_wall_representation(model,
        context=body, length=5, height=3, thickness=0.2)

    # Assign our new body geometry back to our wall
    ifcopenshell.api.geometry.assign_representation(model,
        product=wall, representation=representation)

    # Place our wall at the origin
    ifcopenshell.api.geometry.edit_object_placement(model, product=wall)

#### edit_context
Edits the attributes of an IfcGeometricRepresentationContext

For more information about the attributes and data types of an
IfcGeometricRepresentationContext, consult the IFC documentation.

:param context: The IfcGeometricRepresentationContext entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    model = ifcopenshell.api.context.add_context(model, context_type="Model")
    # Revit had a bug where they incorrectly called the body representation a "Facetation"
    body = ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Facetation", target_view="MODEL_VIEW", parent=model
    )

    # Let's fix it!
    ifcopenshell.api.context.edit_context(model,
        context=body, attributes={"ContextIdentifier": "Body"})

#### remove_context
Removes an IfcGeometricRepresentationContext

Any representation geometry that is assigned to the context is also
removed. If a context is removed, then any subcontexts are also removed.

:param context: The IfcGeometricRepresentationContext entity to remove
:return: None

Example:

.. code:: python

    model = ifcopenshell.api.context.add_context(model, context_type="Model")
    # Revit had a bug where they incorrectly called the body representation a "Facetation"
    body = ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Facetation", target_view="MODEL_VIEW", parent=model
    )

    # Let's just get rid of it completely
    ifcopenshell.api.context.remove_context(model, context=body)

## Module: control

### Description
Processes and costs may be controlled by other entities which indicate
constraints that determine how they can change

This is an advanced feature mostly used in 4D/5D

### Available Functions
- assign_control
- unassign_control

### Function Docstrings
#### assign_control
Assigns a planning control or constraint to a list of objects.

IFC can describe concepts that control other objects. For example, a
planning calendar controls the availability of working days for
construction planning. As another example, a cost item might constrain
or limit the ability to procure and build a product.

This usecase lets you assign controls following the rules of the IFC
specification. This is an advanced topic and assumes knowledge of the
IFC concepts to determine what is allowed to control what. In the
future, this API will likely be deprecated in favour of multiple usecase
specific APIs.

:param relating_control: The IfcControl entity that is creating the
    control or constraint
:param related_objects: The list of IfcObjectDefinition that is being controlled
:return: The newly created IfcRelAssignsToControl. If relationship already
    existed before and wasn't changed then returns None.

Example:

.. code:: python

    # One common usecase is to assign a calendar to a task
    calendar = ifcopenshell.api.sequence.add_work_calendar(model)
    schedule = ifcopenshell.api.sequence.add_work_schedule(model)
    task = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule)

    # All subtasks will inherit this calendar, so assigning a single
    # calendar to the root task effectively defines a "default" calendar
    ifcopenshell.api.control.assign_control(model,
        relating_control=calendar, related_objects=[task])

    # Another common example might be relating a cost item and a product
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")
    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    cost_item = ifcopenshell.api.cost.add_cost_item(model,
        cost_schedule=schedule)
    ifcopenshell.api.control.assign_control(model,
        relating_control=cost_item, related_objects=[wall])

#### unassign_control
Unassigns a planning control or constraint to an object

:param relating_control: The IfcControl entity that is creating the
    control or constraint
:param related_objects: The list IfcObjectDefinitions that is being controlled
:return: None

Example:

.. code:: python

    # Let's relate a cost item and a product
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")
    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    cost_item = ifcopenshell.api.cost.add_cost_item(model,
        cost_schedule=schedule)
    ifcopenshell.api.control.assign_control(model,
        relating_control=cost_item, related_objects=[wall])

    # And now let's change our mind
    ifcopenshell.api.control.unassign_control(model,
        relating_control=cost_item, related_objects=[wall])

## Module: cost

### Description
Manage cost schedules, cost items, cost estimation and parametric quantity
take-off

IFC supports storing cost schedules and detailed cost breakdown structures,
including formulas, subtotals, and parametric links to model element
quantities.

### Available Functions
- add_cost_item
- add_cost_item_quantity
- add_cost_schedule
- add_cost_value
- assign_cost_item_quantity
- assign_cost_value
- calculate_cost_item_resource_value
- copy_cost_item
- copy_cost_item_values
- copy_cost_schedule
- edit_cost_item
- edit_cost_item_quantity
- edit_cost_schedule
- edit_cost_value
- edit_cost_value_formula
- remove_cost_item
- remove_cost_item_quantity
- remove_cost_schedule
- remove_cost_value
- unassign_cost_item_quantity

### Function Docstrings
#### add_cost_item
Add a new cost item

A cost item represents a single line item in a cost schedule. Cost items
may then be broken down into cost subitems.

Either `cost_schedule` or `cost_item` must be provided.

:param cost_schedule: If the cost item is to be added as a root or top
    level cost item to a cost schedule, the IfcCostSchedule may be
    specified. This is mutually exlclusive to the cost_item parameter.
:param cost_item: If the cost item is to be added as a subitem to an
    existing cost item, the parent IfcCostItem may be specified. This is
    mutually exclusive to the cost_schedule parameter.
:return: The newly created IfcCostItem

Example:

.. code:: python

    # The very first cost item must be in a cost schedule
    schedule = ifcopenshell.api.cost.add_cost_schedule(model)

    # You may add cost items as top level item in the schedule
    item1 = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)

    # Alternatively you may add them as subitems
    item2 = ifcopenshell.api.cost.add_cost_item(model, cost_item=item1)

#### add_cost_item_quantity
Adds a new quantity associated with a cost item

Cost items calculate their subtotal by multiplying the sum of the cost
item's "values" by the sum of the cost item's "quantities". The
quantities may be either parametrically linked to quantities measured on
physical product, or manually specified.

The quantity must be of a particular type, common examples are:

- IfcQuantityCount: to count the total occurrences of a product, useful
  for things like doors, windows, and furniture
- IfcQuantityNumber: any other generic numeric quantity
- IfcQuantityLength
- IfcQuantityArea
- IfcQuantityVolume
- IfcQuantityWeight
- IfcQuantityTime

A cost item must not mix quantities of different types.

If an IfcQuantityCount is used, then this API will automatically count
all products that this cost item controls (see
ifcopenshell.api.controls.assign_control) and prefill that quantity.

For all other quantity types, the quantity is left as zero and the user
must either manually specify the quantity or parametrically link it
using another API call.

:param cost_item: The IfcCostItem to add the quantity to
:param ifc_class: The type of quantity to add
:return: The newly created quantity entity, chosen from the ifc_class
    parameter

Example:

.. code:: python

    chair = ifcopenshell.api.root.create_entity(model, ifc_class="IfcFurniture")
    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)
    ifcopenshell.api.control.assign_control(model,
        relating_control=item, related_objects=[chair])

    # Let's assume we want to count the amount of chairs to calculate our cost item
    # Because this is an IfcQuantityCount the count will be automatically set to "1" chair
    ifcopenshell.api.cost.add_cost_item_quantity(model,
        cost_item=item, ifc_class="IfcQuantityCount")

#### add_cost_schedule
Add a new cost schedule

A cost schedule is a group of cost items which typically represent a
cost plan or breakdown of the project. This may be used as an estimate,
bid, or actual cost.

Alternatively, a cost schedule may also represent a schedule of rates,
which include cost items which capture unit rates for different elements
or processes.

As such, creating a cost schedule is necessary prior to creating and
managing any cost items.

:param name: The name of the cost schedule.
:param predefined_type: The predefined type of the cost schedule, chosen
    from a valid type in the IFC documentation for
    IfcCostScheduleTypeEnum
:return: The newly created IfcCostSchedule entity

Example:

.. code:: python

    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    # Now that we have a cost schedule, we may add cost items to it
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)

#### add_cost_value
Adds a new value or subvalue to a cost item

A cost item's subtotal can be specified in two ways.

Option 1 is by simply manually specifying the subtotal value, which
represents the full cost of that cost item. This option occurs when a
cost item has no quantities associated with it.

Option 2 is by specifying a unit cost value of the cost item, which is
then multiplied by the associated quantity of the cost item, to give us
the subtotal. This option occurs when a cost item has quantities
associated with it.

For either option 1 (full cost value) or option 2 (unit cost value), the
cost value may be specified as a single number, or as a sum of
subcomponents or formulas (e.g. multiplication by wastage factor, or
adding taxes or other adjustments).

This function lets you add a single top level unit value to a cost item,
or alternatively price subcomponents by using the "parent" parameter.

More advanced usage, which involves summing, subcategory-filtered costs,
and formulas are possible but not yet documented.

:param parent: A parent IfcCostItem, if specifying a price directly to a
    cost item, or a top-level price component. Alternatively, this can
    be set to a IfcCostValue, if specifying price subcomponents.
:return: The newly created IfcCostValue

Example:

.. code:: python

    # We always need a schedule first prior to adding any cost items
    schedule = ifcopenshell.api.cost.add_cost_schedule(model)

    # Option 1: This cost item will have a full cost of 42.0
    item1 = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)
    value = ifcopenshell.api.cost.add_cost_value(model, parent=item1)
    ifcopenshell.api.cost.edit_cost_value(model, cost_value=value,
        attributes={"AppliedValue": 42.0})

    # Option 2: This cost item will have a unit cost of 5.0 per unit
    # area, multiplied by the quantity of area specified explicitly as
    # 3.0, giving us a subtotal cost of 15.0.
    item2 = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)
    value = ifcopenshell.api.cost.add_cost_value(model, parent=item2)
    ifcopenshell.api.cost.edit_cost_value(model, cost_value=value,
        attributes={"AppliedValue": 5.0})
    quantity = ifcopenshell.api.cost.add_cost_item_quantity(model,
        cost_item=item2, ifc_class="IfcQuantityVolume")
    ifcopenshell.api.cost.edit_cost_item_quantity(model,
        physical_quantity=quantity, "attributes": {"VolumeValue": 3.0})

    # A cost value may also be specified in terms of the sum of its
    # subcomponents. In this case, it's broken down into 2 subvalues.
    item1 = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)
    value = ifcopenshell.api.cost.add_cost_value(model, parent=item1)
    subvalue1 = ifcopenshell.api.cost.add_cost_value(model, parent=value)
    subvalue2 = ifcopenshell.api.cost.add_cost_value(model, parent=value)

    # This specifies that the value is the sum of all subitems
    # regardless of their cost category. The first subvalue is 2.0 and
    # the second is 3.0, giving a total value of 5.0.
    ifcopenshell.api.cost.edit_cost_value(model, cost_value=value, attributes={"Category": "*"})
    ifcopenshell.api.cost.edit_cost_value(model,
        cost_value=subvalue1, attributes={"AppliedValue": 2.0})
    ifcopenshell.api.cost.edit_cost_value(model,
        cost_value=subvalue2, attributes={"AppliedValue": 3.0})

#### assign_cost_item_quantity
Adds a cost item quantity that is parametrically connected to a product

A cost item may have its subtotal calculated by multiplying a unit value
by a quantity associated with the cost item. That quantity may be either
manually specified or parametrically connected to a quantity on a
product. This API function lets you create that parametric connection.

For example, you may wish to have a cost item linked to the "NetVolume"
quantity on all IfcSlabs. Each quantity has a name which you can
specify. If the quantity is updated in-place (which should occur for
Native IFC applications) then the quantity for the cost item will
automatically update as well. If the quantity is deleted and then
re-added, then the parametric relationship is also lost.

This API also automatically assigns a control relationship between the
cost item and the product, so it is not necessary to use
ifcopenshell.api.control.assign_control.

If cost item has just 1 quantity and it's IfcQuantityCount, API will
assume that quantity is used for counting controlled objects
and it will recalculate the quantity value at the end of the API call
as long as the RelatedObjects are not IfcConstructionResource which do not
count towards the cost item (they only provide value).

:param cost_item: The IfcCostItem to assign parametric quantities to
:param products: The IfcObjects to assign parametric quantities to
:param prop_name: The name of the quantity. If this is not specified,
    then it is assumed that there is no calculated quantity, and the
    number of objects are counted instead.
:return: None

Example:

.. code:: python

    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)

    # Let's imagine a unit cost of 5.0 per unit volume
    value = ifcopenshell.api.cost.add_cost_value(model, parent=item)
    ifcopenshell.api.cost.edit_cost_value(model, cost_value=value,
        attributes={"AppliedValue": 5.0})

    slab = ifcopenshell.api.root.create_entity(model, ifc_class="IfcSlab")
    # Usually the quantity would be automatically calculated via a
    # graphical authoring application but let's assign a manual quantity
    # for now.
    qto = ifcopenshell.api.pset.add_qto(model, product=slab, name="Qto_SlabBaseQuantities")
    ifcopenshell.api.pset.edit_qto(model, qto=qto, properties={"NetVolume": 42.0})

    # Now let's parametrically link the slab's quantity to the cost
    # item. If the slab is edited in the future and 42.0 changes, then
    # the updated value will also automatically be applied to the cost
    # item.
    ifcopenshell.api.cost.assign_cost_item_quantity(model,
        cost_item=item, products=[slab], prop_name="NetVolume")

#### assign_cost_value
Assigns a cost value to a cost item from a schedule of rates

Instead of assigning cost values from scratch for each cost item in a
cost schedule, the cost values may instead be assigned from a schedule
of rates.

A schedule of rates is just another cost schedule which have cost values
but no quantities. This API will allow you to "copy" the values from a
cost item in the schedule of rates into another cost item in your own
cost schedule. When the schedule of rates value is updated, then your
cost item values will also be updated. You can think of the schedule of
rates as a "template" to quickly populate your rates from.

:param cost_item: The IfcCostItem that you want to copy the values to
:param cost_rate: The IfcCostItem that you want to copy the values from
:return: None

Example:

.. code:: python

    # Let's create a schedule of rates with a single rate in it of 5.0
    rate_tables = ifcopenshell.api.cost.add_cost_schedule(model,
        predefined_type="SCHEDULEOFRATES")
    rate = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)
    value = ifcopenshell.api.cost.add_cost_value(model, parent=rate)
    ifcopenshell.api.cost.edit_cost_value(model, cost_value=value,
        attributes={"AppliedValue": 5.0})

    # And this schedule will be for our actual cost plan / estimate / etc
    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)

    # Now the cost item has the same rate as the one from the schedule of rate's item
    ifcopenshell.api.cost.assign_cost_value(model, cost_item=item, cost_rate=rate)

#### calculate_cost_item_resource_value
Calculates the total cost of all resources associated with a cost item

A cost item may have construction resources (e.g. equipment, material,
etc) assigned to it. Construction resources may be assigned directly to
the cost item, or assigned first to a task, and the task is then
assigned to the cost item.

The cost of a resource is calculated by the total sum of all of its base
costs. If no quantity is provided, that sum is considered to be the
total cost. Otherwise, it is considered to be a unit cost, and is then
multiplied by the resource quantity. The quantity is either stored as a
base quantity (such as a volume) for a things like material resources,
or as a duration as a daily rate for labour resources.

The final calculated cost is set as the cost item's value. Any
previously existing values are removed.

:param cost_item: The IfcCostItem to calculate
:return: None

Example:

.. code:: python

    # First, we need a cost schedule and item
    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)

    # Let's imagine we have our own formworking crew
    crew = ifcopenshell.api.resource.add_resource(model, ifc_class="IfcCrewResource")

    # ... and they need concrete
    concrete = ifcopenshell.api.resource.add_resource(model,
        ifc_class="IfcConstructionMaterialResource", parent_resource=crew)
    ifcopenshell.api.control.assign_control(model,
        relating_control=item, related_objects=[concrete])
    # ... which has a unit price of 42.0 per m3
    value = ifcopenshell.api.cost.add_cost_value(model, parent=concrete)
    ifcopenshell.api.cost.edit_cost_value(model, cost_value=value,
        attributes={"AppliedValue": 42.0})
    # ... and a volume of 200m3
    quantity = ifcopenshell.api.resource.add_resource_quantity(model,
        resource=concrete, ifc_class="IfcQuantityVolume")
    ifcopenshell.api.resource.edit_resource_quantity(model,
        physical_quantity=quantity, "attributes": {"VolumeValue": 200.0})

    # Let's say they also need some equipment
    equipment = ifcopenshell.api.resource.add_resource(model,
        ifc_class="IfcConstructionEquipmentResource", parent_resource=crew)
    ifcopenshell.api.control.assign_control(model,
        relating_control=item, related_objects=[equipment])
    # ... with a fixed price of 50,000
    value = ifcopenshell.api.cost.add_cost_value(model, parent=concrete)
    ifcopenshell.api.cost.edit_cost_value(model, cost_value=value,
        attributes={"AppliedValue": 42.0})

    # (42 * 200) + 50000 = 58400 is our calculated cost
    ifcopenshell.api.cost.calculate_cost_item_resource_value(model, cost_item=item)

#### copy_cost_item
Copies all cost items and related relationships

The following relationships are also duplicated:

* The copy will have the same attributes and property sets as the original cost item
* The copy will be assigned to the parent cost schedule
* The copy will have duplicated nested cost items

:param cost_item: The cost item to be duplicated
:return: The duplicated cost item or the list of duplicated cost items if the latter has children

Example:
.. code:: python

    # We have a cost item
    cost_item = CostItem(name="Design new feature", deadline="2023-03-01")

    # And now we have two
    duplicated_cost_item = project.duplicate_cost_item(cost_item)

#### copy_cost_item_values
Copies all cost values from one cost item to another

Any previously existing values will be removed. The entire value is
copied, including all components and formulas. However they are not
parametrically linked, so if one value changes, the other will not.

:param source: The IfcCostItem to copy cost values from
:param destination: The IfcCostItem to copy cost values from
:return: None

Example:

.. code:: python

    # Assume we have a schedule with multiple items in it
    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item1 = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)
    item2 = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)

    # One of the items has a value
    value = ifcopenshell.api.cost.add_cost_value(model, parent=item)
    ifcopenshell.api.cost.edit_cost_value(model, cost_value=value,
        attributes={"AppliedValue": 5000.0})

    # Let's copy the value from one item to another
    ifcopenshell.api.cost.copy_cost_item_values(model, source=item1, destination=item2)

#### copy_cost_schedule
Copy a cost schedule.

:param cost_schedule: IfcCostSchedule to copy.
:return: The duplicated IfcCostSchedule entity

Example:

.. code:: python

    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    new_schedule = ifcopenshell.api.cost.copy_cost_schedule(schedule)

#### edit_cost_item
Edits the attributes of an IfcCostItem

For more information about the attributes and data types of an
IfcCostItem, consult the IFC documentation.

:param cost_item: The IfcCostItem entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)
    ifcopenshell.api.cost.edit_cost_item(model, cost_item=item, attributes={"Name": "Foo"})

#### edit_cost_item_quantity
Edits the attributes of an IfcPhysicalQuantity

For more information about the attributes and data types of an
IfcPhysicalQuantity, consult the IFC documentation.

:param physical_quantity: The IfcPhysicalQuantity entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)

    # This cost item will have a unit cost of 5 and a volume of 3
    value = ifcopenshell.api.cost.add_cost_value(model, parent=item)
    ifcopenshell.api.cost.edit_cost_value(model, cost_value=value,
        attributes={"AppliedValue": 5.0})
    quantity = ifcopenshell.api.cost.add_cost_item_quantity(model,
        cost_item=item, ifc_class="IfcQuantityVolume")
    ifcopenshell.api.cost.edit_cost_item_quantity(model,
        physical_quantity=quantity, "attributes": {"VolumeValue": 3.0})

#### edit_cost_schedule
Edits the attributes of an IfcCostSchedule

For more information about the attributes and data types of an
IfcCostSchedule, consult the IFC documentation.

:param cost_schedule: The IfcCostSchedule entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    ifcopenshell.api.cost.edit_cost_schedule(model,
        cost_schedule=schedule, attributes={"Name": "Foo"})

#### edit_cost_value
Edits the attributes of an IfcCostValue

For more information about the attributes and data types of an
IfcCostValue, consult the IFC documentation.

:param cost_value: The IfcCostValue entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)

    # This cost item will have a total cost of 42
    value = ifcopenshell.api.cost.add_cost_value(model, parent=item)
    ifcopenshell.api.cost.edit_cost_value(model, cost_value=value,
        attributes={"AppliedValue": 42.0})

#### edit_cost_value_formula
Sets a cost value based on a formula, similar to formulas in spreadsheets

Costs may be made up of many components (e.g. labour, material, waste
factor, taxes, etc). This can be easily represented in the form of a
formula similar thta would be used in spreadsheet applications.

For more information, see ifcopenshell.util.cost

:param cost_value: The IfcCostValue to set the values of
:param formula: The formula following the language of ifcopenshell.util.cost
:return: None

Example:

.. code:: python

    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)

    value = ifcopenshell.api.cost.add_cost_value(model, parent=item)
    ifcopenshell.api.cost.edit_cost_value_formula(model, cost_value=value,
        formula="5000 * 1.19")

#### remove_cost_item
Removes a cost item

All associated relationships with the cost item are also removed,
however the related resources, products, and tasks themselves are
retained.

:param cost_item: The IfcCostItem entity you want to remove
:return: None

Example:

.. code:: python

    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)
    ifcopenshell.api.cost.remove_cost_item(model, cost_item=item)

#### remove_cost_item_quantity
Removes a quantity assigned to a cost item

If the quantity is part of a product (e.g. wall), then the quantity will
still exist and merely the relationship to the cost item will be
removed.

:param cost_item: The IfcCostItem that the quantity is assigned to
:param physical_quantity: The IfcPhysicalQuantity to remove
:return: None

Example:

.. code:: python

    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)
    quantity = ifcopenshell.api.cost.add_cost_item_quantity(model,
        cost_item=item, ifc_class="IfcQuantityVolume")
    # Let's change our mind and delete it
    ifcopenshell.api.cost.remove_cost_item(model,
        cost_item=item, physical_quantity=quantity)

#### remove_cost_schedule
Removes a cost schedule

All associated relationships with the cost schedule are also removed,
including all cost items.

:param cost_schedule: The IfcCostSchedule entity you want to remove
:return: None

Example:

.. code:: python

    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)
    ifcopenshell.api.cost.remove_cost_schedule(model, cost_schedule=schedule)

#### remove_cost_value
Removes a cost value

The cost value may be assigned either to a cost item, a construction
resource, or another cost value (i.e. it is a subcomponent of a cost)

:param parent: The IfcCostItem, IfcConstructionResource, or IfcCostValue
    that the IfcCostValue is assigned to.
:param cost_value: The IfcCostValue that you want to remove
:return: None

Example:

.. code:: python

    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)

    # This cost item will have a unit cost of 5 and a volume of 3
    value = ifcopenshell.api.cost.add_cost_value(model, parent=item)
    ifcopenshell.api.cost.edit_cost_value(model, cost_value=value,
        attributes={"AppliedValue": 5.0})

    ifcopenshell.api.cost.remove_cost_value(model, parent=item, cost_value=value)

#### unassign_cost_item_quantity
Removes quantities of a cost item that are calculated on products

A cost item may have quantities that are parametrically calculated on
physical products. This lets you remove those quantities. This means
that any future changes in the physical product's dimensions will not
have any impact on the cost item.

:param cost_item: The IfcCostItem to remove quantities from
:param products: A list of IfcProducts that may have parametrically
    connected quantities to the cost item
:return: None

Example:

.. code:: python

    schedule = ifcopenshell.api.cost.add_cost_schedule(model)
    item = ifcopenshell.api.cost.add_cost_item(model, cost_schedule=schedule)

    # Let's imagine a unit cost of 5.0 per unit volume
    value = ifcopenshell.api.cost.add_cost_value(model, parent=item)
    ifcopenshell.api.cost.edit_cost_value(model, cost_value=value,
        attributes={"AppliedValue": 5.0})

    slab = ifcopenshell.api.root.create_entity(model, ifc_class="IfcSlab")
    # Usually the quantity would be automatically calculated via a
    # graphical authoring application but let's assign a manual quantity
    # for now.
    qto = ifcopenshell.api.pset.add_qto(model, product=slab, name="Qto_SlabBaseQuantities")
    ifcopenshell.api.pset.edit_qto(model, qto=qto, properties={"NetVolume": 42.0})

    # Now let's parametrically link the slab's quantity to the cost
    # item. If the slab is edited in the future and 42.0 changes, then
    # the updated value will also automatically be applied to the cost
    # item.
    ifcopenshell.api.cost.assign_cost_item_quantity(model,
        cost_item=item, products=[slab], prop_name="NetVolume")

    # Let's change our mind and remove the parametric connection
    ifcopenshell.api.cost.unassign_cost_item_quantity(model,
        cost_item=item, products=[slab])

## Module: document

### Description
Reference external project documents and associate them to model elements

Some project information (drawings, specifications, certificates, reports, etc)
may be stored in external documents (locally or in a CDE). IFC lets you store a
register of documents with metadata and associate them with elements (both
physical and non-physical).

### Available Functions
- add_information
- add_reference
- assign_document
- edit_information
- edit_reference
- remove_information
- remove_reference
- unassign_document

### Function Docstrings
#### add_information
Adds a new document information to the project

An IFC document information is a document associated with the project.
It may be a drawing, specification, schedule, certificate, warranty
guarantee, manual, contract, and so on. They are often used for drawings
and facility management purposes.

A document may also be a subdocument of a larger document, this is
useful for superseding documents or tracking older versions. The parent
is considered the latest version and the children are older revisions.

:param parent: The parent document, if necessary.
:return: The newly created IfcDocumentInformation entity

Example:

.. code:: python

    document = ifcopenshell.api.document.add_information(model)
    # A document typically has a unique drawing or document name (which
    # follows a coding system depending on the project), as well as a
    # title.  This should match what is shown on the titleblock or title
    # page of the document. At a minimum you'd also want to specify a
    # URI location. The location may be on local, or on a CDE, or any
    # other platform.
    ifcopenshell.api.document.edit_information(model,
        information=document,
        attributes={"Identification": "A-GA-6100", "Name": "Overall Plan",
        "Location": "A-GA-6100 - Overall Plan.pdf"})

#### add_reference
Creates a new reference to a document to assign to products

A document may be associated with physical products, tasks, cost items,
and so on. For example, spaces, storeys, and buildings may have a list
of associated drawings so you can see which drawings (e.g. plans,
sections, details) are documenting that location. Alternatively,
equipment may have associated training manuals, operation and
maintenance manuals or detailed assembly drawings. Resources may be
training certification required, schedules may have gantt charts or bid
documents, and so on.

In order to associate a document with an object, a reference to that
document needs to be created. It could be a reference to the entire
document, or a reference to a particular page or chapter. See
ifcopenshell.api.document.assign_document for more information.

:param information: The IfcDocumentInformation that the reference will
    be created for
:return: The newly created IfcDocumentReference entity

Example:

.. code:: python

    document = ifcopenshell.api.document.add_information(model)
    ifcopenshell.api.document.edit_information(model,
        information=document,
        attributes={"Identification": "A-GA-6100", "Name": "Overall Plan",
        "Location": "A-GA-6100 - Overall Plan.pdf"})

    # In this case, we don't specify any more information, and so the
    # reference is for the entire document, as opposed to a single page or
    # chapter or section.
    reference = ifcopenshell.api.document.add_reference(model, information=document)

    # Alternatively, we can specify a single section, such as by a
    # subheading code.
    reference2 = ifcopenshell.api.document.add_reference(model, information=document)
    ifcopenshell.api.document.edit_reference(model,
        reference=reference2, attributes={"Identification": "2.1.15"})

#### assign_document
Assigns a document to a list of products

An object may be assigned to zero, one, or multiple documents. Almost
any object or property may be assigned to a document, though typically
we'd only use it for spaces, types, physical products and schedules.
Adding a new assignment is typically done using a document reference and
an object.  IFC technically allows association with a document
information and an object, but this is not encouraged because it is not
consistent with other external relationships (such as classification
systems or libraries).

:param product: The list of objects to associate the document to. This could be
    almost any sensible object in IFC.
:param document: The IfcDocumentReference to associate to, or
    alternatively an IfcDocumentInformation, though this is not
    recommended.
:return: The IfcRelAssociatesDocument relationship
    or `None` if `products` was an empty list or all products were
    already assigned to the `document`.

Example:

.. code:: python

    document = ifcopenshell.api.document.add_information(model)
    ifcopenshell.api.document.edit_information(model,
        information=document,
        attributes={"Identification": "A-GA-6100", "Name": "Overall Plan",
        "Location": "A-GA-6100 - Overall Plan.pdf"})
    reference = ifcopenshell.api.document.add_reference(model, information=document)

    # Let's imagine storey represents an IfcBuildingStorey for the ground floor
    ifcopenshell.api.document.assign_document(model, products=[storey], document=reference)

#### edit_information
Edits the attributes of an IfcDocumentInformation

For more information about the attributes and data types of an
IfcDocumentInformation, consult the IFC documentation.

:param reference: The IfcDocumentInformation entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    document = ifcopenshell.api.document.add_information(model)
    ifcopenshell.api.document.edit_information(model,
        information=document,
        attributes={"Identification": "A-GA-6100", "Name": "Overall Plan",
        "Location": "A-GA-6100 - Overall Plan.pdf"})

#### edit_reference
Edits the attributes of an IfcDocumentReference

For more information about the attributes and data types of an
IfcDocumentReference, consult the IFC documentation.

:param reference: The IfcDocumentReference entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    document = ifcopenshell.api.document.add_information(model)
    ifcopenshell.api.document.edit_information(model,
        information=document,
        attributes={"Identification": "A-GA-6100", "Name": "Overall Plan",
        "Location": "A-GA-6100 - Overall Plan.pdf"})
    reference = ifcopenshell.api.document.add_reference(model, information=document)
    ifcopenshell.api.document.edit_reference(model,
        reference=reference, attributes={"Identification": "2.1.15"})

#### remove_information
Removes a document information

All references and associations are also removed.

:param information: The IfcDocumentInformation to remove
:return: None

Example:

.. code:: python

    # Add a document
    document = ifcopenshell.api.document.add_information(model)
    # ... and remove it!
    ifcopenshell.api.document.remove_information(model, information=document)

#### remove_reference
Remove a document reference

All associations with objects are removed.

:param reference: The IfcDocumentReference to remove
:return: None

Example:

.. code:: python

    document = ifcopenshell.api.document.add_information(model)
    reference = ifcopenshell.api.document.add_reference(model, information=document)
    ifcopenshell.api.document.remove_reference(model, reference=reference)

#### unassign_document
Unassigns a document and an association to the list of products

:param product: The list of objects that the document reference or information is
    related to.
:param document: The IfcDocumentReference (typically) or in rare cases
    the IfcDocumentInformation that is associated with the product
:return: None

Example:

.. code:: python

    document = ifcopenshell.api.document.add_information(model)
    ifcopenshell.api.document.edit_information(model,
        information=document,
        attributes={"Identification": "A-GA-6100", "Name": "Overall Plan",
        "Location": "A-GA-6100 - Overall Plan.pdf"})
    reference = ifcopenshell.api.document.add_reference(model, information=document)

    # Let's imagine storey represents an IfcBuildingStorey for the ground floor
    ifcopenshell.api.document.assign_document(model, products=[storey], document=reference)

    # Now let's change our mind and remove the association
    ifcopenshell.api.document.unassign_document(model, products=[storey], document=reference)

## Module: drawing

### Description
Create relationships necessary for smart annotations for drawings

Drawings may be generated from modeled elements and annotations. These
annotations may have relationships which indicate smart data being populated.

### Available Functions
- assign_product
- edit_text_literal
- unassign_product

### Function Docstrings
#### assign_product
Associates a product and an object, typically for annotation

Warning: this is an experimental API.

When you want to draw attention to a feature or characteristic (such as
a dimension, material, or name) or of a product (e.g. wall, slab,
furniture, etc), an annotation object is created. This annotation is
then associated with the product so that it can reference attributes,
properties, and relationships.

For example, an annotation of a line will be associated with a grid
axis, such that when that grid axis moves, the annotation of that grid
axis (which is typically truncated to the extents of a drawing) will
also move.

Another example might be a label of a furniture product, which might
have some text of the name of the furniture to be shown on drawings or
in 3D.

:param relating_product: The IfcProduct the object is related to
:param related_object: The object (typically IfcAnnotation) that the
    product is related to
:return: The created IfcRelAssignsToProduct relationship

Example:

.. code:: python

    furniture = ifcopenshell.api.root.create_entity(model, ifc_class="IfcFurniture")
    annotation = ifcopenshell.api.root.create_entity(model, ifc_class="IfcAnnotation")
    ifcopenshell.api.drawing.assign_product(model,
        relating_product=furniture, related_object=annotation)

#### edit_text_literal
Edits the attributes of an IfcTextLiteral

For more information about the attributes and data types of an
IfcTextLiteral, consult the IFC documentation.

:param reference: The IfcTextLiteral entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    text = model.createIfcTextLiteral()
    ifcopenshell.api.drawing.edit_text_literal(model,
        text_literal=text, attributes={"Literal": "MY ANNOTATION"})

#### unassign_product
Unassigns a product and an object (typically an annotation)

Smart annotation objects can be associated with products so that they
can annotate attributes and properties. This function lets you remove
the association, so that you may change the assocation with another
object later or leave the annotation as a "dumb" annotation.

:param relating_product: The IfcProduct the object is related to
:param related_object: The object (typically IfcAnnotation) that the
    product is related to
:return: None

Example:

.. code:: python

    furniture = ifcopenshell.api.root.create_entity(model, ifc_class="IfcFurniture")
    annotation = ifcopenshell.api.root.create_entity(model, ifc_class="IfcAnnotation")
    ifcopenshell.api.drawing.assign_product(model,
        relating_product=furniture, related_object=annotation)

    # Let's change our mind and remove the relationship
    ifcopenshell.api.drawing.unassign_product(model,
        relating_product=furniture, related_object=annotation)

## Module: feature

### Description
Create relationships between features (e.g. openings) and physical elements

A feature is a special element (created using
:func:`ifcopenshell.api.root.create_entity`) that may then be used to create
geometric changes in other elements (such as walls and slabs). Most commonly, a
feature would be an opening void. These voids may then be filled with doors,
trapdoors, skylights, and so on.

### Available Functions
- add_feature
- add_filling
- remove_feature
- remove_filling

### Function Docstrings
#### add_feature
Create a projecting, voiding, or surface feature in an element

There are three main types of features: those that add, remove, or
influence geometry of a parent object.

The most common of these is an opening. For example, it is often necessary
to cut out openings in elements like walls and slabs to make space to
insert doors, windows, and other services that go through these
penetrations.

Whereas it is possible to simply draw the wall as a rectangle with a
hole in it for the opening, often these openings have specific meanings.
For example, an opening might be filled with a window, and so when the
window moves, the opening should move with it. Alternatively, the
opening itself might have fire or acoustic requirements, such that any
service or equipment passing through that space must also comply with
those requirements. For these types of semantic openings, you should
have a distinct opening element which voids your regular element. For
example, your wall will still be a rectangular prism with no hole in it,
and a separate opening element will have a box representing the extents
of the opening for a window. The opening element will automatically
perform a geometric boolean operation to cut out the wall's geometry.

Whenever you have an opening in you project, you should determine
whether or not the opening is semantic (i.e. should be represented by a
distinct opening object) or non-semantic (i.e. should simply be
booleaned or be part of the shape of the object).

:param feature: The IfcFeatureElement to affect the element.
:param element: The IfcElement to add the feature to.
:return: The new IfcRelVoidsElement relationship

Example:

.. code:: python

    # A bit of preparation, let's create some geometric contexts since
    # we want to create some geometry for our wall and opening.
    model3d = ifcopenshell.api.context.add_context(model, context_type="Model")
    body = ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Body", target_view="MODEL_VIEW", parent=model3d)

    # Create a wall
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # Let's use the "3D Body" representation we created earlier to add a
    # new wall-like body geometry, 5 meters long, 3 meters high, and
    # 200mm thick
    representation = ifcopenshell.api.geometry.add_wall_representation(model,
        context=body, length=5, height=3, thickness=0.2)
    ifcopenshell.api.geometry.assign_representation(model,
        product=wall, representation=representation)

    # Place our wall at the origin
    ifcopenshell.api.geometry.edit_object_placement(model, product=wall)

    # Create an opening, such as for a service penetration with fire and
    # acoustic requirements.
    opening = ifcopenshell.api.root.create_entity(model, ifc_class="IfcOpeningElement")

    # Let's create an opening representation of a 950mm x 2100mm door.
    # Notice how the thickness is greater than the wall thickness, this
    # helps resolve floating point resolution errors in 3D.
    representation = ifcopenshell.api.geometry.add_wall_representation(model,
        context=body, length=.95, height=2.1, thickness=0.4)
    ifcopenshell.api.geometry.assign_representation(model,
        product=opening, representation=representation)

    # Let's shift our door 1 meter along the wall and 100mm along the
    # wall, to create a nice overlap for the opening boolean.
    matrix = np.identity(4)
    matrix[:,3] = [1, -.1, 0, 0]
    ifcopenshell.api.geometry.edit_object_placement(model, product=opening, matrix=matrix)

    # The opening will now void the wall.
    ifcopenshell.api.feature.add_feature(model, feature=opening, element=wall)

#### add_filling
Fill an opening with an element

Physical elements may have openings in them. For example, a wall might
have an opening for a door. That opening is then filled by the door.
This indicates that when the door moves, the opening will move with it.
Or if the door is removed, then the opening may remain and need to be
filled.

:param opening: The IfcOpeningElement to fill with the element.
:param element: The IfcElement to be inserted into the opening.
:return: The new IfcRelFillsElement relationship

Example:

.. code:: python

    # A bit of preparation, let's create some geometric contexts since
    # we want to create some geometry for our wall and opening.
    model3d = ifcopenshell.api.context.add_context(model, context_type="Model")
    body = ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Body", target_view="MODEL_VIEW", parent=model3d)

    # Create a wall
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # Let's use the "3D Body" representation we created earlier to add a
    # new wall-like body geometry, 5 meters long, 3 meters high, and
    # 200mm thick
    representation = ifcopenshell.api.geometry.add_wall_representation(model,
        context=body, length=5, height=3, thickness=0.2)
    ifcopenshell.api.geometry.assign_representation(model,
        product=wall, representation=representation)

    # Place our wall at the origin
    ifcopenshell.api.geometry.edit_object_placement(model, product=wall)

    # Create an opening, such as for a service penetration with fire and
    # acoustic requirements.
    opening = ifcopenshell.api.root.create_entity(model, ifc_class="IfcOpeningElement")

    # Let's create an opening representation of a 950mm x 2100mm door.
    # Notice how the thickness is greater than the wall thickness, this
    # helps resolve floating point resolution errors in 3D.
    representation = ifcopenshell.api.geometry.add_wall_representation(model,
        context=body, length=.95, height=2.1, thickness=0.4)
    ifcopenshell.api.geometry.assign_representation(model,
        product=opening, representation=representation)

    # Let's shift our door 1 meter along the wall and 100mm along the
    # wall, to create a nice overlap for the opening boolean.
    matrix = np.identity(4)
    matrix[:,3] = [1, -.1, 0, 0]
    ifcopenshell.api.geometry.edit_object_placement(model, product=opening, matrix=matrix)

    # The opening will now void the wall.
    ifcopenshell.api.feature.add_feature(model, feature=opening, element=wall)

    # Create a door
    door = ifcopenshell.api.root.create_entity(model, ifc_class="IfcDoor")

    # Let's create a door representation of a 950mm x 2100mm door.
    representation = ifcopenshell.api.geometry.add_wall_representation(model,
        context=body, length=.95, height=2.1, thickness=0.05)
    ifcopenshell.api.geometry.assign_representation(model,
        product=door, representation=representation)

    # Let's shift our door 1 meter along the wall and 100mm along the
    # wall, which lines up with our opening.
    matrix = np.identity(4)
    matrix[:,3] = [1, .05, 0, 0]
    ifcopenshell.api.geometry.edit_object_placement(model, product=door, matrix=matrix)

    # The door will now fill the opening.
    ifcopenshell.api.feature.add_filling(model, opening=opening, element=door)

#### remove_feature
Remove a feature

Fillings are retained as orphans. Featured elements remain. Features
cannot exist by themselves, so not only is the relationship removed, the
feature is also removed.

:param feature: The IfcFeatureElement to remove.

Example:

.. code:: python

    # Create an orphaned opening. Note that an orphaned opening is
    # invalid, as an opening can only exist when voiding another
    # element.
    feature = ifcopenshell.api.root.create_entity(model, ifc_class="IfcOpeningElement")

    # Remove it. This brings us back to a valid model.
    ifcopenshell.api.feature.remove_feature(model, feature=feature)

#### remove_filling
Remove a filling relationship

If an element is filling an opening, this removes the relationship such
that the opening and element both still exist, but the element no longer
fills the opening.

:param element: The element filling an opening.
:return: None

Example:

.. code:: python

    # Create a wall
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # Create an opening, such as for a service penetration with fire and
    # acoustic requirements.
    opening = ifcopenshell.api.root.create_entity(model, ifc_class="IfcOpeningElement")

    # Create a door
    door = ifcopenshell.api.root.create_entity(model, ifc_class="IfcDoor")

    # The door will now fill the opening.
    ifcopenshell.api.feature.add_filling(model, opening=opening, element=door)

    # Not anymore!
    ifcopenshell.api.feature.remove_filling(model, element=door)

## Module: geometry

### Description
Create geometric representations and assign them to elements

These functions support both the creation of arbitrary geometry as well as
geometry that follows parametric rules (e.g. layered geometry or profiled
geometry extrusions).

### Available Functions
- add_axis_representation
- add_boolean
- add_door_representation
- add_footprint_representation
- add_mesh_representation
- add_profile_representation
- add_railing_representation
- add_representation
- add_shape_aspect
- add_slab_representation
- add_wall_representation
- add_window_representation
- assign_representation
- connect_element
- connect_path
- connect_wall
- create_2pt_wall
- disconnect_element
- disconnect_path
- edit_object_placement
- map_representation
- regenerate_wall_representation
- remove_boolean
- remove_representation
- unassign_representation
- validate_type

### Function Docstrings
#### add_axis_representation
Adds a new axis representation

Certain objects are typically "axis-based", such as walls, beams,
and columns. This means you can represent them abstractly by simply
drawing a single line either in 2D (such as for walls) or 3D (for beams
and columns). Humans can understand this axis-based representation as
being a simplification of a layered extrusion or a profile that is being
extruded along that axis and joined to other elements.

Using an axis-based representation makes it easy for users and computers
to analyse connectivity and spatial relationships, as well as makes it
easy to parametrically edit these objects by simply stretching the start
or end of the axis.

For now, only simple straight line axes are supported, represented by a
start and end coordinate. The order is important. For walls, the start
must be at the minimum local X ordinate, and the end at the maximum
local X ordinate. For beams and columns, the start is at the minimum
local Z ordinate, and the end of the maximum local Z ordinate. The first
coordinate is the "start" and the second coordinate is the "end". This
stat and end is then used to determine any parametric junctions with
other elements.

Using an axis-representation is optional, but highly recommended for
"standard" representations of walls, beams, columns, and other
structural members. A rule of thumb is that if you can draw it as a line
on paper, you can probably represent it using an axis.

:param context: The IfcGeometricRepresentationContext that the
    representation is part of. This must be either a
    Model/Axis/GRAPH_VIEW (3D) or Plan/Axis/GRAPH_VIEW (2D).
:param axis: The axis, as a list of two coordinates, the coordinates
    being either a list of 2 or 3 float coordinates depending on whether
    the axis is 2D or 3D.
:return: The newly created IfcShapeRepresentation entity

Example:

.. code:: python

    context = ifcopenshell.util.representation.get_context(model, "Plan", "Axis", "GRAPH_VIEW")
    axis = ifcopenshell.api.geometry.add_axis_representation(model,
        context=context, axis=[(0.0, 0.0), (1.0, 0.0)])

#### add_boolean
Adds a boolean operation to two or more representation items

If an IfcBooleanOperand is part of the top level items in an
IfcShapeRepresentation, it will be removed from that level whilst being
added to the IfcBooleanResult. This is because it is generally intuitive
that an item is either participating in a boolean operation, or being an
item in its own right, but not both.

However, if an IfcBooleanOperand is part of another boolean operation
already, it will not be removed from the existing operation. A new
operation will be created, and therefore it will participate in two
operations.

This function protects against recursive booleans.

After a boolean operation is made, since the items of
IfcShapeRepresentation may be modified, it is not guaranteed that the
RepresentationType is still valid. After performing all your booleans, it
is recommended to run :func:`ifcopenshell.api.geometry.validate_csg` to
ensure correctness.

:param first_item: The IfcBooleanOperand that the operation is performed upon
:param second_items: The IfcBooleanOperands that the operation will be
    performed with, in the order given of the list.
:param operator: The type of boolean operation to perform
:return: A list of newly created IfcBooleanResult in the order of boolean
    operations (based on the order of second items). If nothing was
    created, the list will be empty.

#### add_door_representation
Add a geometric representation for a door.

units in usecase_settings expected to be in ifc project units

:param context: IfcGeometricRepresentationContext for the representation.
:param overall_height: Overall door height. Defaults to 2m.
:param overall_width: Overall door width. Defaults to 0.9m.
:param operation_type: Type of the door. Defaults to SINGLE_SWING_LEFT.
:param lining_properties: DoorLiningProperties or a dictionary to create one.
    See DoorLiningProperties description for details.
:param panel_properties: DoorPanelProperties or a dictionary to create one.
    See DoorPanelProperties description for details.
:param unit_scale: The unit scale as calculated by
    ifcopenshell.util.unit.calculate_unit_scale. If not provided, it
    will be automatically calculated for you.
:return: IfcShapeRepresentation for a door.

#### add_footprint_representation
No docstring found

#### add_mesh_representation
Add a mesh representation.

Vertices, edges, and faces are given in the form of: ``[item1, item2, item3, ...]``.
Each ``itemN`` is a sublist representing data for a separate IfcRepresentationItem to add.

You can provide either ``edges`` or ``faces``, no need to provide both.
But currently ``edges`` argument is not supported.

:param context: The IfcGeometricRepresentationContext for the representation.
:param vertices: A list of coordinates.
    where ``itemN = [(0., 0., 0.), (1., 1., 1.), (x, y, z), ...]``
:param edges: A list of edges, represented by vertex index pairs
    where ``itemN = [(0, 1), (1, 2), (v1, v2), ...]``
:param faces: A list of polygons, represented by vertex indices.
    where ``itemN = [(0, 1, 2), (5, 4, 2, 3), (v1, v2, v3, ... vN), ...]``
:param coordinate_offset: Optionally apply a vector offset to all coordinates.
    In project units.
:param unit_scale: Scale factor for ``vertices`` units.

    If omitted, it is assumed that ``vertices`` are in SI units.

    If other value is provided ``vertices`` coords will be divided by ``unit_scale``.
:param force_faceted_brep: Force using IfcFacetedBreps instead of IfcPolygonalFaceSets.
:return: IfcShapeRepresentation.

#### add_profile_representation
Add profile representation.

:param context: The IfcGeometricRepresentationContext for the representation,
    only Model/Body/MODEL_VIEW type of representations are currently supported.
:param profile: The IfcProfileDef to extrude.
:param depth: The depth of the extrusion in meters.
:param cardinal_point: The cardinal point of the profile.
:param clippings: A list of planes that define clipping half space solids.
    Planes are defined either by Clipping objects
    or by dictionaries of arguments for `Clipping.parse`.
:param placement_zx_axes: A tuple of two vectors that define the placement of the profile.
    The first vector is the Z axis, the second vector is the X axis.
:return: IfcShapeRepresentation.

#### add_railing_representation
Units are expected to be in IFC project units.

:param context: IfcGeometricRepresentationContext for the representation.
:param railing_type: Type of the railing. Defaults to "WALL_MOUNTED_HANDRAIL".
:param railing_path: A list of points coordinates for the railing path,
    coordinates are expected to be at the top of the railing, not at the center.
    If not provided, default path [(0, 0, 1), (1, 0, 1), (2, 0, 1)] (in meters) will be used
:param use_manual_supports: If enabled, supports are added on every vertex on the edges of the railing path.
    If disabled, supports are added automatically based on the support spacing. Default to False.
:param support_spacing: Distance between supports if automatic supports are used. Defaults to 1m.
:param railing_diameter: Railing diameter. Defaults to 50mm.
:param clear_width: Clear width between the railing and the wall. Defaults to 40mm.
:param terminal_type: type of the cap. Defaults to "180".
:param height: defaults to 1m
:param looped_path: Whether to end the railing on the first point of `railing_path`. Defaults to False.
:param unit_scale: The unit scale as calculated by
    ifcopenshell.util.unit.calculate_unit_scale. If not provided, it
    will be automatically calculated for you.
:return: IfcShapeRepresentation for a railing.

#### add_representation
Add an IfcShapeRepresentation.

:param context: The IfcGeometricRepresentationContext.
:param blender_object: This is (currently) a Blender object, hence this depends on Blender now.
:param geometry: This is (currently) a Blender data object, hence this depends on Blender now.
:param coordinate_offset: Optionally apply a vector offset to all coordinates (in SI units).
:param total_items: How many representation items to create.
:param unit_scale: A scale factor to apply for all vectors in case the unit is different.
:param should_force_faceted_brep: If we should force faceted breps for meshes.
:param should_force_triangulation: If we should force triangulation for meshes.
:param should_generate_uvs:  If UV coordinates should also be generated.
:param ifc_representation_class: Whether to cast a mesh into a particular class
:param profile_set_usage: The material profile set if the extrusion requires it
:param text_literal: The text literal if the representation requires it
:return: IfcShapeRepresentation or None if couldn't create representation
    for the provided context.

#### add_shape_aspect
Adds a shape aspect to items that are part of a representation and product

Existing shape aspects will be reused where possible. If the items already
belong to another shape aspect with a different name, this relationship
will be purged.

Warning: it is not possible to add a shape aspect to types (i.e.
IfcRepresentationMap) in IFC2X3.

:param name: The name of the shape aspect. This is case sensitive.
:param items: IfcRepresentationItems that will be assigned to this aspect.
:param representation: The IfcShapeRepresentation that the items are in.
:param part_of_product: The IfcRepresentationMap or
    IfcProductDefinitionShape that the representation is in.
:param description: A description to set for the shape aspect. It's usually
    not necessary.
:return: The IfcShapeAspect

#### add_slab_representation
Add a geometric representation for a slab.

:param context: The IfcGeometricRepresentationContext for the representation,
    only Model/Body/MODEL_VIEW type of representations are currently supported.
:param depth: The slab depth, in meters.
:param x_angle: The slope angle along the slab's X-axis, in radians.
:param clippings: List of planes that define clipping half space solids.
    Clippings can be `Clipping` objects or dictionaries of arguments for `Clipping.parse`.
:return: IfcShapeRepresentation.

Example:

.. code:: python

    context = ifcopenshell.util.representation.get_context(ifc_file, "Model", "Body", "MODEL_VIEW")
    clippings = [ifcopenshell.util.data.Clipping(location=(0.0, 0.0, 0.1), normal=(0.0, 0.0, 1.0),)]
    representation = ifcopenshell.api.geometry.add_slab_representation(ifc_file, context, depth=0.2, clippings=clippings)
    ifcopenshell.api.geometry.assign_representation(ifc_file, product=element, representation=representation)

#### add_wall_representation
Add a geometric representation for a wall.

:param context: The IfcGeometricRepresentationContext for the representation,
    only Model/Body/MODEL_VIEW type of representations are currently supported.
:param length: The length of the wall in meters.
:param height: The height of the wall in meters.
:param offset: The base offset distance of the wall from the origin.
:param thickness: The thickness of the wall in meters.
:param x_angle: The slope angle along the wall's X-axis, in radians.
:param clippings: List of clipping definitions. Clippings can be `Clipping` objects
    or dictionaries of arguments for `Clipping.parse`.
:param booleans: List of any existing IfcBooleanResults.
:return: IfcShapeRepresentation.

#### add_window_representation
units in usecase_settings expected to be in ifc project units

:param context: IfcGeometricRepresentationContext for the representation.
:param overall_height: Overall window height. Defaults to 0.9m.
:param overall_width: Overall window width. Defaults to 0.6m.
:param partition_type: Type of the window. Defaults to SINGLE_PANEL.
:param lining_properties: WindowLiningProperties or a dictionary to create one.
    See WindowLiningProperties description for details.
:param panel_properties: A list of WindowPanelProperties or dictionaries to create one.
    See WindowPanelProperties description for details.
:param unit_scale: The unit scale as calculated by
    ifcopenshell.util.unit.calculate_unit_scale. If not provided, it
    will be automatically calculated for you.
:return: IfcShapeRepresentation for a window.

#### assign_representation
No docstring found

#### connect_element
No docstring found

#### connect_path
No docstring found

#### connect_wall
No docstring found

#### create_2pt_wall
Create a wall between two points (p1 and p2).
A shortcut for geometry.add_wall_representation.

:param element: Wall IFC element.
:param context: IfcGeometricRepresentationContext for the representation.
    only Model/Body/MODEL_VIEW type of representations are currently supported.
:param p1: The starting point (x, y) of the wall.
:param p2: The ending point (x, y) of the wall.
:param elevation: The base elevation (z-coordinate) for the wall.
:param height: The height of the wall.
:param thickness: The thickness of the wall.
:param is_si: If True, provided arguments units are treated as SI (meters).
    If False, values are converted from project units to SI.
:return: IfcShapeRepresentation.

#### disconnect_element
No docstring found

#### disconnect_path
There are two options to use this API method:
- provide `element` (connected from) and `connection_type` that should be disconnected.
- provide connected elements to disconnect explicitly:
`relating_element` (connected from) and `related_element` (connected to)

#### edit_object_placement
Changes the object placement matrix of an element

The placement matrix is a 4x4 matrix describing the location and
orientation of an element in 3D. See
https://docs.ifcopenshell.org/ifcopenshell-python/geometry_creation.html#object-placements
for more details.

This only supports local placements. Grid and linear placements are not
supported.

:param matrix: A 4x4 matrix in numpy. If left blank, it is the identity
    matrix (equivalent to ``np.eye(4)``).
:param is_si: If True, the matrix is given in SI units. If false, in
    project units.
:param should_transform_children: A child element is a nested element,
    opening, filling, etc. If true, child elements will move along with the
    parent. If false, child elements will stay where they are. Because most
    placements in IFC are relative, this means that if a child moves, we
    actually don't change their placement.
:return: The new or updated IfcLocalPlacement entity

#### map_representation
No docstring found

#### regenerate_wall_representation
Regenerate the body representation of a wall taking into account connections.

IFC defines how a standard (case) wall should behave that has a material
layer set and connections to other walls using IfcRelConnectsPathElements.
This function will regenerate the body geometry of a wall taking into
account the notches, butts, mitres, etc in the wall due to connections with
other walls.

A standard wall has a 2D axis line as well as parameters defined in terms
of layer thicknesses and priorities. The body geometry is defined as a 2D
XY profile which is extruded in the +Z direction. For this function to
work, a wall must have these defined and the project must have an axis and
body representation context.

For non-sloped walls, a 2D profile is generated and extruded in the +Z
direction. The profile may be a composite profile, if the wall is split due
to wall joins along the path of the wall that protrude all the way through
the wall.

For sloped walls, a basic rectangular 2D profile is extruded, and then
additional extrusions are generated for each connection that boolean
difference the base extrusion.

This will also update the axis line representation (e.g. trim the axis line
to any connections).

The wall's object placement will also be updated such that the placement is
equivalent to the axis line's start point (which therefore becomes (0.0,
0.0)). This is a logical, consistent, and useful placement coordinate
(especially for apps that can pivot using this point).

All this functionality relies on the Plan/Axis/GRAPH_VIEW representation
context. It will be created if it does not exist.

:param wall: The IfcWall for the representation,
    only Model/Body/MODEL_VIEW type of representations are currently supported.
:param length: If the wall doesn't have an axis length, this is the default
    length in SI units.
:param height: If the wall doesn't already have a height, this is the
    default height in SI units.
:param angle: If the wall doesn't already have a slope, this is the default
    angle in radians. Left as none or 0 defines no slope.
:return: The newly generated body IfcShapeRepresentation

#### remove_boolean
Removes a boolean operation without deleting the operands

The first operand will replace the boolean result itself, and the second
operand will be reset as a top level representation item.

This may affect the Items of IfcShapeRepresentation, so it is recommended
to run :func:`ifcopenshell.api.geometry.validate_type` after all boolean
modifications are complete.

:param item: This may either be an IfcBooleanResult or an
    IfcRepresentationItem that is participating in one or more boolean
    results (in which case all are removed).

#### remove_representation
Remove a representation.

Also purges representation items and their related elements
like IfcStyledItem, tessellated facesets colours and UV map.

By default, named profiles are assumed to be significant (i.e. curated as
part of a profile library) and will not be removed.

:param representation: IfcRepresentation to remove.
    Note that it's expected that IfcRepresentation won't be in use
    before calling this method (in such elements as IfcProductRepresentation, IfcShapeAspect)
    otherwise representation won't be removed.
:param should_keep_named_profiles: If true, named profile defs will not be
    removed as they are assumed to be significant.

#### unassign_representation
No docstring found

#### validate_type
Validates the RepresentationType of an IfcShapeRepresentation

A shape representation has to identify its geometry using the
RepresentationType attribute. For example, if it holds tessellated
geometry, it should store "Tessellation" as its RepresentationType.

This function checks whether or not the RepresentationType is valid. This
is a wrapper around :func:`ifcopenshell.util.representation.guess_type`. It
will then set RepresentationType to the most appropriate value, or return
False otherwise. In addition, it also attempts to reconcile otherwise
invalid CSG geometry by unioning all remaining top level items to existing
boolean results.

:param representation: The IfcShapeRepresentation with Items
:param preferred_item: If the type is expected to be a CSG, this will be
    the preferred item to union all remaining items to. If no preferred
    item is provided, the first boolean result will be chosen.
:return: True if the representation type was set and it is a valid
    combination, or False otherwise.

## Module: georeference

### Description
Manage georeferencing metadata

IFC model geometry may have a coordinate reference system (CRS) assigned to it.
It may also optionally have a map conversion defined to transform to and from
map coordinates and project local engineering coordinates.

### Available Functions
- add_georeferencing
- edit_georeferencing
- edit_true_north
- edit_wcs
- remove_georeferencing

### Function Docstrings
#### add_georeferencing
Add empty georeferencing entities to a model

By default, models are not georeferenced. Georeferencing requires two
entities: a definition of the projected coordinated reference system
(CRS) used, and the transformation parameters between any local coordinate
system and that projected CRS if any.

This function will create the entities to store the projected CRS and
map conversion transformation, but will leave all the parameters blank.
It is this the users responsibility to specify the correct
georeferencing parameters. See
ifcopenshell.api.georeference.edit_georeferencing.

:param ifc_class: A type of IfcCoordinateOperation. For IFC2X3, this has no
    impact and only uses ePSet_MapConversion.

Example:

.. code:: python

    ifcopenshell.api.georeference.add_georeferencing(model)

#### edit_georeferencing
Edits the attributes of a map conversion, projected CRS, and true north

Setting the correct georeferencing parameters is a complex topic and
should ideally be done with three parties present: the lead architect,
surveyor, and a third-party digital engineer with expertise in IFC to
moderate. For more information, read the Bonsai documentation
for Georeferencing:
https://docs.bonsaibim.org/guides/authoring/georeferencing.html

For more information about the attributes and data types of an
IfcCoordinateOperation, consult the IFC documentation.

For more information about the attributes and data types of an
IfcProjectedCRS, consult the IFC documentation.

See ifcopenshell.util.geolocation for more utilities to convert to and
from local and map coordinates to check your results.

:param coordinate_operation: The dictionary of attribute names and values
    you want to edit.
    'MapUnit' attribute in IFC2X3 should be presented as a full unit name (string),
    in other IFC versions it's presented an IfcNamedUnit.
:param projected_crs: The IfcProjectedCRS dictionary of attribute
    names and values you want to edit.

Example:

.. code:: python

    ifcopenshell.api.georeference.add_georeferencing(model)
    # This is the simplest scenario, a defined CRS (GDA2020 / MGA Zone
    # 56, typically used in Sydney, Australia) but with no local
    # coordinates. This is only recommended for horizontal construction
    # projects, not for vertical construction (such as buildings).
    ifcopenshell.api.georeference.edit_georeferencing(model,
        projected_crs={"Name": "EPSG:7856"})

    # For buildings, it is almost always recommended to specify map
    # conversion parameters to a false origin and orientation to project
    # north. See the diagram in the Bonsai Georeferencing
    # documentation for correct calculation of the X Axis Abcissa and
    # Ordinate.
    ifcopenshell.api.georeference.edit_georeferencing(model,
        projected_crs={"Name": "EPSG:7856"},
        coordinate_operation={
            "Eastings": 335087.17, # The architect nominates a false origin
            "Northings": 6251635.41, # The architect nominates a false origin
            # Note: this is the angle difference between Project North
            # and Grid North. Remember: True North should never be used!
            "XAxisAbscissa": cos(radians(-30)), # The architect nominates a project north
            "XAxisOrdinate": sin(radians(-30)), # The architect nominates a project north
            "Scale": 0.99956, # Ask your surveyor for your site's average combined scale factor!
        })

#### edit_true_north
Edits the true north

Given project north being up (i.e. a vector of 0, 1), true north is defined
as a unitised 2D vector pointing to true north. Alternatively, true north
may be defined as a rotation from project north to true north.
Anticlockwise is positive.

Note that true north is not part of georeferencing, and is only optionally
provided as a reference value, typically for solar analysis. Remember: grid
north (what your surveyor will typically use) is not the same as true
north!

:param true_north: A unitised 2D vector, where each ordinate is a float, or
    an angle in decimal degrees where anticlockwise is positive.

Example:

.. code:: python

    # Both of these are identical, and indicate that:
    # - If project north is up the page, true north is in the top left
    # - The building is therefore facing north east
    ifcopenshell.api.georeference.edit_true_north(model, true_north=30)
    ifcopenshell.api.georeference.edit_true_north(model, true_north=(-0.5, 0.8660254))

    # This unsets true north
    ifcopenshell.api.georeference.edit_true_north(model, true_north=None)

#### edit_wcs
Edits the WCS for all geometric contexts to a translation and rotation

Typically, a project's local engineering origin (0, 0, 0) has a coordinate
operation (e.g. map conversion) to a projected CRS. If a WCS is provided,
the coordinate operation is relative to the WCS, not the local engineering
origin.

For example, if I have an IfcSite with a placement at (10, 0, 0) and a map
conversion of (50, 0, 0), my IfcSite's local XYZ is at (10, 0, 0) with an
ENH (Easting, Northing, Height) of (60, 0, 0).

If I then define by WCS at (15, 0, 0), my IfcSite's local XYZ is still at
(10, 0, 0) but its ENH is now at (45, 0, 0).

It's recommended to leave the WCS at 0,0,0. Please :)

:param x: The X translation of the WCS
:param y: The Y translation of the WCS
:param z: The Z translation of the WCS
:param rotation: The rotation around the Z axis (i.e. top down plan view)
    in decimal degrees of the WCS. Anticlockwise is positive.

Example:

.. code:: python

    # This is the simplest scenario, resetting the WCS to 0,0,0 with no rotation (recommended)
    ifcopenshell.api.georeference.edit_wcs(model)

#### remove_georeferencing
Remove georeferencing data

All georeferencing parameters such as projected CRS and map conversion
data will be lost.

In IFC2X3, the psets will be removed from the IfcProject.

Example:

    ifcopenshell.api.georeference.add_georeferencing(model)
    # Let's change our mind
    ifcopenshell.api.georeference.remove_georeferencing(model)

## Module: grid

### Description
Manages grid and grid axes

A grid in IFC may contain two or more axes running in two or more directions.

### Available Functions
- create_axis_curve
- create_grid_axis
- remove_grid_axis

### Function Docstrings
#### create_axis_curve
Adds curve geometry to a grid axis to represent the axis extents

An IFC grid will have a minimum of two axes (typically perpendicular). Each
axis will then have a line which represents the extents of the axis.

Points are provided as 3D coordinates in world space.
During axis creation, the coordinates will be localized relative to IfcGrid
and saved as 2D.

:param p1: The first point of the grid axis
:param p2: The second point of the grid axis
:param grid_axis: The IfcGridAxis element to add geometry to.
:param is_si: If true, the points are in meters, not project units

Example:

.. code:: python

    # A pretty standard rectangular grid, with only two axes.
    grid = ifcopenshell.api.root.create_entity(model, ifc_class="IfcGrid")
    axis_a = ifcopenshell.api.grid.create_grid_axis(model,
        axis_tag="A", uvw_axes="UAxes", grid=grid)
    axis_1 = ifcopenshell.api.grid.create_grid_axis(model,
        axis_tag="1", uvw_axes="VAxes", grid=grid)

    # By convention, alphabetic grids are horizontal, and numeric are vertical
    ifcopenshell.api.grid.create_axis_curve(
        model, p1=np.array((0., 0., 0.)), p2=np.array((10., 0., 0.)), grid_axis=axis_a)
    ifcopenshell.api.grid.create_axis_curve(
        model, p1=np.array((0., 0., 0.)), p2=np.array((0., 10., 0.)), grid_axis=axis_1)

#### create_grid_axis
Adds a new grid axis to a grid

An IFC grid will typically have a minimum of two axes which will be
perpendicular to one another. Grids may be rectangular (typically
perpendicular lines), radial (where one set of axes is a circle and the
other is a line), or triangular (three sets of axes, each at a different
angle to one another).

For a simple rectangular grid, the "UAxes" are a set of one or more
horizontal axes, which are typically labeled with the convention of A,
B, C, etc. The "VAxes" is another set of one or more vertical axes,
typically labeled with the convention of 1, 2, 3, etc. These axes are
horizontal or vertical relative to project north.

For a radial grid, the "UAxes" are straight lines, typically radiating
from a central point. The "VAxes" are circular perimeters, with the
center of these circles being the same central point.

For a triangular grid, the UAxes, VAxes, and WAxes are all sets of one
or more straight lines.

:param axis_tag: The name of the axis, that would typically be labeled
    on drawings or described on site during coordination, such as A, B,
    C, 1, 2, 3, etc. Defaults to "A".
:param same_sense: Determines whether the direction of the axis's line
    is reversed. True means the direction the geometry is defined in
    represents the direction of the axis. False means the direction is
    reversed. Leave as True if unsure. Defaults to "True".
:param uvw_axes: Choose from "UAxes", "VAxes" or "WAxes" depending on
    which set of axes the new axis you are adding should belong to.
    Defaults to "UAxes".
:param grid: The IfcGrid you are adding the axis to.
:return: The newly created IfcGridAxis

Example:

    # A pretty standard rectangular grid, with only two axes.
    grid = ifcopenshell.api.root.create_entity(model, ifc_class="IfcGrid")
    axis_a = ifcopenshell.api.grid.create_grid_axis(model,
        axis_tag="A", uvw_axes="UAxes", grid=grid)
    axis_1 = ifcopenshell.api.grid.create_grid_axis(model,
        axis_tag="1", uvw_axes="VAxes", grid=grid)

#### remove_grid_axis
Removes a grid axis from a grid

:param axis: The IfcGridAxis you want to remove.
:return: None

Example:

    # A pretty standard rectangular grid, with only two axes.
    grid = ifcopenshell.api.root.create_entity(model, ifc_class="IfcGrid")
    axis_a = ifcopenshell.api.grid.create_grid_axis(model,
        axis_tag="A", uvw_axes="UAxes", grid=grid)
    axis_1 = ifcopenshell.api.grid.create_grid_axis(model,
        axis_tag="1", uvw_axes="VAxes", grid=grid)

    # Let's create a third so we can remove it later
    axis_2 = ifcopenshell.api.grid.create_grid_axis(model,
        axis_tag="2", uvw_axes="VAxes", grid=grid)

    # Let's remove it!
    ifcopenshell.api.grid.remove_grid_axis(model, axis=axis_2)

## Module: group

### Description
Elements may be arbitrarily assigned to groups for organisation

Groups are useful for filtering elements or non-hierarchical organisation of a
model. Note that this only targets arbitrary groups. If you want to group
elements into a distribution system, see :mod:`ifcopenshell.api.system`.

### Available Functions
- add_group
- assign_group
- edit_group
- remove_group
- unassign_group
- update_group_products

### Function Docstrings
#### add_group
Adds a new group

An IFC group is an arbitrary collection of products, which are typically
physical. It may be used when there is no other more specific group
which may be used. Other types of groups include distribution systems,
which group together products that are connected and circulate a medium
(such as fluid or electricity), or zones, which group together spaces,
or structural load groups, which group together loads for structural
analysis, or inventories, which are groups of assets.

:param name: The name of the group. Defaults to "Unnamed"
:param description: The description of the purpose of the group.
:return: The newly created IfcGroup

Example:

.. code:: python

    ifcopenshell.api.group.add_group(model, name="Unit 1A")

#### assign_group
Assigns products to a group

If a product is already assigned to the group, it will not be assigned
twice.

:param products: A list of IfcProduct elements to assign to the group
:param group: The IfcGroup to assign the products to
:return: The IfcRelAssignsToGroup relationship
    or `None` if `products` was empty list.

Example:

.. code:: python

    group = ifcopenshell.api.group.add_group(model, name="Furniture")
    ifcopenshell.api.group.assign_group(model,
        products=model.by_type("IfcFurniture"), group=group)

#### edit_group
Edits the attributes of an IfcGroup

For more information about the attributes and data types of an
IfcGroup, consult the IFC documentation.

:param group: The IfcGroup entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    group = ifcopenshell.api.group.add_group(model, name="Unit 1A")
    ifcopenshell.api.group.edit_group(model,
        group=group, attributes={"Description": "All furniture and joinery included in the unit"})

#### remove_group
Removes a group

All products assigned to the group will remain, but the relationship to
the group will be removed.

:param group: The IfcGroup entity you want to remove
:return: None

Example:

.. code:: python

    group = ifcopenshell.api.group.add_group(model, name="Unit 1A")
    ifcopenshell.api.group.remove_group(model, group=group)

#### unassign_group
Unassigns products from a group

If the product isn't assigned to the group, nothing will happen.

:param products: A list of IfcProduct elements to unassign from the group
:param group: The IfcGroup to unassign from
:return: None

Example:

.. code:: python

    group = ifcopenshell.api.group.add_group(model, name="Furniture")
    furniture = model.by_type("IfcFurniture")
    ifcopenshell.api.group.assign_group(model, products=furniture, group=group)

    bad_furniture = furniture[0]
    ifcopenshell.api.group.unassign_group(model, products=[bad_furniture], group=group)

#### update_group_products
Sets a group products to be an explicit list of products

Any previous products assigned to that group will have their assignment
removed.

:param products: A list of IfcProduct elements to assign to the group
:param group: The IfcGroup to assign the products to
:return: The IfcRelAssignsToGroup relationship

Example:

.. code:: python

    group = ifcopenshell.api.group.add_group(model, name="Furniture")
    ifcopenshell.api.group.update_group_products(model,
        products=model.by_type("IfcFurniture"), group=group)

## Module: layer

### Description
Manage CAD layers

Note that in IFC, elements cannot be assigned to CAD layers. Instead, the
geometric representation of the element is associated to a layer.

If you want to associated a whole element to a "layer", consider using
:mod:`ifcopenshell.api.classification`.

### Available Functions
- add_layer
- add_layer_with_style
- assign_layer
- edit_layer
- remove_layer
- unassign_layer

### Function Docstrings
#### add_layer
Adds a new layer

An IFC layer is like a CAD layer. Portions of an object's geometry
(typically portions of its 2D linework) can be assigned to layers, which
can provide stylistic information such as line weights, colours, or
simply be used for filtering.

Layers have historically been used to organise CAD data and included in
ISO standards such as ISO 13567 or by the AIA. This alllows IFC data to
be compatible with older, 2D-oriented, layer-based workflows.

Some software that are still based on layers, such as Tekla or ArchiCAD
may also use this layer information for filtering.

:param name: The name of the layer. Defaults to "Unnamed".
:return: The newly created IfcPresentationLayerAssignment element

Example:

    ifcopenshell.api.layer.add_layer(model, name="AI-WALL-FULL-DIMS-N")

#### add_layer_with_style
Adds a new layer with style

:param name: The name of the layer.
:param on: Whether layer is visible.
:param frozen:
:param blocked: Whether layer elements are blocked from manipulation.
:param styles: Styles to be used as default for representation item.
:return: The newly created IfcPresentationLayerWithStyle element

Example:

    ifcopenshell.api.layer.add_layer_with_style(
        model,
        name="AI-WALL-FULL-DIMS-N",
        on=True,
        frozen=False,
        blocked=False,
        stlyes=[curve_style]
    )

#### assign_layer
Assigns representation items or representations to a layer

In IFC, instead of objects being assigned to layers, representation
items are assigned to layers. Representation items are portions of the
object's representation. For example, this allows a single IFC Window
element to have portions of its 2D linework (e.g. the cross section of
its frame) assigned to one layer, and another portion (e.g. the glazing
panels) assigned to another layer.

:param items: The list of IfcRepresentationItems / IfcRepresentations to assign to the layer. This
    should be the items from the object's IfcShapeRepresentation.
:param layer: The IfcPresentationLayerAssignment layer to assign the
    item to.
:return: None

Example:

.. code:: python

    # Remember, all geometry needs to specify the context it is part of first.
    # See ifcopenshell.api.context.add_context for details.
    model = ifcopenshell.api.context.add_context(model, context_type="Model")
    body = ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Body", target_view="MODEL_VIEW", parent=model
    )

    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")
    representation = ifcopenshell.api.geometry.add_wall_representation(model,
        context=body, length=5, height=3, thickness=0.2)
    ifcopenshell.api.geometry.assign_representation(model,
        product=wall, representation=representation)
    ifcopenshell.api.geometry.edit_object_placement(model, product=wall)

    # Now let's create a layer that contains walls
    layer = ifcopenshell.api.layer.add_layer(model, name="AI-WALL")

    # And assign our wall representation item (in this example, there is
    # only one item) to the layer.
    ifcopenshell.api.layer.assign_layer(model, items=[representation.Items[0]], layer=layer)

#### edit_layer
Edits the attributes of an IfcPresentationLayerAssignment

For more information about the attributes and data types of an
IfcPresentationLayerAssignment, consult the IFC documentation.

:param layer: The IfcPresentationLayerAssignment entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    layer = ifcopenshell.api.layer.add_layer(model, name="AI-WALL")
    ifcopenshell.api.layer.edit_layer(model,
        layer=layer, attributes={"Description": "All walls, based on the AIA standard."})

#### remove_layer
Removes a layer

All representation items assigned to the layer will remain, but the
relationship to the layer will be removed.

:param layer: The IfcPresentationLayerAssignment entity to remove
:return: None

Example:

.. code:: python

    layer = ifcopenshell.api.layer.add_layer(model, name="AI-WALL")
    ifcopenshell.api.layer.remove_layer(model, layer=layer)

#### unassign_layer
Unassigns representation items or representations from a layer

If the element isn't assigned to the layer, nothing will happen.
If after unassignment layer won't have any assigned items it will be
removed to keep IFC valid.

:param items: A list IfcRepresentationItem / IfcRepresentation elements to unassign
:param layer: The IfcPresentationLayerAssignment to unassign from
:return: None

Example:

.. code:: python

    # Remember, all geometry needs to specify the context it is part of first.
    # See ifcopenshell.api.context.add_context for details.
    model = ifcopenshell.api.context.add_context(model, context_type="Model")
    body = ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Body", target_view="MODEL_VIEW", parent=model
    )

    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")
    representation = ifcopenshell.api.geometry.add_wall_representation(model,
        context=body, length=5, height=3, thickness=0.2)
    ifcopenshell.api.geometry.assign_representation(model,
        product=wall, representation=representation)
    ifcopenshell.api.geometry.edit_object_placement(model, product=wall)

    # Now let's create a layer that contains walls
    layer = ifcopenshell.api.layer.add_layer(model, name="AI-WALL")

    # And assign our wall representation item (in this example, there is
    # only one item) to the layer.
    ifcopenshell.api.layer.assign_layer(model, items=[representation.Items[0]], layer=layer)

    # Let's undo it!
    ifcopenshell.api.layer.unassign_layer(model, items=[representation.Items[0]], layer=layer)

## Module: library

### Description
Manage references to external libraries

An external library is any system which uses a key to store information. This
allows you to associate IFC entities with any arbitrary external database, API,
system, and so on. This is typically useful in smart building systems.

### Available Functions
- add_library
- add_reference
- assign_reference
- edit_library
- edit_reference
- remove_library
- remove_reference
- unassign_reference

### Function Docstrings
#### add_library
Adds a new library to the project

A library is an external data source that is related to the project. It
may be a database, a spreadsheet, an API, or even a stack of papers in a
filing cabinet. This allows IFC data to store relationships to these
external data sources.

For example, you may have a list of laser scans of a site stored in an
online platform, which can be queried using an API. Or, you might have a
database of live building sensor data. So long as there is a clear
identifier you can use to link the two datasets together, you can create
a relationship.

Note that IFC does not store any instructions on how to access the
library. It does not specify whether a HTTP request or database
connection needs to be made or what protocol the library operates with.
Until this is fleshed out further, it is the users responsibility to
name the libraries consistently and use appropriate identifiers. For
example, if you are linking IFC data and Brickschema data, use a full
URI for the identifier with no abbreviation (e.g.
'http://example.org/digitaltwin#AHU01', not 'digitaltwin:AHU01').

A library will then contain a list of references within that library.
These references will then be related to IFC elements. For example, a
library will represent an external database, and a reference will point
to a particular table and row within that database.

:param name: The name of the library
:return: The newly created IfcLibraryInformation

Example:

.. code:: python

    ifcopenshell.api.library.add_library(model, name="Brickschema")

#### add_reference
Adds a new reference to a library

A library represents an external data source, such as a database,
spreadsheet, API, or something else that contains information related to
the IFC project. Within a library, there will be one or more references,
such as reference to a particular table or row in a database, or a sheet
and row or column in a spreadsheet, a URI in a linked data Brickschema
file, 32-bit decimal BACnetObjectIdentifier in a BACnet system, IP
address in a network, and so on.

These references can then be related to IFC elements. You cannot relate
an IFC element directly to a library, it must be related to one of the
library's references.

:param library: The IfcLibraryInformation element to add a reference to
:return: The newly created IfcLibraryReference element

Example:

.. code:: python

    library = ifcopenshell.api.library.add_library(model, name="Brickschema")

    # Let's create a reference to a single AHU in our Brickschema dataset
    reference = ifcopenshell.api.library.add_reference(model, library=library)
    ifcopenshell.api.library.edit_reference(model,
        reference=reference, attributes={"Identification": "http://example.org/digitaltwin#AHU01"})

#### assign_reference
Associates a list products with a library reference

A product may be associated with zero, one, or many references across
multiple libraries. See ifcopenshell.api.library.add_reference for more
detail about how references work.

:param products: The list of IfcProducts you want to associate with the reference
:param reference: The IfcLibraryReference you want the product to be
    associated with.
:return: The IfcRelAssociatesLibrary relationship entity
    or `None` if `products` was an empty list or all products were
    already assigned to the `reference`.

Example:

.. code:: python

    library = ifcopenshell.api.library.add_library(model, name="Brickschema")

    # Let's create a reference to a single AHU in our Brickschema dataset
    reference = ifcopenshell.api.library.add_reference(model, library=library)
    ifcopenshell.api.library.edit_reference(model,
        reference=reference, attributes={"Identification": "http://example.org/digitaltwin#AHU01"})

    # Let's assume we have an AHU in our model.
    ahu = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcUnitaryEquipment", predefined_type="AIRHANDLER")

    # And now assign the IFC model's AHU with its Brickschema counterpart
    ifcopenshell.api.library.assign_reference(model, reference=reference, products=[ahu])

#### edit_library
Edits the attributes of an IfcLibraryInformation

For more information about the attributes and data types of an
IfcLibraryInformation, consult the IFC documentation.

:param library: The IfcLibraryInformation entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    library = ifcopenshell.api.library.add_library(model, name="Brickschema")
    ifcopenshell.api.library.edit_library(model, library=library,
        attributes={"Description": "A Brickschema TTL including only mechanical distribution systems."})

#### edit_reference
Edits the attributes of an IfcLibraryReference

For more information about the attributes and data types of an
IfcLibraryReference, consult the IFC documentation.

:param reference: The IfcLibraryReference entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    library = ifcopenshell.api.library.add_library(model, name="Brickschema")
    # Let's create a reference to a single AHU in our Brickschema dataset
    reference = ifcopenshell.api.library.add_reference(model, library=library)
    ifcopenshell.api.library.edit_reference(model,
        reference=reference, attributes={"Identification": "http://example.org/digitaltwin#AHU01"})

#### remove_library
Removes a library

All references along with their relationships will also be removed. Any
products which have relationships to this library will not be removed.

:param library: The IfcLibraryInformation entity you want to remove
:return: None

Example:

.. code:: python

    library = ifcopenshell.api.library.add_library(model, name="Brickschema")
    ifcopenshell.api.library.remove_library(model, library=library)

#### remove_reference
Removes a library reference

Any products which have relationships to this reference will not be
removed.

:param reference: The IfcLibraryReference entity you want to remove
:return: None

Example:

.. code:: python

    library = ifcopenshell.api.library.add_library(model, name="Brickschema")
    reference = ifcopenshell.api.library.add_reference(model, library=library)
    # Let's change our mind and remove it.
    ifcopenshell.api.library.remove_reference(model, reference=reference)

#### unassign_reference
Unassigns a product of products from a reference

If the product isn't assigned to the reference, nothing will happen.

:param reference: The IfcLibraryReference to unassign from
:param products: A list of IfcProduct elements to unassign from the reference
:return: None

Example:

.. code:: python

    library = ifcopenshell.api.library.add_library(model, name="Brickschema")

    # Let's create a reference to a single AHU in our Brickschema dataset
    reference = ifcopenshell.api.library.add_reference(model, library=library)
    ifcopenshell.api.library.edit_reference(model,
        reference=reference, attributes={"Identification": "http://example.org/digitaltwin#AHU01"})

    # Let's assume we have an AHU in our model.
    ahu = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcUnitaryEquipment", predefined_type="AIRHANDLER")

    # And now assign the IFC model's AHU with its Brickschema counterpart
    ifcopenshell.api.library.assign_reference(model, reference=reference, products=[ahu])

    # Let's change our mind and unassign it.
    ifcopenshell.api.library.unassign_reference(model, reference=reference, products=[ahu])

## Module: material

### Description
Manage physical materials (concrete, steel, etc) and their association to
elements

IFC supports both simple materials and parametric materials (materials that
have layered thicknesses or cross sectional profiles).

Parametric materials will include parametric constraints on the geometry of
the element. These API functions do not cover that responsibility. See
:mod:`ifcopenshell.api.geometry`.

Note that this API only covers physical materials, not visual styles. If you
want to look at visual styles such as colours, transparency, shading, or
rendering options, see :mod:`ifcopenshell.api.style`.

### Available Functions
- add_constituent
- add_layer
- add_list_item
- add_material
- add_material_set
- add_profile
- assign_material
- assign_profile
- copy_material
- edit_assigned_material
- edit_constituent
- edit_layer
- edit_layer_usage
- edit_material
- edit_profile
- edit_profile_usage
- remove_constituent
- remove_layer
- remove_list_item
- remove_material
- remove_material_set
- remove_profile
- reorder_set_item
- set_shape_aspect_constituents
- unassign_material

### Function Docstrings
#### add_constituent
Adds a new constituent to a constituent set

A constituent describes how a portion of an object is made out of a
material whereas other portions of the object is made out of other
materials. For example, a window might be made out of an aluminium frame
and a glass panel. The aluminium used for the frame is one constituent
of the material, and glass would be another constituent. Another example
might be concrete, where one constituent might be cement, and another
constituent might be binder. In the case of the window, the constituent
is represented explicitly by the geometry of the window frame and the
geometry of the window panel. In the case of a concrete slab, the
constituents might be represented in terms of percentages.

Constituents are not available in IFC2X3.

:param constituent_set: The IfcMaterialConstituentSet that the
    constituent is part of. The constituent set represents a group of
    constituents. See ifcopenshell.api.material.add_material_set for
    information on how to add a constituent set.
:param material: The IfcMaterial that the constituent is made out of.
:param name: An optional name of the constituent.
:return: The newly created IfcMaterialConstituent

Example:

.. code:: python

    # Let's imagine we have a window type that has an aluminium frame
    # and a glass glazing panel. Notice we are assigning to the type
    # only, as all occurrences of that type will automatically inherit
    # the material.
    window_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWindowType")

    # First, let's create a constituent set. This will later be assigned
    # to our window element.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="Window", set_type="IfcMaterialConstituentSet")

    # Let's create a few materials, it's important to also give them
    # categories. This makes it easy for model recipients to do things
    # like "show me everything made out of aluminium / concrete / steel
    # / glass / etc". The IFC specification states a list of categories
    # you can use.
    aluminium = ifcopenshell.api.material.add_material(model, name="AL01", category="aluminium")
    glass = ifcopenshell.api.material.add_material(model, name="GLZ01", category="glass")

    # Now let's use those materials as two constituents in our set.
    ifcopenshell.api.material.add_constituent(model,
        constituent_set=material_set, material=aluminium, name="Framing")
    ifcopenshell.api.material.add_constituent(model,
        constituent_set=material_set, material=glass, name="Glazing")

    # Great! Let's assign our material set to our window type.
    # We're technically not done here, we might want to add geometry to
    # our window too, but to keep this example simple, geometry is
    # optional and it is enough to say that this window is made out of
    # aluminium and glass.
    ifcopenshell.api.material.assign_material(model, products=[window_type], material=material_set)

#### add_layer
Adds a new layer to a layer set

A layer represents a portion of material within a layered build up,
defined by a thickness. Typical layered construction includes walls and
slabs, where a wall might include a layer of finish, a layer of
structure, a layer of insulation, and so on. It is recommended to define
layered construction this way where it is unnecessary to define the
exact geometry of how the wall or slab will be built, and it will
instead be determined on site by a trade.

Layers are defined in a particular order and thickness, so that it is
clear which layer comes next.

:param layer_set: The IfcMaterialLayerSet that the layer is part of. The
    layer set represents a group of layers. See
    ifcopenshell.api.material.add_material_set for more information on
    how to add a layer set.
:param material: The IfcMaterial that the layer is made out of.
:param name: An optional name of the layer.
:return: The newly created IfcMaterialLayer

Example:

.. code:: python

    # Let's imagine we have a wall type that has two layers of
    # gypsum with steel studs inside. Notice we are assigning to
    # the type only, as all occurrences of that type will automatically
    # inherit the material.
    wall_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWallType", name="WAL01")

    # First, let's create a material set. This will later be assigned
    # to our wall type element.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="GYP-ST-GYP", set_type="IfcMaterialLayerSet")

    # Let's create a few materials, it's important to also give them
    # categories. This makes it easy for model recipients to do things
    # like "show me everything made out of aluminium / concrete / steel
    # / glass / etc". The IFC specification states a list of categories
    # you can use.
    gypsum = ifcopenshell.api.material.add_material(model, name="PB01", category="gypsum")
    steel = ifcopenshell.api.material.add_material(model, name="ST01", category="steel")

    # Now let's use those materials as three layers in our set, such
    # that the steel studs are sandwiched by the gypsum. Let's imagine
    # we're setting the layer thickness in millimeters.
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=gypsum)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": 13})
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=steel)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": 92})
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=gypsum)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": 13})

    # Great! Let's assign our material set to our wall type.
    ifcopenshell.api.material.assign_material(model, products=[wall_type], material=material_set)

#### add_list_item
Adds a new material in a list of materials

In IFC2X3, if you wanted an object to have multiple materials (i.e. a
composite material) you would assign the object to a material list,
which would contain a list of materials. For example, a window might
have a list of 2 materials, one being aluminium for the frame, and
another being glass for the panel.

In IFC4 and above, this is deprecated and should not be used. Instead,
you should use constituent sets instead, which achieve the same thing
but are more powerful as they allow you to define the properties of the
constituents too.

However if you're stuck on IFC2X3, you have my condolences as well as
this function.

:param material_list: The IfcMaterialList the material should be added
    to.
:param material: The IfcMaterial to add to the list
:return: None

Example:

.. code:: python

    # Let's imagine we have a window type that has an aluminium frame
    # and a glass glazing panel. Notice we are assigning to the type
    # only, as all occurrences of that type will automatically inherit
    # the material.
    window_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWindowType")

    # First, let's create a list. This will later be assigned to our
    # window element.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="Window", set_type="IfcMaterialList")

    # Let's create a few materials, it's important to also give them
    # categories. This makes it easy for model recipients to do things
    # like "show me everything made out of aluminium / concrete / steel
    # / glass / etc". The IFC specification states a list of categories
    # you can use.
    aluminium = ifcopenshell.api.material.add_material(model, name="AL01", category="aluminium")
    glass = ifcopenshell.api.material.add_material(model, name="GLZ01", category="glass")

    # Now let's use those materials as two items in our list.
    ifcopenshell.api.material.add_list_item(model, material_list=material_set, material=aluminium)
    ifcopenshell.api.material.add_list_item(model, material_list=material_set, material=glass)

    # Great! Let's assign our material set to our window type.
    # We're technically not done here, we might want to add geometry to
    # our window too, but to keep this example simple, geometry is
    # optional and it is enough to say that this window is made out of
    # aluminium and glass.
    ifcopenshell.api.material.assign_material(model, products=[window_type], material=material_set)

#### add_material
Adds a new material

A material in IFC represents a physical material, such as timber, steel,
concrete, aluminium, etc. It may also contain physical properties used
for structural or lighting simulation. Note that unlike the computer
graphics industry, a material by itself does not define any colour or
lighting information. Colours in IFC are known as "styles", and an IFC
material may or may not have any style information associated with it.
See ifcopenshell.api.style for more information.

A material is typically given a code name which is used by architects in
elevations and details when tagging finishes. Materials are also useful
to structural engineers in specifying the exact types of concrete and
steel to be used in structural simulations.

In addition, materials can belong to a category. Specifying this
category is critical to allow model recipients to make simple queries
like "show me all concrete / steel" elements in the model. Without
standardised category naming of all materials, this type of query
becomes a bespoke and inefficient task. A list of categories are:
'concrete', 'steel', 'aluminium', 'block', 'brick', 'stone', 'wood',
'glass', 'gypsum', 'plastic', and 'earth'. The user is allowed to
specify their own category instead if none of these categories are
appropriate.

Note that categories are not available in IFC2X3. This shortcoming is
one of the big reasons projects should upgrade to IFC4.

Additionally, a material's description provides more information beyond
its name or category.

:param name: The name of the material, typically tagged in a finishes
    drawing or schedule.
:param category: The category of the material.
:param description: A description of the material.
:return: The newly created IfcMaterial

Example:

.. code:: python

    # Let's create two materials with their respective categories
    concrete = ifcopenshell.api.material.add_material(model, name="CON01", category="concrete", description="Garage Slab")
    steel = ifcopenshell.api.material.add_material(model, name="ST01", category="steel", description="Corten Steel")

    # Let's imagine an urban concrete bench which is purely made out of concrete
    concrete_bench = ifcopenshell.api.root.create_entity(model, ifc_class="IfcFurnitureType")

    # Assign the concrete material to that bench. Note that no colour
    # "Style" has been specified.
    ifcopenshell.api.material.assign_material(model, products=[concrete_bench], material=concrete)

#### add_material_set
Adds a new material set

IFC allows you to state that objects are made out of multiple materials.
These are known generically as material sets, but may also be called
layered materials, composite materials, or other names in software.

There are three types of material sets:

 - A layer set, used for layered construction such as walls, where the
   element is parametrically made out of extruded layers, each layer
   having a thickness defined. Even though this is known as a layer
   "set" it is still recommended to use it for all standared layered
   construction as it describes the intent of the element to be layered
   construction and thus can be used for parametric editing.
 - A profile set, used for profiled construction such as beams or
   columns, where the element is parametrically made out of one or more
   extruded profiles, where each profile may be parametric from a
   standard section (e.g. standardised steel profile) or an arbitrary
   shape (e.g. cold rolled sections, or skirtings, moldings, etc). Note
   that even though this is called a profile "set", it should still be
   used even if there is only a single profile. This is not available in
   IFC2X3.
 - A constituent set, used for arbitrary composite construction where
   the object is made out of multiple materials. The constituents may be
   explicitly defined via a shape, such as a window where the frame
   geometry is made from one material and the panel geometry is made
   from another material. Alternatively, the constituents may be
   represented in terms of percentages, such as in mixtures like
   concrete where there might be a percentage constituent of cement and
   another percentage constituent of binder. This is not available in
   IFC2X3.

There is also a fourth material set known as a material list, which is a
legacy type of set used by IFC2X3. It should not be used on IFC4 and
above, and constituent sets should be used instead.

:param name: The name of the material set, which may be purely
    descriptive or annotated in drawings. Defaults to "Unnamed".
:param set_type: What type of set you want to create, chosen from
    IfcMaterialLayerSet, IfcMaterialProfileSet,
    IfcMaterialConstituentSet, or IfcMaterialList. Defaults to
    IfcMaterialConstituentSet.
:return: The newly created material set element

Example:

.. code:: python

    # Let's imagine we have a wall type that has two layers of
    # gypsum with steel studs inside. Notice we are assigning to
    # the type only, as all occurrences of that type will automatically
    # inherit the material.
    wall_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWallType", name="WAL01")

    # First, let's create a material set. This will later be assigned
    # to our wall type element.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="GYP-ST-GYP", set_type="IfcMaterialLayerSet")

    # Let's create a few materials, it's important to also give them
    # categories. This makes it easy for model recipients to do things
    # like "show me everything made out of aluminium / concrete / steel
    # / glass / etc". The IFC specification states a list of categories
    # you can use.
    gypsum = ifcopenshell.api.material.add_material(model, name="PB01", category="gypsum")
    steel = ifcopenshell.api.material.add_material(model, name="ST01", category="steel")

    # Now let's use those materials as three layers in our set, such
    # that the steel studs are sandwiched by the gypsum. Let's imagine
    # we're setting the layer thickness in millimeters.
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=gypsum)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": 13})
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=steel)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": 92})
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=gypsum)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": 13})

    # Great! Let's assign our material set to our wall type.
    ifcopenshell.api.material.assign_material(model, products=[wall_type], material=material_set)

#### add_profile
Add a new profile item to a profile set

A profile item in a profile set represents an extruded 2D profile curve
that is extruded along the axis of the element. Most commonly there will
only be a single profile item in a profile set. For example, a beam will
have a material profile set containing a single profile item, which may
have a steel material and a I-beam shaped profile curve.

Note that the "profile item" represents a single extrusion in the
profile set, whereas the "profile curve" represents a 2D curve used by a
"profile item".

Profile is not optional for IfcMaterialProfile but it is optional for this API
call and can be assigned later with material.assign_profile.

In some cases, a profiled element (i.e. beam, column) may be a composite
beam or column and include multiple extrusions. This is rare. The order
of the profiles does not matter.

:param profile_set: The IfcMaterialProfileSet that the profile is part of. The
    profile set represents a group of profile items. See
    ifcopenshell.api.material.add_material_set for more information on
    how to add a profile set.
:param material: The IfcMaterial that the profile item is made out of.
:param profile: The IfcProfileDef that represents the 2D cross section
    of the the profile item.
:param name: An optional name of the material profile (not the geometric
    profile).
:return: The newly created IfcMaterialProfile

Example:

.. code:: python

    # Let's imagine we have a steel I-beam. Notice we are assigning to
    # the type only, as all occurrences of that type will automatically
    # inherit the material.
    beam_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBeamType", name="B1")

    # First, let's create a material set. This will later be assigned
    # to our beam type element.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="B1", set_type="IfcMaterialProfileSet")

    # Create a steel material.
    steel = ifcopenshell.api.material.add_material(model, name="ST01", category="steel")

    # Create an I-beam profile curve. Notice how we name our profiles
    # based on standardised steel profile names.
    hea100 = file.create_entity(
        "IfcIShapeProfileDef", ProfileName="HEA100", ProfileType="AREA",
        OverallWidth=100, OverallDepth=96, WebThickness=5, FlangeThickness=8, FilletRadius=12,
    )

    # Define that steel material and cross section as a single profile
    # item. If this were a composite beam, we might add multiple profile
    # items instead, but this is rarely the case in most construction.
    ifcopenshell.api.material.add_profile(model,
        profile_set=material_set, material=steel, profile=hea100)

    # Great! Let's assign our material set to our beam type.
    ifcopenshell.api.material.assign_material(model, products=[beam_type], material=material_set)

#### assign_material
Assigns a material to the list of products

Will unassign previously assigned material.

When a material is assigned to a product, it means that the product is
made out of that material. In its simplest form, a single material may
be assigned to a product, meaning that the entire product is made out of
that one material. Alternatively, a material set may be assigned to a
product, meaning that the product is made out of a set of materials.
There are three types of sets, including layered construction, profiled
materials, and arbitrary material constituents. See
ifcopenshell.api.material.add_material_set for details.

Materials are typically assigned to the element types rather than
individual occurrences of elements. Individual occurrences would then
inherit the material from the type.

If the type has a material set, then the geometry of the occurrences
must comply with the material set. For example, if the type has a
constituent set, then it is expected that all occurrences also inherit
the geometry of the type, which is made out of those constituents.
Alternatively, if the type has a layer set, then all occurrences must
have geometry that has a thickness equal to the sum of all layers. If a
type has a profile set, then all occurrences must has the same profile
extruded along its axis.

For layers and profiles assigned to types, the occurrences must be
assigned an IfcMaterialLayerSetUsage or an IfcMaterialProfileSetUsage.
This allows individual occurrences to override the layered or profiled
construction offset from a reference line.

:param products: The list of IfcProducts to assign the material or material set
    to.
:param type: Choose from "IfcMaterial", "IfcMaterialConstituentSet",
    "IfcMaterialLayerSet", "IfcMaterialLayerSetUsage",
    "IfcMaterialProfileSet", "IfcMaterialProfileSetUsage", or
    "IfcMaterialList". Note that "Set Usages" may only be assigned to
    occurrences, not types. Defaults to "IfcMaterial".
:param material: The IfcMaterial or material set you are assigning here.
    If type is Usage then no need to provide `material`, it will be deduced
    from the element type automatically.
    If IfcMaterial is provided as material and type is not IfcMaterial,
    provided material will be ignored except for IfcMaterialList
    where it will be used as part of the list.
:return: IfcRelAssociatesMaterial entity
    or a list of IfcRelAssociatesMaterial entities
    (possible if `type` is Usage
    and `products` require different Usages)
    or `None` if `products` was empty list.

Example:

.. code:: python

    # Let's start with a simple concrete material
    concrete = ifcopenshell.api.material.add_material(model, name="CON01", category="concrete")

    # Let's imagine a concrete bench made out of a single concrete
    # material. Let's assign it to the type.
    bench_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcFurnitureType")
    ifcopenshell.api.material.assign_material(model,
        products=[bench_type], type="IfcMaterial", material=concrete)

    # Let's imagine there are a two occurrences of this bench.  It's not
    # necessary to assign any material to these benches as they
    # automatically inherit the material from the type.
    bench1 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcFurniture")
    bench2 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcFurniture")
    ifcopenshell.api.type.assign_type(model, related_objects=[bench1], relating_type=bench_type)
    ifcopenshell.api.type.assign_type(model, related_objects=[bench2], relating_type=bench_type)

    # If we have a concrete wall, we should use a layer set. Again,
    # let's start with a wall type, not occurrences.
    wall_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWallType", name="WAL01")

    # Even though there is only one layer in our layer set, we still use
    # a layer set because it makes it clear that this is a layered
    # construction. Let's say it's a 200mm thick concrete layer.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="CON200", set_type="IfcMaterialLayerSet")
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=steel)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": 200})

    # Our wall type now has the layer set assigned to it
    ifcopenshell.api.material.assign_material(model,
        products=[wall_type], type="IfcMaterialLayerSet", material=material_set)

    # Let's imagine an occurrence of this wall type.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")
    ifcopenshell.api.type.assign_type(model, related_objects=[wall], relating_type=wall_type)

    # Our wall occurrence needs to have a "set usage" which describes
    # how the layers relate to a reference line (typically a 2D line
    # representing the extents of the wall). Usages are special since
    # they automatically detect the inherited material set from the
    # type. You'd write similar code for a profile set.
    ifcopenshell.api.material.assign_material(model,
        products=[wall], type="IfcMaterialLayerSetUsage")

    # To be complete, let's create the wall's axis and body
    # representation. Notice how the axis guides the walls "reference
    # line" which determines where layers are extruded from, and the
    # body has a thickness of 200mm, same as our total layer set
    # thickness.
    axis = ifcopenshell.api.geometry.add_axis_representation(model,
        context=axis_context, axis=[(0.0, 0.0), (5000.0, 0.0)])
    body = ifcopenshell.api.geometry.add_wall_representation(model,
        context=body_context, length=5000, height=3000, thickness=200)
    ifcopenshell.api.geometry.assign_representation(model, product=wall, representation=axis)
    ifcopenshell.api.geometry.assign_representation(model, product=wall, representation=body)
    ifcopenshell.api.geometry.edit_object_placement(model, product=wall)

#### assign_profile
Changes the profile curve of a material profile item in a profile set

In addition to changing the profile curve, it will also change the
profile curve used in any body representation extrusions.

:param material_profile: The IfcMaterialProfile to change the profile
    curve of. See ifcopenshell.api.material.add_profile to see how to
    create profiles.
:param profile: The IfcProfileDef to set the profile item's curve to.
:return: None

Example:

.. code:: python

    # Let's imagine we have a steel I-beam. Notice we are assigning to
    # the type only, as all occurrences of that type will automatically
    # inherit the material.
    beam_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBeamType", name="B1")

    # First, let's create a material set. This will later be assigned
    # to our beam type element.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="B1", set_type="IfcMaterialProfileSet")

    # Create a steel material.
    steel = ifcopenshell.api.material.add_material(model, name="ST01", category="steel")

    # Create an I-beam profile curve. Notice how we name our profiles
    # based on standardised steel profile names.
    hea100 = model.create_entity(
        "IfcIShapeProfileDef", ProfileName="HEA100", ProfileType="AREA",
        OverallWidth=100, OverallDepth=96, WebThickness=5, FlangeThickness=8, FilletRadius=12,
    )

    # Define that steel material and cross section as a single profile
    # item. If this were a composite beam, we might add multiple profile
    # items instead, but this is rarely the case in most construction.
    profile_item = ifcopenshell.api.material.add_profile(model,
        profile_set=material_set, material=steel, profile=hea100)

    # Great! Let's assign our material set to our beam type.
    ifcopenshell.api.material.assign_material(model, products=[beam_type], material=material_set)

    # Let's create an occurrence of this beam.
    beam = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBeam", name="B1.01")
    ifcopenshell.api.material.assign_material(model,
        products=[beam], type="IfcMaterialProfileSetUsage")

    # Let's give a 1000mm long beam body representation.
    body = ifcopenshell.api.geometry.add_profile_representation(
        context=body_context, profile=hea100, depth=1000)
    ifcopenshell.api.geometry.assign_representation(model, product=beam, representation=body)
    ifcopenshell.api.geometry.edit_object_placement(model, product=beam)

    # Now let's change the profile to a HEA200 standard profile instead.
    # This will automatically change the body representation that we
    # just added as well to a HEA200 profile.
    hea200 = model.create_entity(
        "IfcIShapeProfileDef", ProfileName="HEA200", ProfileType="AREA",
        OverallWidth=200, OverallDepth=190, WebThickness=6.5, FlangeThickness=10, FilletRadius=18,
    )
    ifcopenshell.api.material.assign_profile(model, material_profile=profile_item, profile=hea200)

#### copy_material
Copies a material or material set

All material psets and styles are copied. The copied material is not
associated to any elements.

If a material set is copied, the set items are also copied. However the
underlying materials (and profiles) used within the set items are reused.

If a material is associated with a presentation style, that presentation
style is reused.

:param material: The IfcMaterialDefinition to copy
:return: The new copy of the material

Example:

.. code:: python

    concrete = ifcopenshell.api.material.add_material(model, name="CON01", category="concrete")

    # Let's duplicate the concrete material
    concrete_copy = ifcopenshell.api.material.copy_material(model, material=concrete)

#### edit_assigned_material
Edits the attributes of an IfcMaterial

For more information about the attributes and data types of an
IfcMaterial, consult the IFC documentation.

:param element: The IfcMaterial entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    concrete = ifcopenshell.api.material.add_material(model, name="CON01", category="concrete")
    ifcopenshell.api.material.edit_assigned_material(model,
        element=concrete, attributes={"Description": "40MPA concrete with broom finish"})

#### edit_constituent
Edits the attributes of an IfcMaterialConstituent

For more information about the attributes and data types of an
IfcMaterialConstituent, consult the IFC documentation.

:param constituent: The IfcMaterialConstituent entity you want to edit
:param attributes: a dictionary of attribute names and values.
:param material: The IfcMaterial entity you want to change the constituent to
:return: None

Example:

.. code:: python

    # Let's add two materials
    aluminium1 = ifcopenshell.api.material.add_material(model, name="AL01", category="aluminium")
    aluminium2 = ifcopenshell.api.material.add_material(model, name="AL02", category="aluminium")
    glass = ifcopenshell.api.material.add_material(model, name="GLZ01", category="glass")

    material_set = ifcopenshell.api.material.add_material_set(model,
        name="Window", set_type="IfcMaterialConstituentSet")

    # Set up two constituents, one for the frame and the other for the glazing.
    framing = ifcopenshell.api.material.add_constituent(model,
        constituent_set=material_set, material=aluminium1)
    glazing = ifcopenshell.api.material.add_constituent(model,
        constituent_set=material_set, material=glass)

    # Let's make sure this constituent refers to the framing of the
    # window and uses the second aluminium material instead.
    ifcopenshell.api.material.edit_constituent(model,
        constituent=framing, attributes={"Name": "Framing"}, material=aluminium2)

    ifcopenshell.api.material.edit_constituent(model,
        constituent=constituent, attributes={"Name": "Glazing"})

#### edit_layer
Edits the attributes of an IfcMaterialLayer

For more information about the attributes and data types of an
IfcMaterialLayer, consult the IFC documentation.

:param layer: The IfcMaterialLayer entity you want to edit
:param attributes: a dictionary of attribute names and values.
:param material: The IfcMaterial entity you want the layer to be made
    from.
:return: None

Example:

.. code:: python

    # Let's create two materials typically used for steel stud partition
    # walls with gypsum lining.
    gypsum = ifcopenshell.api.material.add_material(model, name="PB01", category="gypsum")
    steel = ifcopenshell.api.material.add_material(model, name="ST01", category="steel")

    # Create a material layer set to contain our layers.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="GYP-ST-GYP", set_type="IfcMaterialLayerSet")

    # Now let's use those materials as three layers in our set, such
    # that the steel studs are sandwiched by the gypsum. Let's imagine
    # we're setting the layer thickness in millimeters.
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=gypsum)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": 13})
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=steel)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": 92})
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=gypsum)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": 13})

#### edit_layer_usage
Edits the attributes of an IfcMaterialLayerSetUsage

This is typically used to change the offset from the reference line to
the layers.

For more information about the attributes and data types of an
IfcMaterialLayerSetUsage, consult the IFC documentation.

:param usage: The IfcMaterialLayerSetUsage entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Let's start with a simple concrete material
    concrete = ifcopenshell.api.material.add_material(model, name="CON01", category="concrete")

    # If we have a concrete wall, we should use a layer set. Again,
    # let's start with a wall type, not occurrences.
    wall_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWallType", name="WAL01")

    # Even though there is only one layer in our layer set, we still use
    # a layer set because it makes it clear that this is a layered
    # construction. Let's say it's a 200mm thick concrete layer.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="CON200", set_type="IfcMaterialLayerSet")
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=steel)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": 200})

    # Our wall type now has the layer set assigned to it
    ifcopenshell.api.material.assign_material(model,
        products=[wall_type], type="IfcMaterialLayerSet", material=material_set)

    # Let's imagine an occurrence of this wall type.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")
    ifcopenshell.api.type.assign_type(model, related_objects=[wall], relating_type=wall_type)

    # Our wall occurrence needs to have a "set usage" which describes
    # how the layers relate to a reference line (typically a 2D line
    # representing the extents of the wall). Usages are special since
    # they automatically detect the inherited material set from the
    # type. You'd write similar code for a profile set.
    rel = ifcopenshell.api.material.assign_material(model,
        products=[wall], type="IfcMaterialLayerSetUsage")

    # Let's change the offset from the reference line to be 200mm
    # instead of the default of 0mm.
    ifcopenshell.api.material.edit_layer_usage(model,
        usage=rel.RelatingMaterial, attributes={"OffsetFromReferenceLine": 200})

#### edit_material
Edits the attributes of an IfcMaterial

#### edit_profile
Edits the attributes of an IfcMaterialProfile

For more information about the attributes and data types of an
IfcMaterialProfile, consult the IFC documentation.

:param profile: The IfcMaterialProfile entity you want to edit
:param attributes: a dictionary of attribute names and values.
:param profile_def: The IfcProfileDef entity the profile curve should be
    extruded from.
:param material: The IfcMaterial entity you want to change the profile
    to be made from.
:return: None

Example:

.. code:: python

    # Let's create a material set to store our profiles.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="B1", set_type="IfcMaterialProfileSet")

    # Create a couple steel materials.
    steel1 = ifcopenshell.api.material.add_material(model, name="ST01", category="steel")
    steel2 = ifcopenshell.api.material.add_material(model, name="ST01", category="steel")

    # Create some I-shaped profiles. Notice how we name our profiles based
    # on standardised steel profile names.
    hea100 = file.create_entity(
        "IfcIShapeProfileDef", ProfileName="HEA100", ProfileType="AREA",
        OverallWidth=100, OverallDepth=96, WebThickness=5, FlangeThickness=8, FilletRadius=12,
    )
    hea200 = file.create_entity(
        "IfcIShapeProfileDef", ProfileName="HEA200", ProfileType="AREA",
        OverallWidth=200, OverallDepth=190, WebThickness=6.5, FlangeThickness=10, FilletRadius=18,
    )

    # Define that steel material and cross section as a single profile
    # item. If this were a composite beam, we might add multiple profile
    # items instead, but this is rarely the case in most construction.
    profile_item = ifcopenshell.api.material.add_profile(model,
        profile_set=material_set, material=steel1, profile=hea100)

    # Edit our profile item to use a HEA200 profile instead made out of
    # another type of steel.
    ifcopenshell.api.material.edit_profile(model,
        profile=profile_item, profile_def=hea200, material=steel2)

#### edit_profile_usage
Edits the attributes of an IfcMaterialProfileSetUsage

This is typically used to change the cardinal point of the profile.
The cardinal point represents whether the profile is extruded along the
center of the axis line, at a corner, at a shear center, at the bottom,
top, etc.

For more information about the attributes and data types of an
IfcMaterialProfileSetUsage, consult the IFC documentation.

:param usage: The IfcMaterialProfileSetUsage entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Let's imagine we have a steel I-beam. Notice we are assigning to
    # the type only, as all occurrences of that type will automatically
    # inherit the material.
    beam_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBeamType", name="B1")

    # First, let's create a material set. This will later be assigned
    # to our beam type element.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="B1", set_type="IfcMaterialProfileSet")

    # Create a steel material.
    steel = ifcopenshell.api.material.add_material(model, name="ST01", category="steel")

    # Create an I-beam profile curve. Notice how we name our profiles
    # based on standardised steel profile names.
    hea100 = model.create_entity(
        "IfcIShapeProfileDef", ProfileName="HEA100", ProfileType="AREA",
        OverallWidth=100, OverallDepth=96, WebThickness=5, FlangeThickness=8, FilletRadius=12,
    )

    # Define that steel material and cross section as a single profile
    # item. If this were a composite beam, we might add multiple profile
    # items instead, but this is rarely the case in most construction.
    profile_item = ifcopenshell.api.material.add_profile(model,
        profile_set=material_set, material=steel, profile=hea100)

    # Great! Let's assign our material set to our beam type.
    ifcopenshell.api.material.assign_material(model, products=[beam_type], material=material_set)

    # Let's create an occurrence of this beam.
    beam = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBeam", name="B1.01")
    rel = ifcopenshell.api.material.assign_material(model, material=material_set,
        products=[beam], type="IfcMaterialProfileSetUsage")

    # Let's give a 1000mm long beam body representation.
    body = ifcopenshell.api.geometry.add_profile_representation(
        context=body_context, profile=hea100, depth=1000)
    ifcopenshell.api.geometry.assign_representation(model, product=beam, representation=body)
    ifcopenshell.api.geometry.edit_object_placement(model, product=beam)

    # Let's change the cardinal point to be the top center of the axis
    # line. This is represented by the number "8". Consult the IFC
    # documentation for all the numbers you can use.
    ifcopenshell.api.material.edit_profile_usage(model,
        usage=rel.RelatingMaterial, attributes={"CardinalPoint": 8})

#### remove_constituent
Removes a constituent from a constituent set

Note that it is invalid to have zero items in a set, so you should leave
at least one constituent to ensure a valid IFC dataset.

:param constituent: The IfcMaterialConstituent entity you want to remove
:param should_remove_material: If true, materials with no users will be removed

Example:

.. code:: python

    # Create a material set for windows made out of aluminium and glass.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="Window", set_type="IfcMaterialConstituentSet")

    aluminium = ifcopenshell.api.material.add_material(model, name="AL01", category="aluminium")
    glass = ifcopenshell.api.material.add_material(model, name="GLZ01", category="glass")

    # Now let's use those materials as two constituents in our set.
    framing = ifcopenshell.api.material.add_constituent(model,
        constituent_set=material_set, material=aluminium)
    glazing = ifcopenshell.api.material.add_constituent(model,
        constituent_set=material_set, material=glass)

    # Let's remove the glass constituent. Note that we should not remove
    # the framing, at this would mean there are no constituents which is
    # invalid.
    ifcopenshell.api.material.remove_constituent(model, constituent=glazing)

#### remove_layer
Removes a layer from a layer set

Note that it is invalid to have zero items in a set, so you should leave
at least one layer to ensure a valid IFC dataset.

:param layer: The IfcMaterialLayer entity you want to remove
:param should_remove_material: If true, materials with no users will be removed

Example:

.. code:: python

    # Create a material set for steel stud partition walls.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="Window", set_type="IfcMaterialConstituentSet")

    gypsum = ifcopenshell.api.material.add_material(model, name="PB01", category="gypsum")
    steel = ifcopenshell.api.material.add_material(model, name="ST01", category="steel")

    # Now let's use those materials as three layers in our set, such
    # that the steel studs are sandwiched by the gypsum. Let's imagine
    # we're setting the layer thickness in millimeters.
    layer1 = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=gypsum)
    ifcopenshell.api.material.edit_layer(model, layer=layer1, attributes={"LayerThickness": 13})
    layer2 = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=steel)
    ifcopenshell.api.material.edit_layer(model, layer=layer2, attributes={"LayerThickness": 92})
    layer3 = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=gypsum)
    ifcopenshell.api.material.edit_layer(model, layer=layer3, attributes={"LayerThickness": 13})

    # Let's remove the last layer, such that the wall might be clad only
    # one one side such as to line a services riser.
    ifcopenshell.api.material.remove_layer(model, layer=layer3)

#### remove_list_item
Removes an item in an material list

Note that it is invalid to have zero items in a list, so you should leave
at least one item to ensure a valid IFC dataset.

:param material_list: The IfcMaterialList entity you want to remove an
    item from.
:param material_index: The index of the material you want to remove from
    the list. Starts counting at 0. Defaults to 0.
:return: None

Example:

.. code:: python

    # Create a material list for aluminium windows.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="Window", set_type="IfcMaterialMaterialList")

    aluminium = ifcopenshell.api.material.add_material(model, name="AL01", category="aluminium")
    glass = ifcopenshell.api.material.add_material(model, name="GLZ01", category="glass")

    # Now let's use those materials as two items in our list.
    ifcopenshell.api.material.add_list_item(model, material_list=material_set, material=aluminium)
    ifcopenshell.api.material.add_list_item(model, material_list=material_set, material=glass)

    # Let's remove the glass
    ifcopenshell.api.material.remove_list_item(model, material_list=material_set, material_index=1)

#### remove_material
Removes a material

If the material is used in a material set, the corresponding layer,
profile, or constituent is also removed. Note that this may result in a
material set with zero items in it, which is invalid, so the user must
take care of this situation themselves.

:param material: The IfcMaterial entity you want to remove
:return: None

Example:

.. code:: python

    # Create a material
    aluminium = ifcopenshell.api.material.add_material(model, name="AL01", category="aluminium")

    # ... and remove it
    ifcopenshell.api.material.remove_material(model, material=aluminium)

#### remove_material_set
Removes a material set

All set items, such as layers, profiles, or constituents will also be
removed. All set usages are also removed.

However, the materials and profile curves used by the layers,
profiles and constituents will not be removed.

:param material: The IfcMaterialLayerSet, IfcMaterialConstituentSet,
    IfcMaterialProfileSet entity you want to remove.
:return: None

Example:

.. code:: python

    # Create a material set
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="GYP-ST-GYP", set_type="IfcMaterialLayerSet")

    # Create some materials
    gypsum = ifcopenshell.api.material.add_material(model, name="PB01", category="gypsum")
    steel = ifcopenshell.api.material.add_material(model, name="ST01", category="steel")

    # Add some layers
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=gypsum)
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=steel)
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=gypsum)

    # Completely delete the set and all layers. The gypsum and steel
    # material still exist, though.
    ifcopenshell.api.material.remove_material_set(model, material=material_set)

#### remove_profile
Removes a profile item from a profile set

Note that it is invalid to have zero items in a set, so you should leave
at least one profile to ensure a valid IFC dataset.

:param profile: The IfcMaterialProfile entity you want to remove
:param should_remove_profile_def: If true, profile defs with no users will be removed
:param should_remove_material: If true, materials with no users will be removed

Example:

.. code:: python

    # First, let's create a material set.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="B1", set_type="IfcMaterialProfileSet")

    # Create a steel material.
    steel = ifcopenshell.api.material.add_material(model, name="ST01", category="steel")

    # Create an I-beam profile curve. Notice how we name our profiles
    # based on standardised steel profile names.
    hea100 = file.create_entity(
        "IfcIShapeProfileDef", ProfileName="HEA100", ProfileType="AREA",
        OverallWidth=100, OverallDepth=96, WebThickness=5, FlangeThickness=8, FilletRadius=12,
    )

    # Define that steel material and cross section as a single profile item.
    ifcopenshell.api.material.add_profile(model,
        profile_set=material_set, material=steel, profile=hea100)

    # Imagine a welded square along the length of the profile.
    welded_square = ifcopenshell.api.profile.add_arbitrary_profile(model,
        profile=[(.0025, .0025), (.0325, .0025), (.0325, -.0025), (.0025, -.0025), (.0025, .0025)])
    weld_profile = ifcopenshell.api.material.add_profile(model,
        profile_set=material_set, material=steel, profile=welded_square)

    # Let's remove our welded square.
    ifcopenshell.api.material.remove_profile(model, profile=weld_profile)

#### reorder_set_item
Reorders an item in a material set

In some material sets, the order have meaning, like in a layer set. In
other cases, it is purely for human convenience.

:param material_set: The IfcMaterialSet which you want to reorder an
    item in.
:param old_index: The index of the item you want to move. This starts
    counting from 0.
:param new_index: The index of the new position the item will move to.
    This starts counting from 0.
:return: None

Example:

.. code:: python

    material_set = ifcopenshell.api.material.add_material_set(model,
        name="Window", set_type="IfcMaterialList")

    aluminium = ifcopenshell.api.material.add_material(model, name="AL01", category="aluminium")
    glass = ifcopenshell.api.material.add_material(model, name="GLZ01", category="glass")

    # Now let's use those materials as two items in our list.
    ifcopenshell.api.material.add_list_item(model, material_list=material_set, material=aluminium)
    ifcopenshell.api.material.add_list_item(model, material_list=material_set, material=glass)

    # Switch the order around, this has no meaning for a list, so this
    # is just for fun.
    ifcopenshell.api.material.reorder_set_item(model,
        material_set=material_set, old_index=0, new_index=1)

#### set_shape_aspect_constituents
Assigns a material constituent set and sets styles based on shape aspects

An IFC element may be assigned to a set of material constituents. For
example, a window may have a framing material and a glazing material. Each
constituent may have a name, such as "Framing" (which may be assigned to an
"Aluminium" material), and "Glazing" (assigned to a "Laminated Low-e Glass"
material).

An IFC element's geometry may be composed of multiple geometric items.
These geometric items may have names, known as "Shape Aspects".  For
example a solid extrusion for the framing named "Framing" and a solid
extrusion for the glass panel named "Glazing".

A material may be associated with a style (i.e. colour). For example, a
grey style for the "Aluminium" material and a transparent blue style for
the "Laminated Low-e Glass" material.

These three concepts of material constituents, shape aspects, and
associated styles are correlated. For example, if the name (e.g. "Framing")
of a material constituent and a shape aspect correlate, that means that the
geometric item inherits the style (i.e. grey).

This function lets you specify named material constituents, and it'll
create a constituent set assigned to the element with those names. It'll
then find any geometric representation items with shape aspects matching
those names, and assign the correlating style.

If an assigned material constituent set already exists matching those
values, it will be reused. If the values do not match, the existing
material constituent set will be removed if it is not used by anything
else.

:param element: The IfcProduct or IfcTypeProduct
:param context: The IfcGeometricRepresentationContext, typically the body
    context. You can get this via
    :func:`ifcopenshell.util.representation.get_context`.
:param materials: The key is the name of the constituent, and the value is
    the IfcMaterial.

Example:

.. code:: python

    # Create two materials
    aluminium = ifcopenshell.api.material.add_material(model, name="AL01", category="aluminium")
    glass = ifcopenshell.api.material.add_material(model, name="GLZ01", category="glass")

    # Auto assign material constituents and styles to items based on shape aspects
    ifcopenshell.api.material.set_shape_aspect_constituents(
        model, element=window, context=body, materials={
            "Framing": aluminium
            "Lining": aluminium
            "Glazing": glass
        })

#### unassign_material
Removes any material relationship with the list of products

A product can only have one material assigned to it, which is why it is
not necessary to specify the material to unassign. The material is not
removed, only the relationship is removed.

If the product does not have a material, nothing happens.

Unassigning a LayerSet or ProfileSet from the product type will also
remove all Usages of the set.

:param products: The list IfcProducts that may or may not have a material
:return: None

Example:

.. code:: python

    concrete = ifcopenshell.api.material.add_material(model, name="CON01", category="concrete")

    # Let's imagine a concrete bench made out of concrete.
    bench_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcFurnitureType")
    ifcopenshell.api.material.assign_material(model,
        products=[bench_type], type="IfcMaterial", material=concrete)

    # Let's change our mind and remove the concrete assignment. The
    # concrete material still exists, but the bench is no longer made
    # out of concrete now.
    ifcopenshell.api.material.unassign_material(model, products=[bench_type])

## Module: nest

### Description
Nesting is when a component is attached to a host element

Examples include when a faucet is attached using a predrilled hole in a basin,
or when a modular connection occurs through a connection point. This implies
that when a host element moves, the child nested components must move as well.

Note that this API is not meant to be used for connection points on
distribution systems. For that purpose, such as for pipe fittings and
equipment, please see :mod:`ifcopenshell.api.system`.

### Available Functions
- assign_object
- change_nest
- reorder_nesting
- unassign_object

### Function Docstrings
#### assign_object
Assigns objects as nested children to a parent host

All physical IFC model elements must be part of a hierarchical tree
called the "spatial decomposition", where large things are made up of
smaller things. This tree always begins at an "IfcProject" and is then
broken down using "decomposition" relationships, of which aggregation is
the first relationship you will use.

Another type of "decomposition" relationship is known as "nesting".
Nesting is used when an child object is physically attached to a parent
host object, through a physical predetermined connection point. The
child object must be specifically designed to attach to a other objects
at specific positions with a particular form factor. Examples include
faucets which must always be attached through a predrilled hole in a
basin. Alternatively, it could be a modular attachment with a
correlating male and female joint that must join at a particular point.
Because there is a strict connection point, when the parent moves, all
nested children must move with the parent. Another example might be a
predrilled hole in a door panel where hardware must fit through.

Nesting relationships are not very commonly used in most design and
construction models. Its main usecase is in modular construction, kit of
parts, or fabrication models.

As a product may only have a single location in the "spatial
decomposition" tree, assigning an nesting relationship will remove any
previous aggregation, containment, or nesting relationships it may have.

IFC placements follow a convention where the placement is relative to
its parent in the spatial hierarchy. If your product has a placement,
its placement will be recalculated to follow this convention.

For physical connections which are part of a distribution system, such
as a plug connecting into a GPO, or a duct connecting to an AHU, or two
pipe segments connecting with a bend, tee, or wye fitting, you should
not nest the two objects directly. Instead, you should nest a connection
port, which determines the type of compatible distribution flow that can
be connected to it. To do this, do not use this function, but instead
use the more specific functions in the ifcopenshell.api.system module.

Note that nesting relationships may also be used by non-physical
elements, such as cost items or tasks. In this context, nesting means
that there is an implied order to the child cost items or tasks (i.e.
task 1 should be shown before task 2). It is not necessary to use this
function for nesting non-physical elements. Instead, it is recommended
to instead just use the relevant API functions, like
ifcopenshell.api.cost.add_cost_item or
ifcopenshell.api.sequence.add_task.

:param related_objects: The list of children of the nesting relationship,
    typically IfcElements.
:param relating_object: The host parent of the nesting relationship,
    typically an IfcElement.
:return: The IfcRelNests relationship instance
    or `None` if `related_objects` was empty list.

Example:

.. code:: python

    # Faucets are designed to attach onto a sink through a predrilled hole.
    sink = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcSanitaryTerminal", predefined_type="SINK")
    faucet = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcValve", predefined_type="FAUCET")
    ifcopenshell.api.nest.assign_object(model, related_objects=[faucet], relating_object=sink)

#### change_nest
Assigns a cost item to a new parent cost item

#### reorder_nesting
Reorders an item in a nesting set

#### unassign_object
Unassigns related_objects from their nests.

An object (the whole within a decomposition) is Nested by zero or one more smaller objects.
This function will remove this nesting relationship.

If the object is not part of a nesting relationship, nothing will happen.

:param related_objects: The list of children of the nesting relationship,
    typically IfcElements.
:return: None

Example:

.. code:: python

    task = ifcopenshell.api.root.create_entity(model, ifc_class="IfcTasks")
    subtask1 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcTask")
    subtask2 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcTask")
    ifcopenshell.api.nest.assign_object(model, related_objects=[subtask1], relating_object=task)
    ifcopenshell.api.nest.assign_object(model, related_objects=[subtask2], relating_object=task)
    # nothing is returned
    rel = ifcopenshell.api.nest.unassign_object(model, related_objects=[subtask1])
    # nothing is returned, relationship is removed
    ifcopenshell.api.nest.unassign_object(model, related_objects=[subtask2])

## Module: owner

### Description
An element may have an owner, indicating who is responsible, liable, or
contactable regarding that element

Note that in IFC2X3, element ownership is mandatory and must be addressed prior
to the creation of any element at all. See :func:`create_owner_history` for
examples.

### Available Functions
- add_actor
- add_address
- add_application
- add_organisation
- add_person
- add_person_and_organisation
- add_role
- assign_actor
- create_owner_history
- edit_actor
- edit_address
- edit_application
- edit_organisation
- edit_person
- edit_role
- remove_actor
- remove_address
- remove_application
- remove_organisation
- remove_person
- remove_person_and_organisation
- remove_role
- unassign_actor
- update_owner_history

### Function Docstrings
#### add_actor
Adds a new actor

An actor is a person or an organisation who has a responsibility or role
to play in a project. Actor roles include design consultants,
architects, engineers, cost planners, suppliers, manufacturers,
warrantors, owners, subcontractors, etc.

Actors may either be project actors, who are responsible for the
delivery of the project, or occupants, who are responsible for the
consumption of the project.

Identifying and managing actors is critical for asset management, and
identifying liability for legal submissions.

:param actor: Most commonly, an IfcOrganization (in compliance with GDPR
    requirements for non personally identifiable information), or an
    IfcPerson if it is a sole individual, or an IfcPersonAndOrganization
    if a specific person is liable within an organisation and must be
    legally nominated.
:param ifc_class: Either "IfcActor" or "IfcOccupant".
:return: The newly created IfcActor or IfcOccupant

Example:

.. code:: python

    # Setup an organisation with a single role
    organisation = ifcopenshell.api.owner.add_organisation(model,
        identification="AWB", name="Architects Without Ballpens")
    role = ifcopenshell.api.owner.add_role(model, assigned_object=organisation, role="ARCHITECT")

    # Assign that organisation to a newly created actor
    actor = ifcopenshell.api.owner.add_actor(model, actor=organisation)

#### add_address
Add a new telecom or postal address to an organisation or person

A person or organisation may have associated contact details such as
phone numbers, mailing addresses, websites, email addresses, and instant
messaging handles. This information is critical in recording the contact
information of manufacturers and suppliers for facility management, or
liable actors.

There are two types of addresses, postal addresses for physical snail
mail, and telecom addresses for telephone or internet contact numbers
and addresses.

:param assigned_object: The IfcOrganization or IfcPerson the contact
    address belongs to.
:param ifc_class: Either IfcPostalAddress or IfcTelecomAddress. Defaults
    to IfcPostalAddress.
:return: The new IfcPostalAddress or IfcTelecomAddress

Example:

.. code:: python

    organisation = ifcopenshell.api.owner.add_organisation(model)

    # A snail mail address
    postal = ifcopenshell.api.owner.add_address(model,
        assigned_object=organisation, ifc_class="IfcPostalAddress")
    ifcopenshell.api.owner.edit_address(model, address=postal,
        attributes={"Purpose": "OFFICE", "AddressLines": ["42 Wallaby Way"],
        "Town": "Sydney", "Region": "NSW", "PostalCode": "2000"})

    # A phone or internet address
    telecom = ifcopenshell.api.owner.add_address(model,
        assigned_object=organisation, ifc_class="IfcTelecomAddress")
    ifcopenshell.api.owner.edit_address(model, address=telecom,
        attributes={"Purpose": "OFFICE", "TelephoneNumbers": ["+61432466949"],
        "ElectronicMailAddresses": ["bobthebuilder@example.com"],
        "WWWHomePageURL": "https://thinkmoult.com"})

#### add_application
Adds a new application

IFC data may be associated with an authoring application to identify
which application was responsible for editing or authoring the data. An
application is defined by the developing organisation, as well as a full
name and identifier. This is akin to how web browsers have an
identification string.

:param application_developer: The IfcOrganization responsible for
    creating the application. Defaults to generating an IfcOpenShell
    organisation if none is provided.
:param version: The version of the application. Defaults to the
    ifcopenshell.version data if not specified.
:param application_full_name: The name of the application
:param application_identifier: An identification string for the
    application intended for computers to read.
:return: The newly created IfcApplication

Example:

.. code:: python

    application = ifcopenshell.api.owner.add_application(model)

#### add_organisation
Adds a new organisation

Organisations are the main way to identify manufacturers, suppliers, and
other actors who do not have a single representative or must not have
any personally identifiable information.

:param identification: The short code identifying the organisation.
    Sometimes used in drawing naming schemes. Otherise used as a
    canonicalised way of computers to identify the organisation. Like
    their stock name.
:param name: The legal name of the organisation
:return: The newly created IfcOrganization

Example:

.. code:: python

    organisation = ifcopenshell.api.owner.add_organisation(model,
        identification="AWB", name="Architects Without Ballpens")

#### add_person
Adds a new person

Persons are used to identify a legal or liable representative of an
organisation or point of contact.

:param identification: The computer readable unique identification of
    the person. For example, their username in a CDE or alias.
:param family_name: The family name
:param given_name: The given name
:return: The newly created IfcPerson

Example:

.. code:: python

    ifcopenshell.api.owner.add_person(model,
        identification="bobthebuilder", family_name="Thebuilder", given_name="Bob")

#### add_person_and_organisation
Adds a paired person and organisation

A person and an organisation may be paired to create a representative
belonging to a company.

:param person: The IfcPerson being the representative of the
    organisation.
:param organisation: The IfcOrganization it
:return: The newly created IfcPersonAndOrganization

Example:

.. code:: python

    person = ifcopenshell.api.owner.add_person(model,
        identification="lecorbycorbycorb", family_name="Curbosiar", given_name="Le")
    organisation = ifcopenshell.api.owner.add_organisation(model,
        identification="AWB", name="Architects Without Ballpens")

    ifcopenshell.api.owner.add_person_and_organisation(model,
        person=person, organisation=organisation)

#### add_role
Adds and assigns a new role

People and organisations must play one or more roles on a project. Roles
include architects, engineers, subcontractors, clients, manufacturers,
etc. Typically these roles and their corresponding responsibilities will
be outlined in contractual documents.

This function will both add and assign the role to the person or
organisation.

:param assigned_object: The IfcPerson or IfcOrganization the role should
    be assigned to.
:param role: The type of role, taken from the IFC documentation for
    IfcActorRole, or a custom name. Defaults to "ARCHITECT".
:return: The newly created IfcActorRole

Example:

.. code:: python

    organisation = ifcopenshell.api.owner.add_organisation(model,
        identification="AWB", name="Architects Without Ballpens")
    ifcopenshell.api.owner.add_role(model, assigned_object=organisation, role="ARCHITECT")

#### assign_actor
Assigns an actor to an object

An actor may be assigned to objects which implies that the actor is
responsible for. This is most commonly used in facility management for
indicating the manufacturers, suppliers, and warrantors for product
types.

Here are a list of objects you may assign an actor to:

* IfcControl: Indicates project directives issued by the actor.
* IfcGroup: Indicates groups for which the actor is responsible.
* IfcProduct: Indicates products for which the actor is responsible.
* IfcProcess: Indicates processes for which the actor is responsible.
* IfcResource: Indicates resources for which the actor is responsible to
    allocate, manage, or delegate. This is not the actor actually using
    the resource or performing the work. For that type of actor, see
    ifcopenshell.api.resource.assign_resource.

:param relating_actor: The IfcActor who is responsible for the object.
:param related_object: The object the actor is responsible for.
:return: The newly created IfcRelAssignsToActor relationship.

Example:

.. code:: python

    # We need to procure and install 2 of this particular pump type in our facility.
    pump_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcPumpType")

    # Define who the manufacturer is
    manufacturer = ifcopenshell.api.owner.add_organisation(model,
        identification="PWP", name="Pumps With Power")
    ifcopenshell.api.owner.add_role(model, assigned_object=manufacturer, role="MANUFACTURER")

    # To help our facility manager, it's nice to provide contact details
    # of the manufacturer so they know how to call when the pump breaks.
    telecom = ifcopenshell.api.owner.add_address(model,
        assigned_object=organisation, ifc_class="IfcTelecomAddress")
    ifcopenshell.api.owner.edit_address(model, address=telecom,
        attributes={"Purpose": "OFFICE", "TelephoneNumbers": ["+61432466949"],
        "ElectronicMailAddresses": ["contact@example.com"],
        "WWWHomePageURL": "https://example.com"})

    # Make the manufacturer responsible for that pump type.
    ifcopenshell.api.owner.assign_actor(model,
        relating_actor=manufacturer, related_object=pump_type)

#### create_owner_history
Creates a new owner history indicating an element was added

Any object in IFC with a unique ID and name (such as physical products,
tasks, calendars, etc) may have an owner associated with it. An owner is
a liable person and/or organisation which a bit of metadata indicating
whether they have created the object, edited the object, when the change
was made, and which application they used.

IFC does not offer a comprehensive specification for version control and
change tracking, as this is completely out of scope. However this
similar ability allows IFC to satisfy legal requirements where object
ownership, responsibilities, and permissions must be specified.
Recording the owner is mandatory in IFC2X3 but optional in IFC4. It is
not recommended to store this ownership data in IFC4 unless a legal
requirement is in place.

Because owner tracking is mandatory in IFC2X3, be aware that some
configuration may be required to work correctly. Read on.

To track the owner, at a minimum we have to know the application that
the element was authored from, as well as the user (person and
organisation) that made the change. The IfcOpenShell API is a low level
software library and will not know what application the API is being
called from, and nor does it have the responsibility to manage the
"active user" making edits, which may be as simple as hardcoding it to
"Bob" or even be as complex as integration with a CDE's authentication
system. As a result, the developer responsible to integrate with
IfcOpenShell is expected to overload the
ifcopenshell.api.owner.settings.get_user and
ifcopenshell.api.owner.settings.get_application functions.

It is not necessary to call this function directly if you are already
using other API calls. It is a low level function only available if you
are writing your own advanced scripts and want to take advantage of the
easier ownership tracking.

:return: The newly created IfcOwnerHistory element or `None` if it's
    not IFC2X3 and user or application is not found in the current project.

Example:

.. code:: python

    # Let's imagine we're writing a small script, not large enough to be
    # its own fully branded application. In this case, let's use the
    # default application which is prepopulated with "IfcOpenShell" as
    # the name and version.
    application = ifcopenshell.api.owner.add_application(model)

    # Let's imagine we run this as an automated QA process in an
    # architectural firm. However, the results must be signed off by the
    # registered architect who is liable for the project.
    person = ifcopenshell.api.owner.add_person(model,
        identification="LPARTEE", family_name="Partee", given_name="Leeable")
    organisation = ifcopenshell.api.owner.add_organisation(model,
        identification="AWB", name="Architects Without Ballpens")
    user = ifcopenshell.api.owner.add_person_and_organisation(model,
        person=person, organisation=organisation)

    # Let's configure our owner settings to hardcode always returning
    # the application and user. In theory, you could build complex user
    # access control lookup functions here, but this is simple enough.
    ifcopenshell.api.owner.settings.get_user = lambda x: user
    ifcopenshell.api.owner.settings.get_application = lambda x: application

    # We've finished our ownership setup. Now let's start our script and
    # create a space. Notice we don't actually call
    # create_owner_history at all. This is already automatically handled
    # by the API when necessary. Under the hood, the API is actually
    # running this code on the IfcSpace element:
    # element.OwnerHistory = ifcopenshell.api.owner.create_owner_history(model)
    space = ifcopenshell.api.root.create_entity(model, ifc_class="IfcSpace")

#### edit_actor
Edits the attributes of an IfcActor

For more information about the attributes and data types of an
IfcActor, consult the IFC documentation.

:param actor: The IfcActor entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Setup an organisation with a single role
    organisation = ifcopenshell.api.owner.add_organisation(model,
        identification="AWB", name="Architects Without Ballpens")
    role = ifcopenshell.api.owner.add_role(model, assigned_object=organisation)
    ifcopenshell.api.owner.edit_role(model, role=role, attributes={"Role": "ARCHITECT"})

    # Assign that organisation to a newly created actor
    actor = ifcopenshell.api.owner.add_actor(model, actor=organisation)

    # Edit the description of the attribute.
    ifcopenshell.api.actor.edit_actor(model,
        actor=actor, attributes={"Description": "Responsible for buildings A, B, and C."})

#### edit_address
Edits the attributes of an IfcAddress

For more information about the attributes and data types of an
IfcAddress, consult the IFC documentation.

:param address: The IfcAddress entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # A snail mail address
    postal = ifcopenshell.api.owner.add_address(model,
        assigned_object=organisation, ifc_class="IfcPostalAddress")
    ifcopenshell.api.owner.edit_address(model, address=postal,
        attributes={"Purpose": "OFFICE", "AddressLines": ["42 Wallaby Way"],
        "Town": "Sydney", "Region": "NSW", "PostalCode": "2000"})

    # A phone or internet address
    telecom = ifcopenshell.api.owner.add_address(model,
        assigned_object=organisation, ifc_class="IfcTelecomAddress")
    ifcopenshell.api.owner.edit_address(model, address=telecom,
        attributes={"Purpose": "OFFICE", "TelephoneNumbers": ["+61432466949"],
        "ElectronicMailAddresses": ["bobthebuilder@example.com"],
        "WWWHomePageURL": "https://thinkmoult.com"})

#### edit_application
Edits the attributes of an IfcApplication

For more information about the attributes and data types of an
IfcApplication, consult the IFC documentation.

:param application: The IfcApplication entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    application = ifcopenshell.api.owner.add_application(model,
        application_full_name="My App")
    ifcopenshell.api.owner.edit_application(model, application=application,
        attributes={"ApplicationFullName": "My App New Name"})

#### edit_organisation
Edits the attributes of an IfcOrganization

For more information about the attributes and data types of an
IfcOrganization, consult the IFC documentation.

:param organisation: The IfcOrganization entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    organisation = ifcopenshell.api.owner.add_organisation(model,
        identification="AWB", name="Architects With Ballpens")
    ifcopenshell.api.owner.edit_organisation(model, organisation=organisation,
        attributes={"name": "Architects Without Ballpens"})

#### edit_person
Edits the attributes of an IfcPerson

For more information about the attributes and data types of an
IfcPerson, consult the IFC documentation.

:param person: The IfcPerson entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    person = ifcopenshell.api.owner.add_person(model,
        identification="bobthebuilder", family_name="Thebuilder", given_name="Bob")
    ifcopenshell.api.owner.edit_person(model, person=person,
        attributes={"MiddleNames": ["The"], "FamilyName": "Builder"})

#### edit_role
Edits the attributes of an IfcActorRole

For more information about the attributes and data types of an
IfcActorRole, consult the IFC documentation.

:param role: The IfcActorRole entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    person = ifcopenshell.api.owner.add_person(model,
        identification="bobthebuilder", family_name="Thebuilder", given_name="Bob")

    # By default, the role is an architect
    role = ifcopenshell.api.owner.add_role(model, assigned_object=person)

    # But Bob is not an architect
    ifcopenshell.api.owner.edit_role(model, role=role, attributes={"Role": "CONSTRUCTIONMANAGER"})

#### remove_actor
Removes an actor

:param actor: The IfcActor to remove.
:return: None

Example:

.. code:: python

    # Setup an organisation with a single role
    organisation = ifcopenshell.api.owner.add_organisation(model,
        identification="AWB", name="Architects Without Ballpens")
    role = ifcopenshell.api.owner.add_role(model, assigned_object=organisation)
    ifcopenshell.api.owner.edit_role(model, role=role, attributes={"Role": "ARCHITECT"})

    # Assign that organisation to a newly created actor
    actor = ifcopenshell.api.owner.add_actor(model, actor=organisation)

    # Actually we need ballpens on this project
    ifcopenshell.api.owner.remove_actor(model, actor=actor)

#### remove_address
Removes an address

Naturally, any organisations or people using that address will have the
relationship removed.

:param address: The IfcAddress to remove.
:return: None

Example:

.. code:: python

    organisation = ifcopenshell.api.owner.add_organisation(model)
    address = ifcopenshell.api.owner.add_address(model,
        assigned_object=organisation, ifc_class="IfcPostalAddress")

    # Change our mind and delete it
    ifcopenshell.api.owner.remove_address(model, address=address)

#### remove_application
Removes an application

Warning: removing an application may invalidate ownership histories.
Check whether or not the application is used anywhere prior to removal.

:param address: The IfcApplication to remove.
:return: None

Example:

.. code:: python

    application = ifcopenshell.api.owner.add_application(model)
    ifcopenshell.api.owner.remove_address(model, application=application)

#### remove_organisation
Remove an organisation

All roles and addresses assigned to the organisation will also be
removed.

:param organisation: The IfcOrganization to remove
:return: None

Example:

.. code:: python

    organisation = ifcopenshell.api.owner.add_organisation(model,
        identification="AWB", name="Architects Without Ballpens")
    ifcopenshell.api.owner.remove_organisation(model, organisation=organisation)

#### remove_person
Remove an person

All roles and addresses assigned to the person will also be
removed.
In IFC2X3 will also remove related inventories if `person` was
the only responsile person for them.

:param person: The IfcPerson to remove
:return: None

Example:

.. code:: python

    ifcopenshell.api.owner.add_person(model,
        identification="bobthebuilder", family_name="Thebuilder", given_name="Bob")
    ifcopenshell.api.owner.remove_person(model, person=person)

#### remove_person_and_organisation
Removes a person and organisation

Note that the underlying person and organisation is not removed, only
the "person and organisation" group.

:param person_and_organisation: The IfcPersonAndOrganization to remove.
:return: None

Example:

.. code:: python

    person = ifcopenshell.api.owner.add_person(model,
        identification="lecorbycorbycorb", family_name="Curbosiar", given_name="Le")
    organisation = ifcopenshell.api.owner.add_organisation(model,
        identification="AWB", name="Architects Without Ballpens")

    user = ifcopenshell.api.owner.add_person_and_organisation(model,
        person=person, organisation=organisation)

    ifcopenshell.api.owner.remove_person_and_organisation(model, person_and_organisation=user)

#### remove_role
Removes a role

People and organisations using the role will be untouched. This may
leave some of them without roles.

:param role: The IfcActorRole to remove.
:return: None

Example:

.. code:: python

    organisation = ifcopenshell.api.owner.add_organisation(model,
        identification="AWB", name="Architects Without Ballpens")
    role = ifcopenshell.api.owner.add_role(model, assigned_object=organisation, role="ARCHITECT")

    # After running this, the organisation will have no role again
    ifcopenshell.api.owner.remove_role(model, role=role)

#### unassign_actor
Unassigns an actor to an object

This means that the actor is no longer responsible for the object.

:param relating_actor: The IfcActor who is responsible for the object.
:param related_object: The object the actor is responsible for.
:return: None

Example:

.. code:: python

    # We need to procure and install 2 of this particular pump type in our facility.
    pump_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcPumpType")

    # Define who the manufacturer is
    manufacturer = ifcopenshell.api.owner.add_organisation(model,
        identification="PWP", name="Pumps With Power")
    ifcopenshell.api.owner.add_role(model, assigned_object=manufacturer, role="MANUFACTURER")

    # Make the manufacturer responsible for that pump type.
    ifcopenshell.api.owner.assign_actor(model,
        relating_actor=manufacturer, related_object=pump_type)

    # Undo the assignment
    ifcopenshell.api.owner.unassign_actor(model,
        relating_actor=manufacturer, related_object=pump_type)

#### update_owner_history
Updates the owner that is assigned to an object

This ensures that the owner is tracked to have modified the object last,
including the time when the change occured. See
ifcopenshell.api.owner.create_owner_history for details.

:param element: The IfcRoot element to update the ownership details on
    when a change is made.
:return: The updated IfcOwnerHistory element.

Example:

.. code:: python

    # See ifcopenshell.api.owner.create_owner_history for setup
    # [ ... example setup code ... ]

    # We've finished our ownership setup. Now let's start our script and
    # create a space. Notice we don't actually call
    # create_owner_history at all. This is already automatically handled
    # by the API when necessary. Under the hood, the API is actually
    # running this code on the IfcSpace element:
    # element.OwnerHistory = ifcopenshell.api.owner.create_owner_history(model)
    space = ifcopenshell.api.root.create_entity(model, ifc_class="IfcSpace")

    # Any edits we make will have ownership tracking automatically
    # applied. There is no need to run any owner.update_owner_history
    # API calls either.
    ifcopenshell.api.attribute.edit_attributes(model, product=space, attributes={"Name": "Lobby"})

## Module: profile

### Description
Handles the definition of cross sectional profiles

Maintaining a clean profile library is important for structural simulations and
identification of standardised profiles for fabrication and carbon counting.

### Available Functions
- add_arbitrary_profile
- add_arbitrary_profile_with_voids
- add_parameterized_profile
- copy_profile
- edit_profile
- remove_profile

### Function Docstrings
#### add_arbitrary_profile
Adds a new arbitrary polyline-based profile

The profile is represented as a polyline defined by a list of
coordinates. Only straight segments are allowed. Coordinates must be
provided in SI meters.

To represent a closed curve, the first and last coordinate must be
identical.

:param profile: A list of coordinates
:param name: If the profile is semantically significant (i.e. to be
    managed and reused by the user) then it must be named. Otherwise,
    this may be left as none.
:return: The newly created IfcArbitraryClosedProfileDef

Example:

.. code:: python

    # A 10mm by 100mm rectangle, such that might be used as a wooden
    # skirting board or kick plate.
    square = ifcopenshell.api.profile.add_arbitrary_profile(model,
        profile=[(0., 0.), (.01, 0.), (.01, .1), (0., .1), (0., 0.)],
        name="SK01 Profile")

#### add_arbitrary_profile_with_voids
Adds a new arbitrary polyline-based profile with voids

The outer profile is represented as a polyline defined by a list of
coordinates. Only straight segments are allowed. Coordinates must be
provided in SI meters.

To represent a closed curve, the first and last coordinate must be
identical.

The inner profiles are represented as a list of polylines.
Every polyline in defined by a list of coordinates.
Only straight segments are allowed. Coordinates must be
provided in SI meters.

:param outer_profile: A list of coordinates
:param inner_profiles: A list of polylines
:param name: If the profile is semantically significant (i.e. to be
    managed and reused by the user) then it must be named. Otherwise,
    this may be left as none.
:return: The newly created IfcArbitraryProfileDefWithVoids

Example:

.. code:: python

    # A 400mm by 400mm square with a 200mm by 200mm hole in it.
    square_with_hole = ifcopenshell.api.profile.add_arbitrary_profile_with_voids(model,
        outer_profile=[(0., 0.), (.4, 0.), (.4, .4), (0., .4), (0., 0.)],
        inner_profiles=[[(0.1, 0.1), (0.3, 0.1), (0.3, 0.3), (0.1, 0.3), (0.1, 0.1)]],
        name="SK01 Hole Profile")

#### add_parameterized_profile
Adds a new parameterised profile

IFC offers parameterised profiles for common standardised hot roll
steel sections and common concrete forms. A full list is available on
the IFC documentation as subclasses of IfcParameterizedProfileDef.

Currently, this API has no benefit over directly calling
ifcopenshell.file.create_entity.

:param ifc_class: The subclass of IfcParameterizedProfileDef that you'd
    like to create.
:param profile_type:
:return: The newly created element depending on the specified ifc_class.

Example:

.. code:: python

    circle = ifcopenshell.api.profile.add_parameterized_profile(model,
        ifc_class="IfcCircleProfileDef")
    circle.Radius = 1.

#### copy_profile
Copies a profile

All profile's psets are copied. The copied profile is not
associated to any elements.

:param profile: The IfcProfileDef to copy
:return: The new copy of the profile

Example:

.. code:: python

    profile = ifcopenshell.api.profile.add_profile(model, ifc_class="IfcRectangleProfileDef")

    # Let's duplicate the rectangle profile
    profile_copy = ifcopenshell.api.profile.copy_profile(model, profile=profile)

#### edit_profile
Edits the attributes of an IfcProfileDef

For more information about the attributes and data types of an
IfcProfileDef, consult the IFC documentation.

:param profile: The IfcProfileDef entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    circle = ifcopenshell.api.profile.add_parameterized_profile(model,
        ifc_class="IfcCircleProfileDef")
    circle = 1.

    ifcopenshell.api.profile.edit_profile(model,
        profile=circle, attributes={"ProfileName": "1000mm Dia"})

#### remove_profile
Removes a profile

:param profile: The IfcProfileDef to remove.

Example:

.. code:: python

    circle = ifcopenshell.api.profile.add_parameterized_profile(model,
        ifc_class="IfcCircleProfileDef")
    circle = 1.
    ifcopenshell.api.profile.remove_profile(model, profile=circle)

## Module: project

### Description
Create an IFC project

All IFCs must have one, and only one IFC project before any data may be
associated. If you are starting from scratch, see :func:create_file.

Once a project exists, you may optionally create project libraries and
associate type assets with it. You may also append assets from other projects
into your project.

### Available Functions
- append_asset
- assign_declaration
- create_file
- unassign_declaration

### Function Docstrings
#### append_asset
Appends an asset from a library into the active project

A BIM library asset may be a type product (e.g. wall type), product
(e.g. pump), material, profile, or cost schedule.

This copies the asset from the specified library file into the active
project. It handles all details like ensuring that product materials,
styles, properties, quantities, and so on are preserved.

If an asset contains geometry, the geometric contexts are also
intelligentely transplanted such that existing equivalent contexts are
reused.

Do not mix units.

:param library: The file object containing the asset.
:param element: An element in the library file of the asset. It may be
    an IfcTypeProduct, IfcProduct, IfcMaterial, IfcCostSchedule, or
    IfcProfileDef.
:param reuse_identities: Optional dictionary of mapped entities' identities to the
    already created elements. It will be used to avoid creating
    duplicated inverse elements during multiple `project.append_asset` calls. If you want
    to add just 1 asset or if added assets won't have any shared elements, then it can be left empty.
:param assume_asset_uniqueness_by_name: If True, checks if elements (profiles, materials, styles)
    with the same name already exist in the project and reuses them instead of appending new ones.
:return: The appended element

Example:

.. code:: python

    # Programmatically generate a library. You could do this visually too.
    library = ifcopenshell.api.project.create_file()
    root = ifcopenshell.api.root.create_entity(library, ifc_class="IfcProject", name="Demo Library")
    context = ifcopenshell.api.root.create_entity(library,
        ifc_class="IfcProjectLibrary", name="Demo Library")
    ifcopenshell.api.project.assign_declaration(library, definitions=[context], relating_context=root)

    # Assign units for our example library
    unit = ifcopenshell.api.unit.add_si_unit(library,
        unit_type="LENGTHUNIT", prefix="MILLI")
    ifcopenshell.api.unit.assign_unit(library, units=[unit])

    # Let's create a single asset of a 200mm thick concrete wall
    wall_type = ifcopenshell.api.root.create_entity(library, ifc_class="IfcWallType", name="WAL01")
    concrete = ifcopenshell.api.material.add_material(usecase.file, name="CON", category="concrete")
    rel = ifcopenshell.api.material.assign_material(library,
        products=[wall_type], type="IfcMaterialLayerSet")
    layer = ifcopenshell.api.material.add_layer(library,
        layer_set=rel.RelatingMaterial, material=concrete)
    layer.Name = "Structure"
    layer.LayerThickness = 200

    # Mark our wall type as a reusable asset in our library.
    ifcopenshell.api.project.assign_declaration(library,
        definitions=[wall_type], relating_context=context)

    # Let's imagine we're starting a new project
    model = ifcopenshell.api.project.create_file()
    project = ifcopenshell.api.root.create_entity(model, ifc_class="IfcProject", name="Test")

    # Now we can easily append our wall type from our library
    wall_type = ifcopenshell.api.project.append_asset(model, library=library, element=wall_type)

Example of adding multiple assets and avoiding duplicated inverses:

.. code:: python

    # since occurrences of IfcWindow of the same type
    # might have shared inverses (e.g. IfcStyledItem)
    # we provide a dictionary that will be populated with newly created items
    # and reused to avoid duplicated elements
    reuse_identities = dict()

    for element in ifcopenshell.util.selector.filter_elements(model, "IfcWindow"):
        ifcopenshell.api.project.append_asset(
            model, library=library,
            element=wall_type
            reuse_identities=reuse_identities
        )

#### assign_declaration
Declares the list of elements to the project

Feature was added in IFC4.

All data in a model must be directly or indirectly related to the
project. Most data is indirectly related, existing instead within the
spatial decomposition tree. Other data, such as types, may be declared
at the top level.

Most of the time, the API handles declaration automatically for you.
There is one scenario where you might want to explicitly declare objects
to the project, and that's when you want to organise objects into
project libraries for future use (such as an assets library). Assigning
a declaration lets you say that an object belongs to a library.

:param definitions: The list of objects you want to declare. Typically a list of assets.
:param relating_context: The IfcProject, or more commonly the
    IfcProjectLibrary that you want the object to be part of.
:return: The new IfcRelDeclares relationship or None if all definitions
    were already declared / do not support declaration.

Example:

.. code:: python

    # Programmatically generate a library. You could do this visually too.
    library = ifcopenshell.api.project.create_file()
    root = ifcopenshell.api.root.create_entity(library, ifc_class="IfcProject", name="Demo Library")
    context = ifcopenshell.api.root.create_entity(library,
        ifc_class="IfcProjectLibrary", name="Demo Library")

    # It's necessary to say our library is part of our project.
    ifcopenshell.api.project.assign_declaration(library, definitions=[context], relating_context=root)

    # Assign units for our example library
    unit = ifcopenshell.api.unit.add_si_unit(library,
        unit_type="LENGTHUNIT", prefix="MILLI")
    ifcopenshell.api.unit.assign_unit(library, units=[unit])

    # Let's create a single asset of a 200mm thick concrete wall
    wall_type = ifcopenshell.api.root.create_entity(library, ifc_class="IfcWallType", name="WAL01")
    concrete = ifcopenshell.api.material.add_material(file, name="CON", category="concrete")
    rel = ifcopenshell.api.material.assign_material(library,
        products=[wall_type], type="IfcMaterialLayerSet")
    layer = ifcopenshell.api.material.add_layer(library,
        layer_set=rel.RelatingMaterial, material=concrete)
    layer.Name = "Structure"
    layer.LayerThickness = 200

    # Mark our wall type as a reusable asset in our library.
    ifcopenshell.api.project.assign_declaration(library,
        definitions=[wall_type], relating_context=context)

    # All done, just for fun let's save our asset library to disk for later use.
    library.write("/path/to/my-library.ifc")

#### create_file
Create a blank IFC model file object

Create a new IFC file object based on the nominated schema version. The
schema version you choose determines what type of IFC data you can store
in this model. The file is blank and contains no entities.

It also sets up header data for STEP file serialisation, such as the
current timestamp, IfcOpenShell as the preprocessor, and defaults to a
DesignTransferView MVD.

:param version: The schema version of the IFC file. Choose from
    "IFC2X3", "IFC4", or "IFC4X3". If you have loaded in a custom
    schema, you may specify that schema identifier here too.
:return: The created IFC file object.

Example:

.. code:: python

    # Start a new model.
    model = ifcopenshell.api.project.create_file()

    # It's currently a blank model, so typically the first thing we do
    # is create a project in it.
    project = ifcopenshell.api.root.create_entity(model, ifc_class="IfcProject", name="Test")

    # ... and off we go!

#### unassign_declaration
Unassigns a list of objects from a project or project library

Typically used to remove an asset from a project library.

:param definitions: The list of objects you want to undeclare.
    Typically a list of assets.
:param relating_context: The IfcProject, or more commonly the
    IfcProjectLibrary that you want the object to no longer be part of.
:return: None

Example:

.. code:: python

    # Programmatically generate a library. You could do this visually too.
    library = ifcopenshell.api.project.create_file()
    root = ifcopenshell.api.root.create_entity(library, ifc_class="IfcProject", name="Demo Library")
    context = ifcopenshell.api.root.create_entity(library,
        ifc_class="IfcProjectLibrary", name="Demo Library")

    # It's necessary to say our library is part of our project.
    ifcopenshell.api.project.assign_declaration(library, definitions=[context], relating_context=root)

    # Remove the library from our project
    ifcopenshell.api.project.unassign_declaration(library, definitions=[context], relating_context=root)

## Module: pset

### Description
Property sets and quantity sets let you store simple key value metadata
associated with elements

This is the simplest and most common way to store information about an element.
For example, if a door has a fire rating, it is stored as a property.

### Available Functions
- add_pset
- add_qto
- assign_pset
- edit_pset
- edit_qto
- remove_pset
- unassign_pset
- unshare_pset

### Function Docstrings
#### add_pset
Adds a new property set to a product

Products, such as physical objects or types in IFC may have properties
associated with them. These properties are typically simple key value
metadata with data types. For example, a wall type may have a property
called FireRating with a text value of "2HR". Properties are grouped
into property sets, so that related properties are grouped together.

If a property is assigned to a type, the property is inherited by all
occurrences of that type. For example, a wall type with a FireRating
property of "2HR" automatically implies that all walls of that wall type
also have a FireRating of "2HR". It is not necessary to explictly define
the property again for each occurrence. This also means that properties
are typically defined on types. If the same property is defined at an
occurrence, this overrides the property defined on the type.

buildingSMART has come up with a long list of standardised properties
for the most common properties required internationally. This solves the
age-old question of "where do I store my FireRating data for walls"? The
answer, in this case, is in the "FireRating" property with an "IfcLabel"
data type grouped in the "Pset_WallCommon" property set. It is
recommended to view the list of standardised buildingSMART properties
and see if any suit your needs first. If none are appropriate, then you
are free to create your own custom properties.

This function adds a blank named property set. One you have a property
set you may add properties using ifcopenshell.api.pset.edit_pset.

See also ifcopenshell.api.pset.add_qto if you want to add quantification
data, rather than arbitrary metadata.

:param product: The IfcObject that you want to assign a property set to.
:param name: The name of the property set. Property sets that are
    standardised by buildingSMART typically have a prefix of "Pset_",
    like "Pset_WallCommon". If you create your own, you must not use
    that prefix. It is recommended to use your own prefix tailored to
    your project, company, or local government requirement.

    In IFC2X3 should be provided as an empty string for profile properties
    (they all don't have a name property) and all material properties
    besides IfcExtendedMaterialProperties.
:param ifc2x3_subclass: IFC2X3 subclass for material or profile properties.
    In IFC2X3 IfcProfileProperties and IfcMaterialProperties are abstract
    so you need one of their subclasses to instantiate them.
    By default, for profile will be created IfcGeneralProfileProperties
    and for material - IfcExtendedMaterialProperties.
    Will have no effect in >=IFC4.

:raises TypeError: If `product` class doesn't support adding a pset.

:return: The newly created IfcPropertySet

Example:

.. code:: python

    # Let's imagine we have a new wall type.
    wall_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWallType")

    # Note that this only creates and assigns an empty property set. We
    # still need to add properties into the property set. Having blank
    # property sets are invalid.
    pset = ifcopenshell.api.pset.add_pset(model, product=wall_type, name="Pset_WallCommon")

    # Add a fire rating property standardised by buildingSMART.
    ifcopenshell.api.pset.edit_pset(model, pset=pset, properties={"FireRating": "2HR"})

#### add_qto
Adds a new quantity set to a product

Products, such as physical objects or types in IFC may have quantities
associated with them. These quantities are typically simple key value
metadata with data types. For example, a wall type may have a quantity
called NetSideArea with a area value of "4.2". Quantities are grouped
into quantity sets, so that related quantities are grouped together.

Quantities are similar to, but different from properties in that they
may store a method of measurement or formula. Quantities may also have
parametric relationships to other calculated values, such as cost
schedules, resource utilisation, or construction task durations.

buildingSMART has come up with a long list of standardised quantities
for the most common quantities required internationally. This solves the
age-old question of "what's the standard way of storing quantity
take-off data"? It is recommended to view the list of standardised
buildingSMART quantities and see if any suit your needs first. If none
are appropriate, then you are free to create your own custom quantities.

This function adds a blank named quantity set. One you have a quantity
set you may add quantities using ifcopenshell.api.pset.edit_qto.

See also ifcopenshell.api.pset.add_qto if you want to arbitrary
metadata, rather than quantification data.

:param product: The IfcObject that you want to assign a quantity set to.
:param name: The name of the quantity set. Quantity sets that are
    standardised by buildingSMART typically have a prefix of "Qto_",
    like "Qto_WallBaseQuantities". If you create your own, you must not
    use that prefix. It is recommended to use your own prefix tailored
    to your project, company, or local government requirement.
:return: The newly created IfcElementQuantity

Example:

.. code:: python

    # Let's imagine we have a new wall.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # Note that this only creates and assigns an empty quantity set. We
    # still need to add quantities into the property set. Having blank
    # quantity sets are invalid.
    qto = ifcopenshell.api.pset.add_qto(model, product=wall_type, name="Qto_WallBaseQuantities")

    # Add a side area property standardised by buildingSMART. This
    # allows quantity take-off to occur, even though no geometry has
    # even been modelled!
    ifcopenshell.api.pset.edit_qto(model, qto=qto, properties={"NetSideArea": 4.2})

#### assign_pset
Assign property set to provided elements.

This method can be used to make psets shared by multiple elements.

:param products: Elements (or element types) to assign the pset to.
:param pset: Property set.
:return: None if `products` is empty or has only type elements.
    IfcRelDefinesByProperties if `products` contains occurrences.

Example:

.. code:: python

    element = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")
    ifcopenshell.api.pset.assign_pset(model, [element], pset)
    # Pset is now assigned.
    assert ifcopenshell.util.element.get_elements_by_pset(pset) == {element}

    element1 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")
    element2 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")
    ifcopenshell.api.pset.assign_pset(model, [element1, element2], pset)
    # Pset is now shared by multiple elements.
    assert ifcopenshell.util.element.get_elements_by_pset(pset) == {element, element1, element2}

    # Same for element types.
    element_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWallType")
    ifcopenshell.api.pset.assign_pset(model, [element_type], type_pset)
    # Pset is now assigned to the type.
    assert ifcopenshell.util.element.get_elements_by_pset(type_pset) == {element_type}

#### edit_pset
Edits a property set and its properties

At its simplest usage, this may be used to edit the name of a property
set. It may also be used to add, edit, or remove properties, either
arbitrarily or using a property set template.

A list of properties are provided as a dictionary, where the keys are
property names, and values are property values. Keys that don't already
exist are interpreted as properties to be added. Keys that already exist
are interpreted as properties to be edited. A "None" value may specify a
property to be deleted.

Properties must have a data type. There are lots of data types in IFCs,
not just simple unitless data types like integers, booleans, text, but
also distinguishing between types of text, like labels versus
descriptive text. There are also lots of unit-based data types like
areas, volumes, lengths, power, density, flow rates, pressure, etc.

To ensure the appropriate data type is used for properties, a property
set template may be used. These can be seen as "property
specifications". A default selection is provided by buildingSMART, so
that all buildingSMART defined standard properties have exactly the same
data types and exactly the right property names without fear of invalid
data or typos. The built-in buildingSMART templates are always loaded.
However, you may also specify your own templates. If you try to add a
non-standard property that does not exist in either your own template or
in the built-in buildingSMART template, then you have the responsibility
to ensure that data types are always consistent and correct.

:param pset: The IfcPropertySet to edit.
:param name: A new name for the property set. If no name is specified,
    the property set name is not changed.
:param properties: A dictionary of properties. The keys must be a string
    of the name of the property. The data type of the value will be
    determined by the property set template. If no property set
    template is found, the data types of the Python values will
    influence the IFC data type of the property. String values will
    become IfcLabel, float values will become IfcReal, booleans will
    become IfcBoolean, and integers will become IfcInteger. If more
    control is desired, you may explicitly specify IFC data objects
    directly. Note that provided `properties` might be mutated in the process.
:param pset_template: If a property set template is provided, this will
    be used to determine data types. If no user-defined template is
    provided, the built-in buildingSMART templates will be loaded.
:param should_purge: If set as False, properties set to None will be
    left as None but not removed. If set to true, properties set to None
    will actually be removed. The default of true is the same behaviour as
    :func:`ifcopenshell.api.pset.edit_qto`.
:return: None

Example:

.. code:: python

    # Let's imagine we have a new wall type.
    wall_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWallType")

    # This is a standard buildingSMART property set.
    pset = ifcopenshell.api.pset.add_pset(model, product=wall_type, name="Pset_WallCommon")

    # In this scenario, we don't specify any pset_template because it is
    # part of the built-in buildingSMART templates, and so the
    # FireRating will automatically be an IfcLabel, and the thermal
    # transmittance value will automatically be an
    # IfcThermalTransmittanceMeasure. Neither of these properties exist
    # yet, so they will be created.
    ifcopenshell.api.pset.edit_pset(model,
        pset=pset, properties={"FireRating": "2HR", "ThermalTransmittance": 42.3})

    # We can edit existing properties. In this case, "FireRating" is
    # edited from "2HR" to "1HR". Combustible is new, and will be added.
    # The existing "ThermalTransmittance" property will be left
    # unchanged.
    ifcopenshell.api.pset.edit_pset(model,
        pset=pset, properties={"FireRating": "1HR", "Combustible": False})

    # Setting to None will change the value but not delete the property.
    ifcopenshell.api.pset.edit_pset(model, pset=pset, properties={"Combustible": None})

    # If you actually want to delete the property, enable purging.
    ifcopenshell.api.pset.edit_pset(model, pset=pset,
        properties={"Combustible": None}, should_purge=True)

    # What if we wanted to manage our own properties? Let's create our
    # own "Company Standard" property set templates. Notice how we
    # prefix our property set with "Foo_", if our company name was "Foo"
    # this would make sense.
    template = ifcopenshell.api.pset_template.add_pset_template(model, name="Foo_bar")

    # Let's imagine we want all model authors to specify two properties,
    # one being a length measurement and another being a boolean.
    prop1 = ifcopenshell.api.pset_template.add_prop_template(model,
        pset_template=template, name="DemoA", primary_measure_type="IfcLengthMeasure")
    prop2 = ifcopenshell.api.pset_template.add_prop_template(model,
        pset_template=template, name="DemoB", primary_measure_type="IfcBoolean")

    # Now we can use our property set template to add our properties,
    # and the data types will always match our template.
    pset = ifcopenshell.api.pset.add_pset(model, product=wall_type, name="Foo_Bar")
    ifcopenshell.api.pset.edit_pset(model,
        pset=pset, properties={"DemoA": 42.3, "DemoB": True}, pset_template=template)

    # Here's a third scenario where we want to add arbitrary properties
    # that are not standardised by anything, not even our own custom
    # templates.
    pset = ifcopenshell.api.pset.add_pset(model, product=wall_type, name="Custom_Pset")
    ifcopenshell.api.pset.edit_pset(model,
        pset=pset, properties={
            # Basic Python data types are mapped to a sensible default
            "SomeLabel": "Foo",
            "SomeNumber": 12.3,
            # But we can always specify exactly what we're after too
            "ExplicitLength": model.createIfcLengthMeasure(42.3)
        })

    # Editing existing properties will retain their current data types
    # if possible. So this will still be a length measure.
    ifcopenshell.api.pset.edit_pset(model, pset=pset, properties={"ExplicitLength": 12.3})

#### edit_qto
Edits a quantity set and its quantities

At its simplest usage, this may be used to edit the name of a quantity
set. It may also be used to add, edit, or remove quantities.

See ifcopenshell.api.pset.edit_pset for documentation on how this is
intended to be used.

One major difference is that quantities set to None are always purged.
It is not allowed to have None quantities in IFC.

:param qto: The IfcElementQuantity or IfcPhysicalComplexQuantity to edit.
:param name: A new name for the quantity set. If no name is specified,
    the quantity set name is not changed.
:param properties: A dictionary of properties. The keys must be a string
    of the name of the quantity. The data type of the value will be
    determined by the quantity set template. If no quantity set
    template is found, the data types of the Python values and
    properties names will influence the IFC data type of the quantity.

    - For `float` values - see `FLOAT_TYPE_KEYWORDS` for the keywords in property name
    used to detect the quantity type. If no keyword matches,
    the default quantity type will be IfcQuantityLength.

    - `int` values will map to IfcQuantityCount.

    - dictionary values will be used to create IfcPhysicalComplexQuantity with
    properties from the dictionary.

    If more control is desired, you may explicitly specify IFC data objects directly.
:param pset_template: If a quantity set template is provided, this will
    be used to determine data types. If no user-defined template is
    provided, the built-in buildingSMART templates will be loaded.
:return: None

Example:

.. code:: python

    # Let's imagine we have a new wall type.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # This is a standard buildingSMART property set.
    qto = ifcopenshell.api.pset.add_qto(model, product=wall, name="Qto_WallBaseQuantities")

    # In this scenario, we don't specify any pset_template because it is
    # part of the built-in buildingSMART templates, and so the Length
    # will automatically be an IfcLengthMeasure, and the NetVolume will
    # automatically be an IfcVolumeMeasure. Neither of these properties
    # exist yet, so they will be created.
    ifcopenshell.api.pset.edit_qto(model, qto=qto, properties={"Length": 12, "NetVolume": 7.2})

    # Setting to None will delete the quantity.
    ifcopenshell.api.pset.edit_qto(model, qto=qto, properties={"Length": None})

    # What if we wanted to manage our own properties? Let's create our
    # own "Company Standard" property set templates. Notice how we
    # prefix our property set with "Foo_", if our company name was "Foo"
    # this would make sense. In this example, we say that our template
    # only applies to walls and is for quantities.
    template = ifcopenshell.api.pset_template.add_pset_template(model,
        name="Foo_Wall", template_type="QTO_OCCURRENCEDRIVEN", applicable_entity="IfcWall")

    # Let's imagine we want all model authors to specify a length
    # measurement for the portion of a wall that is overhanging.
    prop = ifcopenshell.api.pset_template.add_prop_template(model, pset_template=template,
        name="OverhangLength", template_type="Q_LENGTH", primary_measure_type="IfcLengthMeasure")

    # Now we can use our property set template to add our properties,
    # and the data types will always match our template.
    qto = ifcopenshell.api.pset.add_qto(model, product=wall, name="Foo_Wall")
    ifcopenshell.api.pset.edit_qto(model,
        qto=qto, properties={"OverhangLength": 42.3}, pset_template=template)

    # Here's a third scenario where we want to add arbitrary quantities
    # that are not standardised by anything, not even our own custom
    # templates.
    qto = ifcopenshell.api.pset.add_qto(model, product=wall, name="Custom_Qto")
    ifcopenshell.api.pset.edit_qto(model,
        qto=qto, properties={
            "SomeLength": model.createIfcLengthMeasure(42.3),
            "SomeArea": model.createIfcAreaMeasure(21.0)
        })

    # Editing existing quantities will retain their current data types
    # if possible. So this will still be a length measure.
    ifcopenshell.api.pset.edit_qto(model, qto=qto, properties={"SomeLength": 12.3})

#### remove_pset
Removes a property set from a product

All properties that are part of this property set are also removed.

:param product: The IfcObject to remove the property set from.
:param pset: The IfcPropertySet or IfcElementQuantity to remove.
:return: None

Example:

.. code:: python

    # Let's imagine we have a new wall type with a property set.
    wall_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWallType")
    pset = ifcopenshell.api.pset.add_pset(model, product=wall_type, name="Pset_WallCommon")

    # Remove it!
    ifcopenshell.api.pset.remove_pset(model, product=wall_type, pset=pset)

#### unassign_pset
Unassign property set from the provided elements.

:param products: Elements (or element types) to assign the pset from.
:param pset: Property set.

Example:

.. code:: python

    element1 = ifcopenshell.api.root.create_entity(self.file, ifc_class="IfcWall")
    element2 = ifcopenshell.api.root.create_entity(self.file, ifc_class="IfcWall")
    ifcopenshell.api.pset.assign_pset(self.file, [element1, element2], pset)

    # Pset is now shared by 2 elements.
    assert ifcopenshell.util.element.get_elements_by_pset(pset) == {element1, element2}

    ifcopenshell.api.pset.unassign_pset(self.file, [element2], pset)
    # Pset was unassigned from element2.
    assert ifcopenshell.util.element.get_elements_by_pset(pset) == {element1}

#### unshare_pset
Copy a shared pset as linked only to the provided elements.

Note that method will create a copy of the pset for each element provided.

:param products: Elements (or element types) to link the pset to.
:param pset: Shared property set.
:return: List of copied property sets.

Example:

.. code:: python

    element1 = ifcopenshell.api.root.create_entity(self.file, ifc_class="IfcWall")
    element2 = ifcopenshell.api.root.create_entity(self.file, ifc_class="IfcWall")
    ifcopenshell.api.pset.assign_pset(self.file, [element1, element2], pset)

    # Pset is now shared by 2 elements.
    assert ifcopenshell.util.element.get_elements_by_pset(pset) == {element1, element2}

    new_psets = ifcopenshell.api.pset.unshare_pset(self.file, [element2], pset)

    # element2 was unassigned from the original pset.
    assert ifcopenshell.util.element.get_elements_by_pset(pset) == {element1}
    new_pset = new_psets[0]

    # New pset was created and was assigned to element2.
    assert new_pset != pset
    assert ifcopenshell.util.element.get_elements_by_pset(new_pset) == {element2}

## Module: pset_template

### Description
Manage property templates to standard project property names and data types

To help standardise the naming, data types, and association of properties to
elements, IFC supports property set templates. buildingSMART provides their own
built-in ISO-standardised property templates, but governments, companies, and
individuals may also create their own.

### Available Functions
- add_prop_template
- add_pset_template
- edit_prop_template
- edit_pset_template
- remove_prop_template
- remove_pset_template

### Function Docstrings
#### add_prop_template
Adds new property templates to a property set template

Assuming you first have a property set template, this allows you to add
templates for properties within that property set. A property template
lets you specify the name, description, and data type of a property.
When the template is provided to a model author, this gives them clear
instructions about the intention of the property and exactly which data
type to use.

Types of properties and quantities include:

* P_SINGLEVALUE - a single value, the most common type of property.
* P_ENUMERATEDVALUE - the property value may one or more values chosen
    from a preset list of values.
* P_BOUNDEDVALUE - the property has a minimum, maximum, and set value.
* P_LISTVALUE - the property has a list of values.
* P_TABLEVALUE - the property has a table of values.
* P_REFERENCEVALUE - the property is a parametric reference to another
    value. This is only for advanced users.
* Q_LENGTH - the quantity is a length.
* Q_AREA - the quantity is an area.
* Q_VOLUME - the quantity is a volume.
* Q_COUNT - the quantity is counting a item.
* Q_WEIGHT - the quantity is a weight.
* Q_TIME - the quantity is a time duration.

:param pset_template: The property set template to add the property
    template to.
:param name: The name of the property
:param description: A few words describing what the property stores.
:param template_type: The type of the property. If not provided,
    P_SINGLEVALUE or Q_LENGTH will be assumed (depending on the pset type).
:param primary_measure_type: The data type of the property,
    doesn't used for quantity set templates.
    Consult the IFC documentation for the full list of data types.
:return: The newly created IfcSimplePropertyTemplate.

Example:

.. code:: python

    # Create a simple template that may be applied to all types
    template = ifcopenshell.api.pset_template.add_pset_template(model, name="ABC_RiskFactors")

    # Here's one example property
    ifcopenshell.api.pset_template.add_prop_template(model, pset_template=template,
        name="HighVoltage", description="Whether there is a risk of high voltage.",
        primary_measure_type="IfcBoolean")

    # Here's another
    ifcopenshell.api.pset_template.add_prop_template(model, pset_template=template,
        name="ChemicalType", description="The class of chemical spillage.",
        primary_measure_type="IfcLabel")

#### add_pset_template
Adds a new property set template

This creates a new template for property sets. A template defines what
the name of the property set should be, what properties it can have,
what entities (e.g. wall) the property set can be assigned to, whether
it should be assigned at a type or occurrence level, the data types of
the properties, and descriptions of the properties. This template can
then be used as a project, company, or local government standard.

buildingSMART itself ships a catalogue of property sets using these
templates, ensuring that internationally common properties (e.g.  fire
rating of a wall) are all implemented exactly the same way across all
vendors and projects. Naturally, not everything can be standardised
internationally, so this allows you to create your own templates.

You may either create a property template to store properties, or a
quantity template to store quantities. For convenience, we will always
call them "property templates" as they are conceptually very similar.

This function only creates a template for the property set, not the
properties themselves within the property set. At this level, you are
allowed to define the name of the property set, whether it is type or
occurrence based, and which entities it applies to.

See the documentation for IfcPropertySetTemplate for instructions on
the types of template type and list of applicable entities.

The types of property set templates are:

* PSET_TYPEDRIVENONLY - assigned only to types
* PSET_TYPEDRIVENOVERRIDE - assigned to types or occurrences. If both,
    the occurrence overrides the type.
* PSET_OCCURRENCEDRIVEN - assigned to occurrences only.
* PSET_PERFORMANCEDRIVEN - assigned as a timeseries data range. This is
    only recommended for advanced users.
* QTO_TYPEDRIVENONLY - assigned only to types, but for quantities.
* QTO_TYPEDRIVENOVERRIDE - assigned to types or occurrences, but for
    quantities. If both, the occurrence overrides the type.
* QTO_OCCURRENCEDRIVEN - assigned to occurrences only, but for
    quantities.

By default, this creates a template that can be applied to types, but
overridden by occurrences, and is applicable to everything.

:param name: The name of the property set
:param template_type: Choose from one of PSET_TYPEDRIVENONLY,
    PSET_TYPEDRIVENOVERRIDE, PSET_OCCURRENCEDRIVEN,
    PSET_PERFORMANCEDRIVEN, QTO_TYPEDRIVENONLY, QTO_TYPEDRIVENOVERRIDE,
    QTO_OCCURRENCEDRIVEN, NOTDEFINED
:param applicable_entity: The entity that this template is allowed to be
    applied to. For example, IfcWall means that the property set may be
    assigned to walls only. IfcTypeObject, the default, means that the
    property set may be assigned to any type.
:return: The newly created IfcPropertySetTemplate

Example:

.. code:: python

    # Create a simple template that may be applied to all types
    ifcopenshell.api.pset_template.add_pset_template(model, name="ABC_RiskFactors")

    # Note that we aren't finished yet. Our property set template
    # doesn't have any properties in it. Let's add a minimum of one
    # property.
    ifcopenshell.api.pset_template.add_prop_template(model, pset_template=template,
        name="HighVoltage", description="Whether there is a risk of high voltage.",
        primary_measure_type="IfcBoolean")

#### edit_prop_template
Edits the attributes of an IfcSimplePropertyTemplate

For more information about the attributes and data types of an
IfcSimplePropertyTemplate, consult the IFC documentation.

:param prop_template: The IfcSimplePropertyTemplate entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    template = ifcopenshell.api.pset_template.add_pset_template(model, name="ABC_RiskFactors")

    # Here's a property with just default values.
    prop = ifcopenshell.api.pset_template.add_prop_template(model, pset_template=template)

    # Let's edit it to give the actual values we need.
    ifcopenshell.api.pset_template.edit_prop_template(model,
        prop_template=prop, attributes={"Name": "DemoA", "PrimaryMeasureType": "IfcLengthMeasure"})

#### edit_pset_template
Edits the attributes of an IfcPropertySetTemplate

For more information about the attributes and data types of an
IfcPropertySetTemplate, consult the IFC documentation.

:param pset_template: The IfcPropertySetTemplate entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Whoops! We named it with a buildingSMART reserved "Pset_" prefix!
    template = ifcopenshell.api.pset_template.add_pset_template(model, name="Pset_RiskFactors")

    # Let's fix it to prefix with our company code instead.
    ifcopenshell.api.pset_template.edit_pset_template(model,
        pset_template=template, attributes={"Name": "ABC_RiskFactors"})

#### remove_prop_template
Removes a property template

Note that a property set template should always have at least one
property template to be valid, so take care when removing property
templates.

:param prop_template: The IfcSimplePropertyTemplate to remove.
:return: None

Example:

.. code:: python

    template = ifcopenshell.api.pset_template.add_pset_template(model, name="ABC_RiskFactors")

    # Here's two propertes with just default values.
    prop1 = ifcopenshell.api.pset_template.add_prop_template(model, pset_template=template)
    prop2 = ifcopenshell.api.pset_template.add_prop_template(model, pset_template=template)

    # Let's remove the second one.
    ifcopenshell.api.pset_template.remove_prop_template(model, prop_template=prop2)

#### remove_pset_template
Removes a property set template

All property templates within the property set template are also removed
along with it.

:param pset_template: The IfcPropertySetTemplate to remove.
:return: None

Example:

.. code:: python

    # Create a template.
    template = ifcopenshell.api.pset_template.add_pset_template(model, name="ABC_RiskFactors")

    # Let's remove the template.
    ifcopenshell.api.pset_template.remove_pset_template(model, pset_template=template)

## Module: resource

### Description
Manage construction and maintenance resources

Resources include equipment (cranes, etc), labour, material, and products. They
are typically referenced in construction planning, maintenance schedules, or
cost items.

### Available Functions
- add_resource
- add_resource_quantity
- add_resource_time
- assign_resource
- calculate_resource_usage
- calculate_resource_work
- edit_resource
- edit_resource_quantity
- edit_resource_time
- remove_resource
- remove_resource_quantity
- unassign_resource

### Function Docstrings
#### add_resource
Add a new construction resource

Construction resources may be managed and connected to cost schedules
and construction schedules. This allows calculations to be done on
resource utilisation, cost optimisation (e.g. labour rates), and
optioneering on build strategies.

There are typically two types of resources. Crew resources are resources
where you manage your own crew and you have full control over the
equipment, labour, products, and materials used by your crew.
Alternatively, there are subcontractor resources, where you simply
delegate all the details to a subcontractor and it is not decomposed
into further levels of detail.

This means when adding resources, you'd first either add a crew or
subcontract resource. If it is a crew resource, you'd then add child
resources to that crew, such as equipment (cranes, excavators, hoists,
etc), material (wood, concrete, etc), and labour (rigging crews,
formworkers, etc).

:param parent_resource: If this is a child resource (typically to a crew
    resource), then nominate the parent IfcConstructionResource here.
:param ifc_class: The class of resource chosen from
    IfcConstructionEquipmentResource, IfcConstructionMaterialResource,
    IfcConstructionProductResource, IfcCrewResource, IfcLaborResource,
    or IfcSubContractResource.
:param name: The name of the resource
:param predefined_type: Consult the IFC documentation for the valid
    predefined types for each type of resource class.
:return: The newly created resource depending on the nominated IFC
    class.

Example:

.. code:: python

    # Add our own crew
    crew = ifcopenshell.api.resource.add_resource(model, ifc_class="IfcCrewResource")

    # Add some labour to our crew.
    ifcopenshell.api.resource.add_resource(model, parent_resource=crew, ifc_class="IfcLaborResource")

#### add_resource_quantity
Adds a quantity to a resource

The quantity of a resource represents the "unit quantity" of that
resource. For example, labour might be hired on a daily basis (8 hours).
There are different types of quantities (e.g. volume, count, or time).
Which quantity is used depends on the type of resource.  Material
resources may be quantified in terms of length, area, volume, or weight.
Equipment and labour resources are quantified in terms of time. Products
resources are quantified in terms of counts.

This base quantity is then used in other calculations.

:param resource: The IfcConstructionResource to add a quantity to.
:param ifc_class: The type of quantity to add, chosen from
    IfcQuantityArea (for material), IfcQuantityCount (for products),
    IfcQuantityLength (for material), IfcQuantityTime (for equipment or
    labour), IfcQuantityVolume (for material), and IfcQuantityWeight
    (for material).
:return: The newly created quantity depending on the IFC class

Example:

.. code:: python

    # Add our own crew
    crew = ifcopenshell.api.resource.add_resource(model, ifc_class="IfcCrewResource")

    # Add some labour to our crew.
    labour = ifcopenshell.api.resource.add_resource(model,
        parent_resource=crew, ifc_class="IfcLaborResource")

    # Labour resource is quantified in terms of time.
    quantity = ifcopenshell.api.resource.add_resource_quantity(model,
        resource=labour, ifc_class="IfcQuantityTime")

    # Store the time used in hours
    ifcopenshell.api.resource.edit_resource_quantity(model,
        physical_quantity=quantity, attributes={"TimeValue": 8.0})

#### add_resource_time
Adds the time that a resource is used for

For labour and equipment resources, the total duration that the resource
is used for may be stored. This may either be input manually or
calculated parametrically. This is known as the resource time, and may
be used to calculate other parameters like resource utilisation.

:param resource: The IfcConstructionResource to record time for.
:return: The newly created IfcResourceTime

Example:

.. code:: python

    # Add our own crew
    crew = ifcopenshell.api.resource.add_resource(model, ifc_class="IfcCrewResource")

    # Add some labour to our crew.
    labour = ifcopenshell.api.resource.add_resource(model,
        parent_resource=crew, ifc_class="IfcLaborResource")

    # Labour resource is quantified in terms of time.
    quantity = ifcopenshell.api.resource.add_resource_quantity(model,
        resource=labour, ifc_class="IfcQuantityTime")

    # Store the unit time used in hours
    ifcopenshell.api.resource.edit_resource_quantity(model,
        physical_quantity=quantity, attributes={"TimeValue": 8.0})

    # Let's imagine we've used the resource for 2 days.
    time = ifcopenshell.api.resource.add_resource_time(model, resource=labour)
    ifcopenshell.api.resource.edit_resource_time(model,
        resource_time=time, attributes={"ScheduleWork": "PT16H"})

#### assign_resource
Assigns a resource to an object

Two types of objects are typically assigned to resources: products and
actors.

If a product is assigned to a resource, that means that the product
represents the resource on site. This may be represented via material
handling zones on a construction site, or equipment like cranes and
their physical locations.

If an actor is assigned to a resource, that means that the actor (person
or organisation) is the actor consuming the resource (e.g. if the
resource is material or equipment) or the actor performing the work
(e.g. if the resource is a labour resource).

:param relating_resource: The IfcResource to assign the object to.
:param related_object: The IfcProduct or IfcActor to assign to the
    object.
:return: The newly created IfcRelAssignsToResource

Example:

.. code:: python

    # Add our own crew
    crew = ifcopenshell.api.resource.add_resource(model, ifc_class="IfcCrewResource")

    # Add some a tower crane to our crew.
    crane = ifcopenshell.api.resource.add_resource(model,
        parent_resource=crew, ifc_class="IfcConstructionEquipmentResource", name="Tower Crane 01")

    # Our tower crane will be placed via this physical product.
    product = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcBuildingElementProxy", predefined_type="CRANE")

    # Let's place our crane at some X, Y coordinates.
    matrix = numpy.eye(4)
    matrix[0][3], matrix[1][3] = 3.0, 4.0
    ifcopenshell.api.geometry.edit_object_placement(model, product=crane, matrix=matrix)

    # Let's assign our crane to the resource. The crane now represents
    # the resource.
    ifcopenshell.api.resource.assign_resource(model, relating_resource=crane, related_object=product)

    # Setup an organisation actor who will operate the crane
    organisation = ifcopenshell.api.owner.add_organisation(model,
        identification="UCO", name="Unionised Crane Operators Pty Ltd")
    role = ifcopenshell.api.owner.add_role(model, assigned_object=organisation, role="CREW")
    actor = ifcopenshell.api.owner.add_actor(model, actor=organisation)

    # This means that UCO is now our crane operator.
    ifcopenshell.api.resource.assign_resource(model, relating_resource=crane, related_object=actor)

#### calculate_resource_usage
Calculates the number of resources required to perform scheduled work on a task.

:param resource: The IfcConstructionResource to calculate the usage for.
:return: None

#### calculate_resource_work
Calculates the work that a resource is used for

This is an unofficial parametric calculation that may be done on a
resource based on careful analysis of the relationships between the
costing, scheduling, and resource domains in IFC.

A resource may store a productivity rate in a property set called
EPset_Productivity. This stores three properties:

* BaseQuantityConsumed - a duration that the resource is consumed for.
* BaseQuantityProducedName - what quantity the resource can produce,
    such as area or volume.
* BaseQuantityProducedValue - what value of that quantity the resource
    can produce during that duration.

For example, a labour or equipment resource might produce 100m3 of
NetVolume every day (i.e. 8 hours are consumed).

Then, if a resource is assigned to a construction task, and that
construction task is assigned to concrete slabs totalling 200m3, we can
calculate that the resource consumes 16 hours of work.

This calculated work is stored against the resource as scheduled work
under the resource time data.

:param resource: The IfcConstructionResource that you want to calculate
    the work performed.
:return None:

#### edit_resource
Edits the attributes of an IfcResource

For more information about the attributes and data types of an
IfcResource, consult the IFC documentation.

:param resource: The IfcResource entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Add our own crew
    crew = ifcopenshell.api.resource.add_resource(model, ifc_class="IfcCrewResource")

    # Change the name of the resource to "Zone A Crew"
    ifcopenshell.api.resource.edit_resource(model, resource=resource, attributes={"Name": "Foo"})

#### edit_resource_quantity
Edits the attributes of an IFC quantity

For more information about the attributes and data types of an
IfC quantity, consult the IFC documentation.

:param physical_quantity: The IfC quantity entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Add our own crew
    crew = ifcopenshell.api.resource.add_resource(model, ifc_class="IfcCrewResource")

    # Add some labour to our crew.
    labour = ifcopenshell.api.resource.add_resource(model,
        parent_resource=crew, ifc_class="IfcLaborResource")

    # Labour resource is quantified in terms of time.
    ifcopenshell.api.resource.add_resource_quantity(model,
        resource=labour, ifc_class="IfcQuantityTime")

    # Store the time used in hours
    ifcopenshell.api.resource.edit_resource_quantity(model,
        physical_quantity=time, attributes={"TimeValue": 8.0})

#### edit_resource_time
Edits the attributes of an IfcResourceTime

For more information about the attributes and data types of an
IfcResourceTime, consult the IFC documentation.

:param resource_time: The IfcResourceTime entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Add our own crew
    crew = ifcopenshell.api.resource.add_resource(model, ifc_class="IfcCrewResource")

    # Add some labour to our crew.
    labour = ifcopenshell.api.resource.add_resource(model,
        parent_resource=crew, ifc_class="IfcLaborResource")

    # Labour resource is quantified in terms of time.
    ifcopenshell.api.resource.add_resource_quantity(model,
        resource=labour, ifc_class="IfcQuantityTime")

    # Store the unit time used in hours
    ifcopenshell.api.resource.edit_resource_quantity(model,
        physical_quantity=time, attributes={"TimeValue": 8.0})

    # Let's imagine we've used the resource for 2 days.
    time = ifcopenshell.api.resource.add_resource_time(model, resource=labour)
    ifcopenshell.api.resource.edit_resource_time(model,
        resource_time=time, attributes={"ScheduleWork": "P16H"})

#### remove_resource
Removes a resource and all relationships

Example:

.. code:: python

    # Add our own crew
    crew = ifcopenshell.api.resource.add_resource(model, ifc_class="IfcCrewResource")

    # Fire our crew
    ifcopenshell.api.resource.remove_resource(model, resource=crew)

#### remove_resource_quantity
Removes the base quantity of a resource

:param resource: The IfcConstructionResource to remove the quantity from.
:return: None

Example:

.. code:: python

    # Add our own crew
    crew = ifcopenshell.api.resource.add_resource(model, ifc_class="IfcCrewResource")

    # Add some labour to our crew.
    labour = ifcopenshell.api.resource.add_resource(model,
        parent_resource=crew, ifc_class="IfcLaborResource")

    # Labour resource is quantified in terms of time.
    ifcopenshell.api.resource.add_resource_quantity(model,
        resource=labour, ifc_class="IfcQuantityTime")

    # Let's say we only want to store the resource but no quantities,
    # let's clean up our mess and remove the quantity.
    ifcopenshell.api.resource.remove_resource_quantity(model, resource=labour)

#### unassign_resource
Removes the relationship between a resource and object

:param relating_resource: The IfcResource to assign the object to.
:param related_object: The IfcProduct or IfcActor to assign to the
    object.
:return: None

Example:

.. code:: python

    # Add our own crew
    crew = ifcopenshell.api.resource.add_resource(model, ifc_class="IfcCrewResource")

    # Add some a tower crane to our crew.
    crane = ifcopenshell.api.resource.add_resource(model,
        parent_resource=crew, ifc_class="IfcConstructionEquipmentResource", name="Tower Crane 01")

    # Our tower crane will be placed via this physical product.
    product = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcBuildingElementProxy", predefined_type="CRANE")

    # Let's assign our crane to the resource. The crane now represents
    # the resource.
    ifcopenshell.api.resource.assign_resource(model,
        relating_resource=crane, related_object=product)

    # Undo it.
    ifcopenshell.api.resource.unassign_resource(model,
        relating_resource=crane, related_object=product)

## Module: sequence

### Description
Manage work schedules, tasks, calendars, and more for 4D

These are typically used for construction planning, but may also be used in
managing recurring facility maintenance schedules.

### Available Functions
- add_date_time
- add_task
- add_task_time
- add_time_period
- add_work_calendar
- add_work_plan
- add_work_schedule
- add_work_time
- assign_lag_time
- assign_process
- assign_product
- assign_recurrence_pattern
- assign_sequence
- assign_work_plan
- calculate_task_duration
- cascade_schedule
- copy_work_schedule
- create_baseline
- duplicate_task
- edit_lag_time
- edit_recurrence_pattern
- edit_sequence
- edit_task
- edit_task_time
- edit_work_calendar
- edit_work_plan
- edit_work_schedule
- edit_work_time
- recalculate_schedule
- remove_task
- remove_time_period
- remove_work_calendar
- remove_work_plan
- remove_work_schedule
- remove_work_time
- unassign_lag_time
- unassign_process
- unassign_product
- unassign_recurrence_pattern
- unassign_sequence

### Function Docstrings
#### add_date_time
Add a new date time.

Depending on ``file``'s schema method will:
- IFC2X3 - create IfcDateAndTime entity
- IFC4+  - create IfcDatetime formatted string

:param dt: datetime to convert to IFC.
:return: IfcDateAndTime entity or IfcDatetime string.

Example:

.. code:: python

    dt = datetime(2025, 3, 1, 12, 31, 24)
    datetime_ifc = ifcopenshell.api.sequence.add_date_time(self.file, dt)

    # IFC2X3: #1=IfcDateAndTime(#2,#3)
    # IFC4+: "2025-03-01T12:31:24"
    print(datetime_ifc)

#### add_task
Adds a new task

Tasks are typically used for two purposes: construction scheduling and
facility management.

In construction scheduling, a task represents a job to be done in a work
schedule. Tasks are organised in a hierarchical manner known as a work
breakdown structure (WBS) and have lots of sequential relationships
(e.g. this task must finish before the next task can start) and date
information (e.g. durations, start dates). This is often represented as
a gantt chart and used to analyse critical paths to try and reduce
project time to stay on-time and within budget.

In facility management, a task represents a maintenance task to maintain
a piece of equipment. Tasks are broken down into a punch list, or simply
a bulleted or ordered sequence of tasks to be performed (e.g. turn off
equipment, check power connection, etc) in order to maintain the
equipment. Tasks will also typically have recurring scheduled dates in
line with the maintenance schedule. These maintenance tasks and
procedures are typically published as part of an operations and
maintenance manual.

All tasks must be grouped in a work schedule, either directly as a root
or top-level task, or indirectly as a child or subtask of a parent task.
In construction scheduling, tasks may be nested many times to create the
work breakdown structure, and the "leaf" tasks (i.e. tasks with no more
subtasks) are considered to be the activities with dates, whereas all
parent tasks are part of the breakdown structure used for categorisation
purposes. In facility management, top-level tasks represent the overall
maintenance job to be performed, and child tasks represent an ordered
list of things to do for that maintenance. These form a 2-level
hierarchy. No further child tasks are recommended.

:param work_schedule: The work schedule to group the task in, if the
    task is to be a top-level or root task. This is mutually exclusive
    with the parent_task parameter.
:param parent_task: The parent task, if the task is to be a subtask or
    child task. This is mutually exclusive with the work_schedule
    parameter.
:param name: The name of the task.
:param description: The description of the task.
:param identification: The identification code of the task.
:param predefined_type: The predefined type of the task. Common ones
    include CONSTRUCTION, DEMOLITION, or MAINTENANCE. Consultant the
    IFC documentation for IfcTaskTypeEnum for more information.
:return: The newly created IfcTask

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Add a root task to represent the design milestones, and major
    # project phases.
    ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Milestones", identification="A")
    ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Design", identification="B")
    construction = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Construction", identification="C")

    # Let's start creating our work breakdown structure.
    ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Early Works", identification="C1")
    ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Substructure", identification="C2")
    superstructure = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Superstructure", identification="C3")

    # Notice how the leaf task is the actual activity
    ifcopenshell.api.sequence.add_task(model,
        parent_task=superstructure, name="Ground Floor FRP", identification="C3.1")

    # Let's imagine we are digitising an operations and maintenance
    # manual for the mechanical discipline.
    maintenance = ifcopenshell.api.sequence.add_work_schedule(model, name="Mechanical Maintenance")

    # Imagine we have to clean the condenser coils for a chiller every
    # month. Like the schedule above, to keep things simple we won't
    # show scheduling times and calendars. This root task represents the
    # overall maintenance task.
    cleaning = ifcopenshell.api.sequence.add_task(model,
        work_schedule=maintenance, name="Condenser coil cleaning")

    # These subtasks represent the punch list of maintenance tasks.
    ifcopenshell.api.sequence.add_task(model, parent_task=cleaning, identification="1",
        description="Prior to work, wear safety shoes, gloves, and goggles.")
    ifcopenshell.api.sequence.add_task(model, parent_task=cleaning, identification="2",
        description="Prepare jet pump, screwdriver, hose clamp, and control panel door key.")
    ifcopenshell.api.sequence.add_task(model, parent_task=cleaning, identification="3",
        description="Switch OFF the chiller unit.")
    ifcopenshell.api.sequence.add_task(model, parent_task=cleaning, identification="3",
        description="Open the isolator switch.")
    ifcopenshell.api.sequence.add_task(model, parent_task=cleaning, identification="3",
        description="Setup the water pressure by tapping to a water supply and connecting to a ...")

#### add_task_time
Adds a task time to a task

Some tasks, such as activities within a work breakdown structure or
overall maintenance tasks will have time related information. This
includes start dates, durations, end dates, and possible recurring times
(especially for maintenance tasks).

:param task: The task to add time data to.
:param is_recurring: Whether or not the time should recur.
:return: The newly created IfcTaskTime.

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Create a portion of a work breakdown structure.
    construction = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Construction", identification="C")
    superstructure = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Superstructure", identification="C3")
    task = ifcopenshell.api.sequence.add_task(model,
        parent_task=superstructure, name="Ground Floor FRP", identification="C3.1")

    # Add time data. Note that time data is blank by default.
    time = ifcopenshell.api.sequence.add_task_time(model, task=task)

    # Let's say our task starts on the first of January when everybody
    # is still drunk from the new years celebration, and lasts for 2
    # days. Note we don't need to specify the end date, as that is
    # derived from the start plus the duration. In this simple example,
    # no calendar has been specified, so we are working 24/7. Yikes!
    ifcopenshell.api.sequence.edit_task_time(model,
        task_time=time, attributes={"ScheduleStart": "2000-01-01", "ScheduleDuration": "P2D"})

#### add_time_period
Adds a time period to a recurrence pattern

A recurring time may be an all-day event, or only during certain time
periods of the day. For example, you might say that every 1st of January
recurring is a public holiday, which is an all-day event. Alternatively,
you might say that you work every (i.e. recurringly) Monday to Friday,
from 9am to 5pm. The 9am to 5pm is the time period.

There may also be multiple recurrence patterns, such as from 9am to
12pm, and then another from 1pm to 5pm (to indicate an hour break for
lunch).

:param recurrence_pattern: The IfcRecurrencePattern to add the time
    period to. See ifcopenshell.api.sequence.assign_recurrence_pattern.
:param start_time: The start time of the time period, in a format
    compatible with IfcTime, such as an ISO format time string or a
    datetime.time object.
:param end_time: The end time of the time period, in a format
    compatible with IfcTime, such as an ISO format time string or a
    datetime.time object.
:return: The newly created IfcTimePeriod

Example:

.. code:: python

    # Let's create a new calendar.
    calendar = ifcopenshell.api.sequence.add_work_calendar(model)

    # Let's start defining the times that we work during the week.
    work_time = ifcopenshell.api.sequence.add_work_time(model,
        work_calendar=calendar, time_type="WorkingTimes")

    # We create a weekly recurrence
    pattern = ifcopenshell.api.sequence.assign_recurrence_pattern(model,
        parent=work_time, recurrence_type="WEEKLY")

    # State that we work from weekdays 1 to 5 (i.e. Monday to Friday)
    ifcopenshell.api.sequence.edit_recurrence_pattern(model,
        recurrence_pattern=pattern, attributes={"WeekdayComponent": [1, 2, 3, 4, 5]})

    # The morning work session, lunch, then the afternoon work session.
    ifcopenshell.api.sequence.add_time_period(model,
        recurrence_pattern=pattern, start_time="09:00", end_time="12:00")
    ifcopenshell.api.sequence.add_time_period(model,
        recurrence_pattern=pattern, start_time="13:00", end_time="17:00")

#### add_work_calendar
Add a work calendar

A work calendar defines when work is allowed to occur and when the
holidays are. This is a fundamental concept in construction planning.
Every task in a work schedule will have an associated calendar. Some
task and resources work 24/7, whereas others work Monday to Friday, or
5.5 day weeks, etc. This is important, as tasks durations may only occur
during working times in a work calendar.

Work calendars can also be used to associate with events, such as
indicating that during certain days and times of the year, motion
sensors should turn on the lights, and other smart building controls.

:param name: The name of the calendar. Typically something like
    "5 Day Working Week" or "24/7".
:param predefined_type: The type of calendar, typically used to more
    specifically define shifts, such as FIRSTSHIFT, SECONDSHIFT, or
    THIRDSHIFT. Leave as NOTDEFINED for basic calendar usage.
:return: The newly created IfcWorkCalendar

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Add a root task to represent the construction tasks.
    task = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Construction", identification="C")

    # Let's create a new calendar.
    calendar = ifcopenshell.api.sequence.add_work_calendar(model, name="5 Day Week")

    # Let's start defining the times that we work during the week.
    work_time = ifcopenshell.api.sequence.add_work_time(model,
        work_calendar=calendar, time_type="WorkingTimes")

    # We create a weekly recurrence
    pattern = ifcopenshell.api.sequence.assign_recurrence_pattern(model,
        parent=work_time, recurrence_type="WEEKLY")

    # State that we work from weekdays 1 to 5 (i.e. Monday to Friday), 9am to 5pm
    ifcopenshell.api.sequence.edit_recurrence_pattern(model,
        recurrence_pattern=pattern, attributes={"WeekdayComponent": [1, 2, 3, 4, 5]})
    ifcopenshell.api.sequence.add_time_period(model,
        recurrence_pattern=pattern, start_time="09:00", end_time="17:00")

    # We associate the calendar with the construction root task. All
    # subtasks underneath the construction work task will also inherit
    # this calendar by default (though you can override them).
    ifcopenshell.api.control.assign_control(model, relating_control=calendar, related_objects=[task])

#### add_work_plan
Add a new work plan

A work plan is a group of work schedules. Since work schedules may have
different purposes, such as for maintenance or construction scheduling,
baseline comparison, or phasing, work plans can be used to group related
work schedules. At a minimum, it is recommended to use work plans to
indicate whether the work schedules are for facility management or for
construction scheduling.

:param name: The name of the work plan. Recommended to be "Maintenance"
    or "Construction" for the two main purposes.
:param predefined_type: The type of work plan, used for baselining.
    Leave as "NOTDEFINED" if unsure.
:param start_time: The earliest start time when the schedules grouped
    within the work plan are relevant.
:return: The newly created IfcWorkPlan

Example:

.. code:: python

    # This will hold all our construction schedules
    work_plan = ifcopenshell.api.sequence.add_work_plan(model, name="Construction")

    # This is one of our schedules in our work plan.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model,
        name="Construction Schedule A", work_plan=work_plan)

#### add_work_schedule
Add a new work schedule

A work schedule is a group of tasks, where the tasks are typically
either for maintenance or for construction scheduling.

:param name: The name of the work schedule.
:param predefined_type: The type of schedule, chosen from ACTUAL,
    BASELINE, and PLANNED. Typically you would start with PLANNED, then
    convert to a BASELINE when changes are made with separate schedules,
    then have a parallel ACTUAL schedule.
:param object_type: Work schedule Object Type. Should be provided
    in case if ``predefined_type`` is USERDEFINED.
:param start_time: The earlier start time when the schedule is relevant.
    May be represented with an ISO standard string.
:param work_plan: The IfcWorkPlan the schedule will be part of. If not
    provided, the schedule will not be grouped in a work plan and would
    exist as a top level schedule in the project. This is not
    recommended.
:return: The newly created IfcWorkSchedule

Example:

.. code:: python

    # This will hold all our construction schedules
    work_plan = ifcopenshell.api.sequence.add_work_plan(model, name="Construction")

    # Let's imagine this is one of our schedules in our work plan.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model,
        name="Construction Schedule A", work_plan=work_plan)

    # Add a root task to represent the design milestones, and major
    # project phases.
    ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Milestones", identification="A")
    ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Design", identification="B")
    construction = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Construction", identification="C")

#### add_work_time
Add either working times or holiday times to a calendar

A calendar defines when work occurs by defining working times and
holiday times. First, the working times are defined, then the holidays
may override the working times. For this reason, holidays are also known
as exception times. For example, you might define the working times as
every Monday to Friday, then define a few holidays in the year, such as
the 1st of January. If the 1st of January is on a weekday, it will
override the work time.

:param work_calendar: The IfcWorkCalendar to add the work or holiday
    time definition to.
:param time_type: Either WorkingTimes or ExceptionTimes, depending on
    what you want to define.
:return: The newly created IfcWorkTime

Example:

.. code:: python

    # Let's create a new calendar.
    calendar = ifcopenshell.api.sequence.add_work_calendar(model)

    # Let's start defining the times that we work during the week.
    work_time = ifcopenshell.api.sequence.add_work_time(model,
        work_calendar=calendar, time_type="WorkingTimes")

    # We create a weekly recurrence
    pattern = ifcopenshell.api.sequence.assign_recurrence_pattern(model,
        parent=work_time, recurrence_type="WEEKLY")

    # State that we work from weekdays 1 to 5 (i.e. Monday to Friday)
    ifcopenshell.api.sequence.edit_recurrence_pattern(model,
        recurrence_pattern=pattern, attributes={"WeekdayComponent": [1, 2, 3, 4, 5]})

    # Let's set some holidays
    holidays = ifcopenshell.api.sequence.add_work_time(model,
        work_calendar=calendar, time_type="ExceptionTimes")

    # We create a yearly recurrence
    pattern = ifcopenshell.api.sequence.assign_recurrence_pattern(model,
        parent=work_time, recurrence_type="YEARLY_BY_DAY_OF_MONTH")

    # The holiday is every 1st of January
    ifcopenshell.api.sequence.edit_recurrence_pattern(model,
        recurrence_pattern=pattern, attributes={"DayComponent": [1], "MonthComponent": [1]})

#### assign_lag_time
Assign a lag time to a sequence relationship between tasks

A task sequence (e.g. finish to start) may optionally have a lag time
defined. This is a fundamental concept in construction scheduling. The
lag is defined as a duration, and the duration is typically either
calendar based (i.e.  follows the working times and holidays of the
calendar) or elapsed time based (i.e. 24/7).

A sequence may only have a single lag time defined. Negative lag times
are allowed.

:param rel_sequence: The IfcRelSequence to assign the lag time to.
:param lag_value: An ISO standardised duration string.
:param duration_type: Choose from WORKTIME for the associated
    calendar-based lag times (this is the most common scenario and is
    recommended as a default), or ELAPSEDTIME to not follow the
    calendar. You may also choose NOTDEFINED but the behaviour of this
    is unclear.
:return: The newly created IfcLagTime

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Let's imagine a root construction task
    construction = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Construction", identification="C")

    # Let's imagine we're doing a typically formwork, reinforcement,
    # pour sequence. Let's start with the formwork. It'll take us 2
    # days.
    formwork = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Formwork", identification="C.1")
    time = ifcopenshell.api.sequence.add_task_time(model, task=formwork)
    ifcopenshell.api.sequence.edit_task_time(model,
        task_time=time, attributes={"ScheduleStart": "2000-01-01", "ScheduleDuration": "P2D"})

    # Now let's do the reinforcement. It'll take us another 2 days.
    reinforcement = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Reinforcement", identification="C.2")
    time = ifcopenshell.api.sequence.add_task_time(model, task=reinforcement)
    ifcopenshell.api.sequence.edit_task_time(model,
        task_time=time, attributes={"ScheduleStart": "2000-01-01", "ScheduleDuration": "P2D"})

    # Now let's say the formwork must finish before the reinforcement
    # can start. This is a typical finish to start relationship (FS).
    sequence = ifcopenshell.api.sequence.assign_sequence(model,
        relating_process=formwork, related_process=reinforcement)

    # Now typically there would be no lag time between formwork and
    # reinforcement, but let's pretend that we had to allow 1 day gap
    # for whatever reason.
    ifcopenshell.api.sequence.assign_lag_time(model, rel_sequence=sequence, lag_value="P1D")

#### assign_process
Assigns an object to be related to a process, typically a construction task

Processes work using the ICOM (Input, Controls, Outputs, Mechanisms)
paradigm in IFC. This process model is commonly used in modeling
manufacturing functions.

For example, processes (such as tasks) consume Inputs and transform them
into Outputs. The process may only occur within the limits of Controls
(e.g. cost items) and may require Mechanisms (ISO9000 calls them
Mechanisms, whereas IFC calls them resources, such as raw materials,
labour, or equipment).

              +----------+
              | Controls |
              +----------+
                    |
                    V
+--------+     +---------+     +---------+
| Inputs | --> | Process | --> | Outputs |
+--------+     +---------+     +---------+
                    ^
                    |
              +-----------+
              | Resources |
              +-----------+

There are three main scenarios where an object may be related to a
task: defining inputs, controls, and resources of a process.

For inputs, a product (i.e. wall) may be defined as an input to a task,
such as when the task is to demolish the wall (i.e. the wall is an
input, and there is no output).

For controls, a cost item may be defined as a control to a task.

For resources, any construction resource may be assigned to a task.

:param relating_process: The IfcProcess (typically IfcTask) that the
    input, control, or resource is related to.
:param related_object: The IfcProduct (for input), IfcCostItem (for
    control) or IfcConstructionResource (for resource).
:return: The newly created IfcRelAssignsToProcess relationship

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Let's create a construction task. Note that the predefined type is
    # important to distinguish types of tasks.
    task = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Demolish existing", identification="A", predefined_type="DEMOLITION")

    # Let's say we have a wall somewhere.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # Let's demolish that wall!
    ifcopenshell.api.sequence.assign_process(model, relating_process=task, related_object=wall)

#### assign_product
Assigns a product to be produced as a result of a process

A construction task may result in products (e.g. a wall) being
constructed. These task "Outputs" are defined in IFC through product
relationships.

Not all tasks have Outputs. For example, maintenance tasks will
typically not have any outputs.

See ifcopenshell.api.sequence.assign_process for Inputs and other types
of process relationships that can be described in manufacturing
process modeling.

:param relating_product: The IfcProduct that was constructed as a result
    of the task.
:param related_object: The IfcProcess (typically IfcTask) of the
    construction task.
:return: The newly created IfcRelAssignsToProduct relationship

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Let's create a construction task. Note that the predefined type is
    # important to distinguish types of tasks.
    task = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Build wall", identification="A", predefined_type="CONSTRUCTION")

    # Let's say we have a wall somewhere.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # Let's construct that wall!
    ifcopenshell.api.sequence.assign_product(model, relating_product=wall, related_object=task)

#### assign_recurrence_pattern
Define a time to recur at a particular interval

There are two scenarios where you might want to define a recurring time
pattern.

You might want a task to be scheduled at a recurring interval,
this is common for maintenance tasks which need to be performed monthly,
every 6 months, every year, etc.

Alternatively, you might be defining a work calendar, which defines
working days or holidays. The working days might be every week from
monday to friday ("every" week means it recurs every week), or the
holidays might be the same every year.

The types of recurrence are:

- DAILY: every Nth (interval) day for up to X (Occurrences) occurrences.
    e.g. Every day, every 2 days, every day up to 5 times, etc
- WEEKLY: every Nth (interval) MTWTFSS (WeekdayComponent) for up to X
    (Occurrences) occurrences. e.g. Every Monday, every weekday, every
    other saturday, etc
- MONTHLY_BY_DAY_OF_MONTH: every Nth (DayComponent) of every Xth
    (Interval) Month up to Y (Occurrences) occurrences. e.g. Every 15th of
    the Month.
- MONTHLY_BY_POSITION: Every Nth (Position) MTWTFSS (WeekdayComponent)
    of every Xth (Interval) Month up to Y (Occurrences) occurrences. e.g.
    Every second Tuesday of the Month.
- YEARLY_BY_DAY_OF_MONTH: every Nth (DayComponent) of every JFMAMJJASOND
    (MonthComponent) month of every Yth (Interval) Year up to Z
    (Occurrences) occurrences. e.g. every 25th of December.
- YEARLY_BY_POSITION: every Nth (Position) MTWTFSS (WeekdayComponent) of
    every JFMAMJJASOND (MonthComponent) month of every Yth (Interval)
    Year up to Z (Occurrences) occurrences. e.g. every third Wednesday
    of January.

These recurrence patterns are fairly standard in all calendar and
scheduling applications.

:param parent: Either an IfcTaskTimeRecurring if you are defining a
    recurring schedule for a task, or IfcWorkTime if you are defining a
    recurring pattern for a workdays or holidays in a calendar.
:param recurrence_type: One of the types of recurrences.
:return: The newly created IfcRecurrencePattern

Example:

.. code:: python

    # Let's create a new calendar.
    calendar = ifcopenshell.api.sequence.add_work_calendar(model)

    # Let's start defining the times that we work during the week.
    work_time = ifcopenshell.api.sequence.add_work_time(model,
        work_calendar=calendar, time_type="WorkingTimes")

    # We create a weekly recurrence
    pattern = ifcopenshell.api.sequence.assign_recurrence_pattern(model,
        parent=work_time, recurrence_type="WEEKLY")

    # State that we work from weekdays 1 to 5 (i.e. Monday to Friday)
    ifcopenshell.api.sequence.edit_recurrence_pattern(model,
        recurrence_pattern=pattern, attributes={"WeekdayComponent": [1, 2, 3, 4, 5]})

    # Let's imagine we are creating a maintenance schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Equipment Maintenance")

    # Now let's imagine we have a task to maintain the chillers
    task = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Chiller maintenance")

    # Because it is a maintenance task, we must schedule a recurring time
    time = ifcopenshell.api.sequence.add_task_time(model, task=task, is_recurring=True)

    # We create a monthly recurrence
    pattern = ifcopenshell.api.sequence.assign_recurrence_pattern(model,
        parent=work_time, recurrence_type="MONTHLY_BY_DAY_OF_MONTH")

    # Specifically, the maintenance task must occur every 6 months
    ifcopenshell.api.sequence.edit_recurrence_pattern(model,
        recurrence_pattern=pattern, attributes={"DayComponent": [1], "Interval": 6})

#### assign_sequence
Assign a sequential relationship between tasks

Tasks in construction sequencing typically have sequence relationships
between them, indicating that one task must happen after another. This
is used to automatically compute new start and end dates and cascade
changes when dates are changed. This is also used to calculate critical
paths and floats.

There are four types of sequence relationships, known as finish to
start, finish to finish, start to start, and start to finish, sometimes
abbreviated as a (FS, FF, SS, and SF). The most common is the finish to
start relationship, indicating that the previous task must finish before
the next task can start.

You must not create cyclical task sequences. This makes the computer
unhappy.

Note that "previous" or "next" does not necessarily mean the task
chronologically happens before or after. They simply indicate the order
of the sequence relationship. For this reason, they are often called
predecessor and successor tasks in the planning profession.

:param relating_process: The previous / predecessor task.
:param related_process: The next / successor task.
:param sequence_type: Choose from FINISH_START, FINISH_FINISH,
    START_START, or START_FINISH.
:return: The newly created IfcRelSequence

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Let's imagine a root construction task
    construction = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Construction", identification="C")

    # Let's imagine we're doing a typically formwork, reinforcement,
    # pour sequence. Let's start with the formwork. It'll take us 2
    # days.
    formwork = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Formwork", identification="C.1")
    time = ifcopenshell.api.sequence.add_task_time(model, task=formwork)
    ifcopenshell.api.sequence.edit_task_time(model,
        task_time=time, attributes={"ScheduleStart": "2000-01-01", "ScheduleDuration": "P2D"})

    # Now let's do the reinforcement. It'll take us another 2 days.
    reinforcement = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Reinforcement", identification="C.2")
    time = ifcopenshell.api.sequence.add_task_time(model, task=reinforcement)
    ifcopenshell.api.sequence.edit_task_time(model,
        task_time=time, attributes={"ScheduleStart": "2000-01-01", "ScheduleDuration": "P2D"})

    # Now the pour it It'll only take 1 day.
    pour = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Reinforcement", identification="C.3")
    time = ifcopenshell.api.sequence.add_task_time(model, task=pour)
    ifcopenshell.api.sequence.edit_task_time(model,
        task_time=time, attributes={"ScheduleStart": "2000-01-01", "ScheduleDuration": "P1D"})

    # Now let's say the formwork must finish before the reinforcement
    # can start, and the reinforcement must finish before the pour can
    # start. This is a typical finish to start relationship (FS).
    ifcopenshell.api.sequence.assign_sequence(model,
        relating_process=formwork, related_process=reinforcement)
    ifcopenshell.api.sequence.assign_sequence(model,
        relating_process=reinforcement, related_process=pour)

    # Notice how we set all the scheduled start dates arbitrarily at
    # 2000-01-01. This is because we can ask IfcOpenShell to
    # automatically cascade the dates, starting from any task. This will
    # update the reinforcement date to be 2000-01-03 and the pour date
    # to be 2000-01-05.
    ifcopenshell.api.sequence.cascade_schedule(model, task=formwork)

#### assign_work_plan
Assigns a work schedule to a work plan

Typically, work schedules would be assigned to a work plan at creation.
However you may also delay this and do it manually afterwards.

:param work_schedule: The IfcWorkSchedule that will be assigned to the
    work plan.
:param work_plan: The IfcWorkPlan for the schedule to be assigned to.
:return: The IfcRelAggregates relationship

Example:

.. code:: python

    # This will hold all our construction schedules
    work_plan = ifcopenshell.api.sequence.add_work_plan(model, name="Construction")

    # Alternatively, if you create a schedule without a work plan ...
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # ... you can assign the work plan afterwards.
    ifcopenshell.api.sequence.assign_work_plan(work_schedule=schedule, work_plan=work_plan)

#### calculate_task_duration
Calculates the task duration based on resource usage

If a task has labour or equipment resources assigned to it, its duration
may be parametrically derived from the scheduled work of the resource.
For example, a labour resource with scheduled work of 10 working days
and a resource utilisation of 200% (i.e. two labour teams) will imply
that the task duration is 5 working days.

If this data is not available, such as if the task has no resources,
then nothing happens.

:param task: The IfcTask to calculate the duration for.
:return: None

Example:

.. code:: python

    # Add our own crew
    crew = ifcopenshell.api.resource.add_resource(model, ifc_class="IfcCrewResource")

    # Add some labour to our crew.
    labour = ifcopenshell.api.resource.add_resource(model,
        parent_resource=crew, ifc_class="IfcLaborResource")

    # Labour resource is quantified in terms of time.
    quantity = ifcopenshell.api.resource.add_resource_quantity(model,
        resource=labour, ifc_class="IfcQuantityTime")

    # Store the unit time used in hours
    ifcopenshell.api.resource.edit_resource_quantity(model,
        physical_quantity=quantity, attributes={"TimeValue": 8.0})

    # Let's imagine we've used the resource for 10 days with a
    # utilisation of 200%.
    time = ifcopenshell.api.resource.add_resource_time(model, resource=labour)
    ifcopenshell.api.resource.edit_resource_time(model,
        resource_time=time, attributes={"ScheduleWork": "PT80H", "ScheduleUsage": 2})

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Let's create a construction task. Note that the predefined type is
    # important to distinguish types of tasks.
    task = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Foundations", identification="A")

    # Assign our resource to the task.
    ifcopenshell.api.sequence.assign_process(model, relating_process=task, related_object=labour)

    # Now we can calculate the task duration based on the resource. This
    # will set task.TaskTime.ScheduleDuration to be P5D.
    ifcopenshell.api.sequence.calculate_task_duration(model, task=task)

#### cascade_schedule
Cascades start and end dates of tasks based on durations

Given a start task with a start date and duration, the end date, and the
start and end of all successor tasks with durations may be automatically
computed.

Using this automatic computation is recommended is an alternative to
manually specifying dates. It is useful for doing edits and cascading
changes.

Dates can only cascade from predecessor to successors, not backwards.
Cyclical relationships are invalid and will result in a recursion error
being raised.

Note that there may be differences between how different planning
software calculate start and end dates. Some may consider Monday 5pm to
be equivalent to be Tuesday 8am, for instance.

:param task: The start task to begin cascading from.
:return: None

Example:

.. code:: python

    # Define a convenience function to add a task chained to a predecessor
    def add_task(model, name, predecessor, work_schedule):
        # Add a construction task
        task = ifcopenshell.api.sequence.add_task(model,
            work_schedule=work_schedule, name=name, predefined_type="CONSTRUCTION")

        # Give it a time
        task_time = ifcopenshell.api.sequence.add_task_time(model, task=task)

        # Arbitrarily set the task's scheduled time duration to be 1 week
        ifcopenshell.api.sequence.edit_task_time(model, task_time=task_time,
            attributes={"ScheduleStart": datetime.date(2000, 1, 1), "ScheduleDuration": "P1W"})

        # If a predecessor exists, create a finish to start relationship
        if predecessor:
            ifcopenshell.api.sequence.assign_sequence(model,
                relating_process=predecessor, related_process=task)

        return task

    # Open an existing IFC4 model you have of a building
    model = ifcopenshell.open("/path/to/existing/model.ifc")

    # Create a new construction schedule
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction")

    # Let's imagine a starting task for site establishment.
    task = add_task(model, "Site establishment", None, schedule)
    start_task = task

    # Get all our storeys sorted by elevation ascending.
    storeys = sorted(model.by_type("IfcBuildingStorey"), key=lambda s: get_storey_elevation(s))

    # For each storey ...
    for storey in storeys:

        # Add a construction task to construct that storey, using our convenience function
        task = add_task(model, f"Construct {storey.Name}", task, schedule)

        # Assign all the products in that storey to the task as construction outputs.
        for product in get_decomposition(storey):
            ifcopenshell.api.sequence.assign_product(model, relating_product=product, related_object=task)

    # Ask the computer to calculate all the dates for us from the start task.
    # For example, if the first task started on the 1st of January and took a
    # week, the next task will start on the 8th of January. This saves us
    # manually doing date calculations.
    ifcopenshell.api.sequence.cascade_schedule(model, task=start_task)

    # Calculate the critical path and floats.
    ifcopenshell.api.sequence.recalculate_schedule(model, work_schedule=schedule)

#### copy_work_schedule
Copy a work schedule.

:param work_schedule: IfcWorkSchedule to copy.
:return: The duplicated IfcWorkSchedule entity.

Example:

.. code:: python

    work_plan = ifcopenshell.api.sequence.add_work_plan(model, name="Construction")
    schedule = ifcopenshell.api.sequence.add_work_schedule(model,
        name="Construction Schedule A", work_plan=work_plan)
    new_schedule = ifcopenshell.api.sequence.copy_work_schedule(model, schedule)

#### create_baseline
Creates a baseline for your Work Schedule

Using a IfcWorkSchdule having PredefinedType=PLANNED,
We can create a baseline for our work schedule. This IfcWorkSchedule will have PredefinedType=BASELINE
and the IfcWorkSchedule.CreationDate indicating the date of the baseline creation, and IfcWorkSchedule.Name indicating the name of the baseline.

The following relationships are also baselined:

* Same Tasks & attributes
* Same Task Relationships
* Same Construction Resources
* Same Resource Relationships

:param work_schedule: The planned work_schedule to baseline
:param name: baseline work schedule name
:return: The baseline work_schedule

Example:

.. code:: python

    # We have a Work Schedule
    planned_work_schedule = WorkSchedule(name="Design new feature",predefinedType="PLANNED", deadline="2023-03-01")

    # And now we have a baseline for our Work Schedule
    baseline_work_schedule = ifcopenshell.api.sequence.create_baseline(file, work_schedule=planned_work_schedule, name="Baseline 1")

#### duplicate_task
Duplicates a task in the project

The following relationships are also duplicated:

* The copy will have the same attributes and property sets as the original task
* The copy will be assigned to the parent task or work schedule
* The copy will have duplicated nested tasks

:param task: The task to be duplicated
:return: A tuple that consists of two lists of tasks:

    - Original task and it's nested tasks.
    - Their corresponding duplicated tasks.

Example:
.. code:: python

    # We have a task
    original_task = ifcopenshell.api.sequence.add_task(
        model, work_schedule=work_schedule,
        name="Design new feature",
    )

    # And now we have two
    original_tasks, duplicated_tasks = ifcopenshell.api.sequence.duplicate_task(original_task)
    print(duplicated_tasks[0])  # A copy of ``original_task``.

#### edit_lag_time
Edits the attributes of an IfcLagTime

For more information about the attributes and data types of an
IfcLagTime, consult the IFC documentation.

:param lag_time: The IfcLagTime entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Let's imagine a root construction task
    construction = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Construction", identification="C")

    # Let's imagine we're doing a typically formwork, reinforcement,
    # pour sequence. Let's start with the formwork. It'll take us 2
    # days.
    formwork = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Formwork", identification="C.1")
    time = ifcopenshell.api.sequence.add_task_time(model, task=formwork)
    ifcopenshell.api.sequence.edit_task_time(model,
        task_time=time, attributes={"ScheduleStart": "2000-01-01", "ScheduleDuration": "P2D"})

    # Now let's do the reinforcement. It'll take us another 2 days.
    reinforcement = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Reinforcement", identification="C.2")
    time = ifcopenshell.api.sequence.add_task_time(model, task=reinforcement)
    ifcopenshell.api.sequence.edit_task_time(model,
        task_time=time, attributes={"ScheduleStart": "2000-01-01", "ScheduleDuration": "P2D"})

    # Now let's say the formwork must finish before the reinforcement
    # can start. This is a typical finish to start relationship (FS).
    sequence = ifcopenshell.api.sequence.assign_sequence(model,
        relating_process=formwork, related_process=reinforcement)

    # Now typically there would be no lag time between formwork and
    # reinforcement, but let's pretend that we had to allow 1 day gap
    # for whatever reason.
    lag = ifcopenshell.api.sequence.assign_lag_time(model, rel_sequence=sequence, lag_value="P1D")

    # Or, let's make it 2 days instead.
    ifcopenshell.api.sequence.edit_lag_time(model, lag_time=lag, attributes={"LagValue": "P2D"})

#### edit_recurrence_pattern
Edits the attributes of an IfcRecurrencePattern

For more information about the attributes and data types of an
IfcRecurrencePattern, consult the IFC documentation.

:param recurrence_pattern: The IfcRecurrencePattern entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Let's create a new calendar.
    calendar = ifcopenshell.api.sequence.add_work_calendar(model)

    # Let's start defining the times that we work during the week.
    work_time = ifcopenshell.api.sequence.add_work_time(model,
        work_calendar=calendar, time_type="WorkingTimes")

    # We create a weekly recurrence
    pattern = ifcopenshell.api.sequence.assign_recurrence_pattern(model,
        parent=work_time, recurrence_type="WEEKLY")

    # State that we work from weekdays 1 to 5 (i.e. Monday to Friday)
    ifcopenshell.api.sequence.edit_recurrence_pattern(model,
        recurrence_pattern=pattern, attributes={"WeekdayComponent": [1, 2, 3, 4, 5]})

#### edit_sequence
Edits the attributes of an IfcRelSequence

For more information about the attributes and data types of an
IfcRelSequence, consult the IFC documentation.

:param rel_sequence: The IfcRelSequence entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Let's imagine a root construction task
    construction = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Construction", identification="C")

    # Let's imagine we're building 2 zones, one after another.
    zone1 = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Zone 1", identification="C.1")
    zone2 = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Zone 2", identification="C.2")

    # Zone 1 finishes, then zone 2 starts.
    sequence = ifcopenshell.api.sequence.assign_sequence(model,
        relating_process=zone1, related_process=zone2)

    # What if they both started at the same time?
    ifcopenshell.api.sequence.edit_sequence(model,
        rel_sequence=sequence, attributes={"SequenceType": "START_START"})

#### edit_task
Edits the attributes of an IfcTask

For more information about the attributes and data types of an
IfcTask, consult the IFC documentation.

:param task: The IfcTask entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Add a root task to represent the design milestones, and major
    # project phases.
    task = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Milestones", identification="A")

    # Change the identification
    ifcopenshell.api.sequence.edit_task(model, task=task, attributes={"Identification": "M"})

#### edit_task_time
Edits the attributes of an IfcTaskTime

For more information about the attributes and data types of an
IfcTaskTime, consult the IFC documentation.

:param task_time: The IfcTaskTime entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Create a task to do formwork
    task = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Formwork", identification="A")

    # Let's say it takes 2 days and starts on the 1st of January, 2000
    time = ifcopenshell.api.sequence.add_task_time(model, task=formwork)
    ifcopenshell.api.sequence.edit_task_time(model,
        task_time=time, attributes={"ScheduleStart": "2000-01-01", "ScheduleDuration": "P2D"})

#### edit_work_calendar
Edits the attributes of an IfcWorkCalendar

For more information about the attributes and data types of an
IfcWorkCalendar, consult the IFC documentation.

:param work_calendar: The IfcWorkCalendar entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Let's create a new calendar.
    calendar = ifcopenshell.api.sequence.add_work_calendar(model, name="5 Day Week")

    # Let's give it a description
    ifcopenshell.api.sequence.edit_work_calendar(model,
        work_calendar=calendar, attributes={"Description": "Monday to Friday 8 hour days"})

#### edit_work_plan
Edits the attributes of an IfcWorkPlan

For more information about the attributes and data types of an
IfcWorkPlan, consult the IFC documentation.

:param work_plan: The IfcWorkPlan entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # This will hold all our construction schedules
    work_plan = ifcopenshell.api.sequence.add_work_plan(model, name="Construction")

    # Let's give it a description
    ifcopenshell.api.sequence.edit_work_plan(model,
        work_plan=work_plan, attributes={"Description": "Construction of phase 1"})

#### edit_work_schedule
Edits the attributes of an IfcWorkSchedule

For more information about the attributes and data types of an
IfcWorkSchedule, consult the IFC documentation.

:param work_schedule: The IfcWorkSchedule entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # This will hold all our construction schedules
    work_plan = ifcopenshell.api.sequence.add_work_plan(model, name="Construction")

    # Let's imagine this is one of our schedules in our work plan.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model,
        name="Construction Schedule A", work_plan=work_plan)

    # Let's give it a description
    ifcopenshell.api.sequence.edit_work_schedule(model,
        work_schedule=work_schedule, attributes={"Description": "3 crane design option"})

#### edit_work_time
Edits the attributes of an IfcWorkTime

For more information about the attributes and data types of an
IfcWorkTime, consult the IFC documentation.

:param work_time: The IfcWorkTime entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Let's create a new calendar.
    calendar = ifcopenshell.api.sequence.add_work_calendar(model)

    # Let's start defining the times that we work during the week.
    work_time = ifcopenshell.api.sequence.add_work_time(model,
        work_calendar=calendar, time_type="WorkingTimes")

    # If we don't specify any recurring time periods in our work time,
    # we need to specify a start and end date of the work time. It
    # starts at 0:00 on the start date and 24:00 at the end date.
    ifcopenshell.api.sequence.edit_work_time(model,
        work_time=work_time, attributes={"StartDate": "2000-01-01", "FinishDate": "2000-01-02"})

#### recalculate_schedule
Calculate the critical path and floats for a work schedule

This implements critical path analysis, using the forward pass and
backward pass method. When run, any tasks that have no float will be
marked as critical, and both the total and free floats will be
populated for all task times.

Cyclical relationships are detected and will result in a recursion
error.

:param work_schedule: The IfcWorkSchedule to perform the calculation on.
:return: None

Example:

.. code:: python

    # See the example for ifcopenshell.api.sequence.cascade_schedule for
    # details of how to set up a basic set of tasks and calculate the
    # critical path. Typically cascade_schedule is run prior to ensure
    # that dates are correct.

#### remove_task
Removes a task

All subtasks are also removed recursively. Any relationships such as
sequences or controls are also removed.

:param task: The IfcTask to remove.
:return: None

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Add a root task to represent the design milestones, and major
    # project phases.
    ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Milestones", identification="A")
    design = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Design", identification="B")
    ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Construction", identification="C")

    # Ah, let's delete the design section, who needs it anyway we'll
    # just fix it on site.
    ifcopenshell.api.sequence.remove_task(model, task=design)

#### remove_time_period
Removes a time period

:param time_period: The IfcTimePeriod to remove.
:return: None

Example:

.. code:: python

    # Let's create a new calendar.
    calendar = ifcopenshell.api.sequence.add_work_calendar(model)

    # Let's start defining the times that we work during the week.
    work_time = ifcopenshell.api.sequence.add_work_time(model,
        work_calendar=calendar, time_type="WorkingTimes")

    # We create a weekly recurrence
    pattern = ifcopenshell.api.sequence.assign_recurrence_pattern(model,
        parent=work_time, recurrence_type="WEEKLY")

    # State that we work from weekdays 1 to 5 (i.e. Monday to Friday)
    ifcopenshell.api.sequence.edit_recurrence_pattern(model,
        recurrence_pattern=pattern, attributes={"WeekdayComponent": [1, 2, 3, 4, 5]})

    # The morning work session, lunch, then the afternoon work session.
    morning = ifcopenshell.api.sequence.add_time_period(model,
        recurrence_pattern=pattern, start_time="09:00", end_time="12:00")
    afternoon = ifcopenshell.api.sequence.add_time_period(model,
        recurrence_pattern=pattern, start_time="13:00", end_time="17:00")

    # Let's take the afternoon off!
    ifcopenshell.api.sequence.remove_time_period(model, time_period=afternoon)

#### remove_work_calendar
Removes a work calendar

All relationships are also removed, such as if a task is set to use that
calendar.

:param work_calendar: The IfcWorkCalendar to remove
:return: None

Example:

.. code:: python

    # Let's create a new calendar.
    calendar = ifcopenshell.api.sequence.add_work_calendar(model, name="5 Day Week")

    # And remove it immediately
    ifcopenshell.api.sequence.remove_work_calendar(model, work_calendar=calendar)

#### remove_work_plan
Removes a work plan

Note that schedules that are grouped under the work plan are not
removed.

:param work_plan: The IfcWorkPlan to remove.
:return: None

Example:

.. code:: python

    # This will hold all our construction schedules
    work_plan = ifcopenshell.api.sequence.add_work_plan(model, name="Construction")

    # And remove it immediately
    ifcopenshell.api.sequence.remove_work_plan(model, work_plan=work_plan)

#### remove_work_schedule
Removes a work schedule

All tasks in the work schedule are also removed recursively.

:param work_schedule: The IfcWorkSchedule to remove.
:return: None

Example:

.. code:: python

    # This will hold all our construction schedules
    work_plan = ifcopenshell.api.sequence.add_work_plan(model, name="Construction")

    # Let's imagine this is one of our schedules in our work plan.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model,
        name="Construction Schedule A", work_plan=work_plan)

    # And remove it immediately
    ifcopenshell.api.sequence.remove_work_schedule(model, work_schedule=schedule)

#### remove_work_time
Removes a work time

:param work_time: The IfcWorkTime to remove.
:return: None

Example:

.. code:: python

    # Let's create a new calendar.
    calendar = ifcopenshell.api.sequence.add_work_calendar(model)

    # Let's start defining the times that we work during the week.
    work_time = ifcopenshell.api.sequence.add_work_time(model,
        work_calendar=calendar, time_type="WorkingTimes")

    # And remove it immediately
    ifcopenshell.api.sequence.remove_work_time(model, work_time=work_time)

#### unassign_lag_time
Removes any lag time in a sequence

The schedule is cascaded afterwards.

:param rel_sequence: The sequence to remove the lag time from.
:return: None

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Let's imagine a root construction task
    construction = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Construction", identification="C")

    # Let's imagine we're building 2 zones, one after another.
    zone1 = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Zone 1", identification="C.1")
    zone2 = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Zone 2", identification="C.2")

    # Zone 1 finishes, then zone 2 starts.
    sequence = ifcopenshell.api.sequence.assign_sequence(model,
        relating_process=zone1, related_process=zone2)

    # What if you had to wait 1 week before you could start zone 2?
    ifcopenshell.api.sequence.assign_lag_time(model, rel_sequence=sequence, lag_value="P1W")

    # What if you didn't?
    ifcopenshell.api.sequence.unassign_lag_time(model, rel_sequence=sequence)

#### unassign_process
Unassigns a process and object relationship

See ifcopenshell.api.sequence.assign_process for details.

:param relating_process: The IfcTask in the relationship.
:param related_object: The related object.
:return: None

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Let's create a construction task. Note that the predefined type is
    # important to distinguish types of tasks.
    task = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Demolish existing", identification="A", predefined_type="DEMOLITION")

    # Let's say we have a wall somewhere.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # Let's demolish that wall!
    ifcopenshell.api.sequence.assign_process(model, relating_process=task, related_object=wall)

    # Change our mind.
    ifcopenshell.api.sequence.unassign_process(model, relating_process=task, related_object=wall)

#### unassign_product
Unassigns a product and object relationship

See ifcopenshell.api.sequence.assign_product for details.

:param relating_product: The IfcProduct in the relationship.
:param related_object: The IfcTask in the relationship.
:return: None

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Let's create a construction task. Note that the predefined type is
    # important to distinguish types of tasks.
    task = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Build wall", identification="A", predefined_type="CONSTRUCTION")

    # Let's say we have a wall somewhere.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # Let's construct that wall!
    ifcopenshell.api.sequence.assign_product(relating_product=wall, related_object=task)

    # Change our mind.
    ifcopenshell.api.sequence.unassign_product(relating_product=wall, related_object=task)

#### unassign_recurrence_pattern
Unassigns a recurrence pattern

Note that a recurring task time must have a recurrence pattern, so if
you remove it, be sure to clean up after this API call
(e.g. remove IfcTaskTimeRecurring entity
or assign a different recurrence patern to it
or replace IfcTaskTimeRecurring with IfcTaskTime).

:param recurrence_pattern: The IfcRecurrencePattern to remove.
:return: None

Example:

.. code:: python

    # Let's create a new calendar.
    calendar = ifcopenshell.api.sequence.add_work_calendar(model)

    # Let's start defining the times that we work during the week.
    work_time = ifcopenshell.api.sequence.add_work_time(model,
        work_calendar=calendar, time_type="WorkingTimes")

    # We create a weekly recurrence
    pattern = ifcopenshell.api.sequence.assign_recurrence_pattern(model,
        parent=work_time, recurrence_type="WEEKLY")

    # Change our mind, let's just maintain it whenever we feel like it.
    ifcopenshell.api.sequence.unassign_recurrence_pattern(recurrence_pattern=pattern)

#### unassign_sequence
Removes a sequence relationship between tasks

:param relating_process: The previous / predecessor task.
:param related_process: The next / successor task.
:return: None

Example:

.. code:: python

    # Let's imagine we are creating a construction schedule. All tasks
    # need to be part of a work schedule.
    schedule = ifcopenshell.api.sequence.add_work_schedule(model, name="Construction Schedule A")

    # Let's imagine a root construction task
    construction = ifcopenshell.api.sequence.add_task(model,
        work_schedule=schedule, name="Construction", identification="C")

    # Let's imagine we're building 2 zones, one after another.
    zone1 = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Zone 1", identification="C.1")
    zone2 = ifcopenshell.api.sequence.add_task(model,
        parent_task=construction, name="Zone 2", identification="C.2")

    # Zone 1 finishes, then zone 2 starts.
    ifcopenshell.api.sequence.assign_sequence(model, relating_process=zone1, related_process=zone2)

    # Let's make them unrelated
    ifcopenshell.api.sequence.unassign_sequence(model,
        relating_process=zone1, related_process=zone2)

## Module: spatial

### Description
Assign spatial relationships such as when an element is in a space

Physical elements (walls, doors, etc) may be contained in or reference spatial
elements (spaces, storeys, buildings, etc).

### Available Functions
- assign_container
- dereference_structure
- reference_structure
- unassign_container

### Function Docstrings
#### assign_container
Assigns products to be contained hierarchically in a space

All physical IFC model elements must be part of a hierarchical tree
called the "spatial decomposition", where large things are made up of
smaller things. This tree always begins at an "IfcProject" and is then
broken down using "decomposition" relationships, of which aggregation is
the first relationship you will use. See
ifcopenshell.api.aggregate.assign_object for more details about
aggregation.

The IfcProject will be "decomposed" into spatial structure elements.
These are virtual spaces like stes, buildings, storeys, and spaces (i.e.
rooms). You can't physically touch these spaces, but you can touch the
products contained within these spaces.

To state that a product is contained in a space, you will use a
"containment" relationship. Containment is a very common relationship
used to create the hierarchical spatial decomposition tree. For example,
you might say that "This wall is on the third building storey", or "this
table is in the living room space".

The distinguishing factor between aggregation and containment is that
aggregation occurs between objects of the same type (e.g. a large space
is made up of smaller spaces), whereas containment is between two
different types: explicitly saying that a physical product exists within
a virtual space.

Containment is critical in construction management, to know which
objects are in which spaces, as often you would divide your construction
schedule into storey by storey, or zone by zone. Containment is also
critical in facility management, as it indicates through which space
equipment may be accessed for maintenance purposes.

As a product may only have a single location in the "spatial
decomposition" tree, assigning an aggregate relationship will remove any
previous aggregation, containment, or nesting relationships it may have.

:param products: A list of physical IfcElements existing in the space.
:param relating_structure: The IfcSpatialStructureElement element, such
    as IfcBuilding, IfcBuildingStorey, or IfcSpace that the element
    exists in.
:return: The IfcRelContainedInSpatialStructure relationship instance
    or `None` if `products` was empty list.

Example:

.. code:: python

    project = ifcopenshell.api.root.create_entity(model, ifc_class="IfcProject")
    site = ifcopenshell.api.root.create_entity(model, ifc_class="IfcSite")
    building = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuilding")
    storey = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuildingStorey")
    space = ifcopenshell.api.root.create_entity(model, ifc_class="IfcSpace")

    # The project contains a site (note that project aggregation is a special case in IFC)
    ifcopenshell.api.aggregate.assign_object(model, products=[site], relating_object=project)

    # The site has a building, the building has a storey, and the storey has a space
    ifcopenshell.api.aggregate.assign_object(model, products=[building], relating_object=site)
    ifcopenshell.api.aggregate.assign_object(model, products=[storey], relating_object=building)
    ifcopenshell.api.aggregate.assign_object(model, products=[space], relating_object=storey)

    # Create a wall and furniture
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")
    furniture = ifcopenshell.api.root.create_entity(model, ifc_class="IfcFurniture")

    # The wall is in the storey, and the furniture is in the space
    ifcopenshell.api.spatial.assign_container(model, products=[wall], relating_structure=storey)
    ifcopenshell.api.spatial.assign_container(model, products=[furniture], relating_structure=space)

#### dereference_structure
Dereferences a list of products and space

:param products: The list of physical IfcElements that exists in the space.
:param relating_structure: The IfcSpatialStructureElement element, such
    as IfcBuilding, IfcBuildingStorey, or IfcSpace that the element
    exists in.
:return: None

Example:

.. code:: python

    project = ifcopenshell.api.root.create_entity(model, ifc_class="IfcProject")
    site = ifcopenshell.api.root.create_entity(model, ifc_class="IfcSite")
    building = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuilding")
    storey1 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuildingStorey")
    storey2 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuildingStorey")
    storey3 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuildingStorey")

    # The project contains a site (note that project aggregation is a special case in IFC)
    ifcopenshell.api.aggregate.assign_object(model, products=[site], relating_object=project)

    # The site has a building, the building has a storey, and the storey has a space
    ifcopenshell.api.aggregate.assign_object(model, products=[building], relating_object=site)
    ifcopenshell.api.aggregate.assign_object(model, products=[storey], relating_object=building)
    ifcopenshell.api.aggregate.assign_object(model, products=[space], relating_object=storey)

    # Create a column, this column spans 3 storeys
    column = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # The column is contained in the lowermost storey
    ifcopenshell.api.spatial.assign_container(model, products=[column], relating_structure=storey1)

    # And referenced in the others
    ifcopenshell.api.spatial.reference_structure(model, products=[column], relating_structure=storey2)
    ifcopenshell.api.spatial.reference_structure(model, products=[column], relating_structure=storey3)

    # Actually, it only goes up to storey 2.
    ifcopenshell.api.spatial.dereference_structure(model, products=[column], relating_structure=storey3)

#### reference_structure
Denote that a list products is related to a list of spatial structures

This is similar to ifcopenshell.api.spatial.assign_container, except
that containment can only occur between a product and a single spatial
structure element. This is fine if a wall is on level 1, but not
appropriate if you have a multistorey column on multiple levels, or a
door with a to and from space, or a stair going from one floor to
another floor. This is where spatial referencing is used.

Typically, the product will be contained in the lowermost, constructed
first, or primarily accessible space. For a multistorey column or stair,
the column or stair will therefore be contained in the lowermost storey.
Then, any other storeys will be referenced.

Referencing is non-hierarchical, so a door may be referenced in multiple
spaces simultaneously.

:param products: The list of physical IfcElements that exists in the space.
:param relating_structure: The IfcSpatialStructureElement element, such
    as IfcBuilding, IfcBuildingStorey, or IfcSpace that the element
    exists in.
:return: The IfcRelReferencedInSpatialStructure relationship instance
    or `None` if `products` was an empty list.

Example:

.. code:: python

    project = ifcopenshell.api.root.create_entity(model, ifc_class="IfcProject")
    site = ifcopenshell.api.root.create_entity(model, ifc_class="IfcSite")
    building = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuilding")
    storey1 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuildingStorey")
    storey2 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuildingStorey")
    storey3 = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuildingStorey")

    # The project contains a site (note that project aggregation is a special case in IFC)
    ifcopenshell.api.aggregate.assign_object(model, products=[site], relating_object=project)

    # The site has a building, the building has a storey, and the storey has a space
    ifcopenshell.api.aggregate.assign_object(model, products=[building], relating_object=site)
    ifcopenshell.api.aggregate.assign_object(model, products=[storey], relating_object=building)
    ifcopenshell.api.aggregate.assign_object(model, products=[space], relating_object=storey)

    # Create a column, this column spans 3 storeys
    column = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # The column is contained in the lowermost storey
    ifcopenshell.api.spatial.assign_container(model, products=[column], relating_structure=storey1)

    # And referenced in the others
    ifcopenshell.api.spatial.reference_structure(
        model, products=[column], relating_structure=[storey2, storey3]
    )

#### unassign_container
Unassigns a container from products.

:param product: A list of IfcProducts to remove the containment from.
:return: None

Example:

.. code:: python

    project = ifcopenshell.api.root.create_entity(model, ifc_class="IfcProject")
    site = ifcopenshell.api.root.create_entity(model, ifc_class="IfcSite")
    building = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuilding")
    storey = ifcopenshell.api.root.create_entity(model, ifc_class="IfcBuildingStorey")

    # The project contains a site (note that project aggregation is a special case in IFC)
    ifcopenshell.api.aggregate.assign_object(model, products=[site], relating_object=project)

    # The site has a building, the building has a storey, and the storey has a space
    ifcopenshell.api.aggregate.assign_object(model, products=[building], relating_object=site)
    ifcopenshell.api.aggregate.assign_object(model, products=[storey], relating_object=building)

    # Create a wall
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # The wall is in the storey
    ifcopenshell.api.spatial.assign_container(model, products=[wall], relating_structure=storey)

    # Not anymore!
    ifcopenshell.api.spatial.unassign_container(model, products=[wall])

## Module: structural

### Description
Manage analytical properties for structural simulation

This only handles authoring the analytical model, and does not actually perform
any structural simulation. To perform the simulation, see IFC2CA.

### Available Functions
- add_structural_activity
- add_structural_analysis_model
- add_structural_boundary_condition
- add_structural_load
- add_structural_load_case
- add_structural_load_group
- add_structural_member_connection
- assign_structural_analysis_model
- edit_structural_analysis_model
- edit_structural_boundary_condition
- edit_structural_connection_cs
- edit_structural_item_axis
- edit_structural_load
- edit_structural_load_case
- remove_structural_analysis_model
- remove_structural_boundary_condition
- remove_structural_connection_condition
- remove_structural_load
- remove_structural_load_case
- remove_structural_load_group
- unassign_structural_analysis_model

### Function Docstrings
#### add_structural_activity
Adds a new structural activity

A structural activity is either a structural action or a reaction. It
may be applied to a point, a curve, or a planar surface, and may be a
constant load, linear, etc.

The activity must be defined using an applied load, and associated with
a structural member.

:param ifc_class: Choose from any subtype of IfcStructuralActivity.
:param predefined_type: View the IFC documentation for what valid
    predefined types may be chosen.
:param global_or_local: The location coordinates of the load is always
    defined locally relative to the structural member the activity is
    assigned to. However, the directions of the applied load may either
    be specified globally or locally depending on how this argument is
    set. Choose from GLOBAL_COORDS or LOCAL_COORDS.
:param applied_load: The IfcStructuralLoad that is applied in this
    activity.
:param structural_member: The IfcStructuralMember that the load is
    applied to.
:return: The newly created entity based on the ifc_class

#### add_structural_analysis_model
Add a new structural analysis model

A structural analysis model is a group of all the loads, reactions,
structural members, and structural connections required to describe a
structural analysis model.

A 3D analytical model is assumed.

:return: The newly created IfcStructuralAnalysisModel

Example:

.. code:: python

    # Create a fresh blank structural analysis
    analysis = ifcopenshell.api.structural.add_structural_analysis_model(model)

#### add_structural_boundary_condition
Adds a new structural boundary condition to a structural connection

The type of boundary condition depends on the connection. Point
connections will have a node condition, curve connections will have an
edge condition, and surface connections will have a face condition.

:param name: The name of the boundary condition.
:param connection: The IfcStructuralConnection to apply the boundary
    condition to. This will determine the type of condition that is
    created. If no connection is supplied, an orphan boundary condition
    will be created using the ifc_class that you specify.
:param ifc_class: The class of IfcBoundaryCondition to create, only
    relevant if you do not specify a connection and want to create an
    orphaned boundary condition.
:return: The newly created IfcBoundaryCondition

Example:

.. code:: python

    ifcopenshell.api.structural.add_structural_boundary_condition(model, connection=connection)

#### add_structural_load
Adds a new structural load

Structural loads may be actions or reactions. A simple load might be a
static and be linear, planar, or a single point. Alternatively, loads
may be defined as a configuration of multiple loads.

:param name: The name of the load
:param ifc_class: The subtype of IfcStructuralLoad to create. Consult
    the IFC documentation to see all the types of loads.
:return: The newly created load entity, depending on the ifc_class
    specified.

Example:

.. code:: python

    # Create a simple linear load
    ifcopenshell.api.structural.add_structural_load(model)

#### add_structural_load_case
Adds a new load case, which is a collection of related load groups

:param name: The name of the load case
:param action_type: Choose from EXTRAORDINARY_A, PERMANENT_G,
    or VARIABLE_Q, taken from the Eurocode standard.
:param action_source: The source of the load case, such as DEAD_LOAD_G,
    LIVE_LOAD_Q, TRANSPORT, ICE, etc. For the full list consult
    IfcActionSourceTypeEnum in the IFC documentation.
:return: The new IfcStructuralLoadCase

#### add_structural_load_group
Adds a new load group, which is a collection of related loads

:param name: The name of the load group
:param action_type: Choose from EXTRAORDINARY_A, PERMANENT_G,
    or VARIABLE_Q, taken from the Eurocode standard.
:param action_source: The source of the load case, such as DEAD_LOAD_G,
    LIVE_LOAD_Q, TRANSPORT, ICE, etc. For the full list consult
    IfcActionSourceTypeEnum in the IFC documentation.
:return: The new IfcStructuralLoadCase

#### add_structural_member_connection
Relates a structural member and a structural connection

:param relating_structural_member: The IfcStructuralMember to have a
    connection added to it.
:param related_structural_connection: The IfcStructuralConnection to add
    to the IfcStructuralMember.
:return: The IfcRelConnectsStructuralMember relationship

#### assign_structural_analysis_model
Assigns a load or structural member to an analysis model

:param products: The structural elements that is part of the analysis.
:param structural_analysis_model: The IfcStructuralAnalysisModel that
    the structural element is related to.
:return: The IfcRelAssignsToGroup relationship

#### edit_structural_analysis_model
Edits the attributes of an IfcStructuralAnalysisModel

For more information about the attributes and data types of an
IfcStructuralAnalysisModel, consult the IFC documentation.

:param structural_analysis_model: The IfcStructuralAnalysisModel entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

#### edit_structural_boundary_condition
Edits the attributes of an IfcBoundaryCondition

For more information about the attributes and data types of an
IfcBoundaryCondition, consult the IFC documentation.

:param condition: The IfcBoundaryCondition entity you want to edit
:param attributes: a dictionary of attribute names and values.
    Each value is represented by a dictionary.
:return: None

#### edit_structural_connection_cs
Edits the coordinate system of a structural connection

:param structural_item: The IfcStructuralItem you want to modify.
:param axis: The unit Z axis vector defined as a list of 3 floats.
    Defaults to (0., 0., 1.).
:param ref_direction: The unit X axis vector defined as a list of 3
    floats. Defaults to (1., 0., 0.).
:return: None

#### edit_structural_item_axis
Edits the coordinate system of a structural connection

:param structural_item: The IfcStructuralItem you want to modify.
:param axis: The unit Z axis vector defined as a list of 3 floats.
    Defaults to (0., 0., 1.).
:return: None

#### edit_structural_load
Edits the attributes of an IfcStructuralLoad

For more information about the attributes and data types of an
IfcStructuralLoad, consult the IFC documentation.

:param structural_load: The IfcStructuralLoad entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

#### edit_structural_load_case
Edits the attributes of an IfcStructuralLoadCase

For more information about the attributes and data types of an
IfcStructuralLoadCase, consult the IFC documentation.

:param load_case: The IfcStructuralLoadCase entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

#### remove_structural_analysis_model
Removes an analysis model

Note that the contents of an analysis model are currently preserved.

:param structural_analysis_model: The IfcStructuralAnalysisModel to
    remove.
:return: None

#### remove_structural_boundary_condition
Removes a condition from a connection, or an orphaned boundary condition

:param connection: The IfcStructuralConnection to remove the condition
    from. If omitted, it is assumed to be an orphaned condition.
:param boundary_condition: The IfcBoundaryCondition to remove.
:return: None

#### remove_structural_connection_condition
Removes a relationship between a connection and a condition

The condition and the member itself is preserved.

:param relation: The IfcRelConnectsStructuralMember to remove.
:return: None

#### remove_structural_load
Removes a structural load

:param structural_load: The IfcStructuralLoad to remove.
:return: None

#### remove_structural_load_case
Removes a structural load case

:param load_case: The IfcStructuralLoadCase to remove.
:return: None

#### remove_structural_load_group
Removes a structural load group

:param load_group: The IfcStructuralLoadGroup to remove.
:return: None

#### unassign_structural_analysis_model
Removes a relationship between a structural element and the analysis model

:param products: The structural elements that is part of the analysis.
:param structural_analysis_model: The IfcStructuralAnalysisModel that
    the structural element is related to.
:return: None

## Module: style

### Description
Manage visual styles of geometry (colours, transparency, rendering, etc)

Geometry may have visual styles associated with it, including surface styles,
2D curve styles, text styles, and more. Surface styles are most commonly used
for simple colouring.

### Available Functions
- add_style
- add_surface_style
- add_surface_textures
- assign_item_style
- assign_material_style
- assign_representation_styles
- edit_presentation_style
- edit_surface_style
- remove_style
- remove_styled_representation
- remove_surface_style
- unassign_material_style
- unassign_representation_styles

### Function Docstrings
#### add_style
Add a new presentation style

A presentation style is a container of visual settings (called
presentation items) that affect the appearance of objects. There are
four types of style:

- Surface styles, which give 3D objects (which have surfaces / faces)
  their colours and textures. This is the most common type of style.
- Curve styles, which give 2D and 3D curves, lines, polylines, their
  stroke thickness and colour.
- Fill area styles, which gives 2D polygons and flat 3D planes their
  colours, hatch patterns, tiled patterns, and pattern scales.
- Text styles, which gives text their font family, weight, variant,
  size, indentation, alignment, decoration, spacing, and transformation.

Once you have created a presentation style object, you can further
define the properties of your style using other API functions by adding
presentation items, such as ifcopenshell.api.style.add_surface_style.

:param name: The name of the style. Used to easily identify it using a
    style library.
:param ifc_class: Choose from IfcSurfaceStyle, IfcCurveStyle,
    IfcFillAreaStyle, or IfcTextStyle.
:return: The newly created style element, based on the provided
    ifc_class.

Example:

.. code:: python

    # Create a new surface style
    style = ifcopenshell.api.style.add_style(model)

#### add_surface_style
Adds a new presentation item to a surface style

A surface style can have multiple different types of presentation items
assigned to it:

- Shading, this is the simplest item, which defines a single basic
  colour and transparency that can be used to display the object on a
  screen. It is an indicative colour of what the object would be in real
  life. It is commonly incorrectly abused to colour code systems for MEP
  equipment or object types for structural steel. If you just want to
  give something a colour, this is what you need.
- Rendering, this is an advanced extension of shading, which includes
  the definition of a shader for a rendering engine. You may select the
  reflectance / lighting model such as PHYSICAL, for PBR style
  rendering, or FLAT, for flat shading, or PHONG for older biased
  rendering workflows. Based on the chosen lighting model, you may then
  specify the appropriate colour maps, such as diffuse colours,
  specularity, emissive component, etc. These lighting models are fully
  compatible with glTF and X3D. This should be used if your model is
  prepared to be rendered by a rendering engine which is compatible with
  glTF / X3D shader descriptions. If you are doing archviz or 3D
  rendering, this is what you need.
- Textures, this is a special type of Rendering presentation item that
  uses image textures instead of single colours. Textures may be either
  mapped using a bounding box stretch mapping, or with UV coordinates
  for mesh-like geometry.
- Lighting, this is used to define photometrically accurate colour
  parameters used in lighting simulation. If you are a simulationist,
  this is what you need.
- Reflectance, this is a special type of Lighting presentation item
  which includes some lesser used photometric properties, typically
  required for advanced materials like glazing.
- External, this is for any other surface style defined using an
  external URI. This is relevant if you are using a third-party non-glTF
  compatible shader definition such as for Cycles, Renderman, V-Ray,
  etc, or a complex lighting simulation definition, such as for
  Radiance.

Shading is sufficient for the majority of basic models.

The attributes you specify will depend on the type of presentation item
you are adding. An example is shown below, but for full details please
refer to the IFC documentation.

:param style: The IfcSurfaceStyle you want to add to presentation item
    to. See ifcopenshell.api.style.add_style.
:param ifc_class: Choose from IfcSurfaceStyleShading,
    IfcSurfaceStyleRendering, IfcSurfaceStyleWithTextures,
    IfcSurfaceStyleLighting, IfcSurfaceStyleReflectance, or
    IfcExternallyDefinedSurfaceStyle.
:param attributes: a dictionary of attribute names and values.
:return: The newly created presentation item based on the provided
    ifc_class.

Example:

.. code:: python

    # Create a new surface style
    style = ifcopenshell.api.style.add_style(model)

    # Create a simple shading colour and transparency.
    ifcopenshell.api.style.add_surface_style(model,
        style=style, ifc_class="IfcSurfaceStyleShading", attributes={
            "SurfaceColour": { "Name": None, "Red": 1.0, "Green": 0.8, "Blue": 0.8 },
            "Transparency": 0., # 0 is opaque, 1 is transparent
        })

    # Alternatively, create a rendering style.
    ifcopenshell.api.style.add_surface_style(model,
        style=style, ifc_class="IfcSurfaceStyleRendering", attributes={
            # A surface colour and transparency is still supplied for
            # viewport display only. This will supersede the shading
            # presentation item.
            "SurfaceColour": { "Name": None, "Red": 1.0, "Green": 0.8, "Blue": 0.8 },
            "Transparency": 0., # 0 is opaque, 1 is transparent

            # NOTDEFINED is assumed to be a PHYSICAL (PBR) lighting
            # model. In IFC4X3, you may choose PHYSICAL directly.
            "ReflectanceMethod": "NOTDEFINED",

            # For PBR shading, you may specify these parameters:
            "DiffuseColour": { "Name": None, "Red": 0.9, "Green": 0.8, "Blue": 0.8 },
            "SpecularColour": 0.1, # Metallic factor
            "SpecularHighlight": {"SpecularRoughness": 0.5}, # Roughness factor
        })

#### add_surface_textures
Add surface texture based on a Blender material definition or texture data.

Either `material` or `textures` should be provided.

:param material: The Blender material definition with a node tree that
    is compatible with glTF. See one of the valid combinations here:
    https://docs.blender.org/manual/en/dev/addons/import_export/scene_gltf2.html
:param uv_maps: A list of IfcIndexedTextureMap for any
    IfcTessellatedFaceSets that the representation has, obtained from
    the HasTextures attribute.
:param textures: A list of dictionaries containing:

    1. Attributes to create IfcImageTexture.
    2. One additional parameter `uv_mode` to map IfcImageTexture to correct
       IfcTextureCoordinate type.

    Possible `uv_mode` values:

    * `UV` - use IfcTextureCoordinate from `uv_maps` parameter;
    * `Generated` - IfcTextureCoordinateGenerator with mode COORD (autogenerated UV
      based on geometry);
    * `Camera` - IfcTextureCoordinateGenerator with mode COORD_EYE (autogenerated UV
      based on camera position)
:return: A list of IfcImageTexture

#### assign_item_style
Assigns a style directly to a representation item

A style may either be assigned directly to an object's representation
items, or to a material which is then associated with the object. If both
exist, then the style assigned directly to the object's representation
takes precedence. It is recommended to use materials and assign styles to
materials. However, sometimes you may want to assign colours directly to
the object representation as an override. This API function provides that
capability.

If you want to assign styles to a material instead (recommended), then
please see ifcopenshell.api.style.assign_material_style.

:param item: The IfcRepresentationItem of the object
    that you want to assign styles to.
:param style: A presentation style, typically IfcSurfaceStyle. None if you
    want to remove an existing style from the item.
:return: Created or existing IfcStyledItem, or None if the style was removed.

Example:

.. code:: python

    # A model context is needed to store 3D geometry
    model3d = ifcopenshell.api.context.add_context(model, context_type="Model")

    # Specifically, we want to store body geometry
    body = ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Body", target_view="MODEL_VIEW", parent=model3d)

    # Let's create a new block shaped furniture. The furniture does not have any geometry yet.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # Let's use the "3D Body" representation we created earlier to add a
    # new wall-like body geometry, 5 meters long, 3 meters high, and
    # 200mm thick
    representation = ifcopenshell.api.geometry.add_wall_representation(model,
        context=body, length=5, height=3, thickness=0.2)

    # Assign our new body geometry back to our wall
    ifcopenshell.api.geometry.assign_representation(model,
        product=wall, representation=representation)

    # Place our wall at the origin
    ifcopenshell.api.geometry.edit_object_placement(model, product=wall)

    # Create a new surface style
    style = ifcopenshell.api.style.add_style(model)

    # Create a simple grey shading colour and transparency.
    ifcopenshell.api.style.add_surface_style(model,
        style=style, ifc_class="IfcSurfaceStyleShading", attributes={
            "SurfaceColour": { "Name": None, "Red": 0.5, "Green": 0.5, "Blue": 0.5 },
            "Transparency": 0., # 0 is opaque, 1 is transparent
        })

    # Now specifically our wall's only item only will be coloured grey.
    ifcopenshell.api.style.assign_item_style(model,
        style=style, item=representation.Items[0])

#### assign_material_style
Assigns a style to a material

A style may either be assigned directly to an object's representation,
or to a material which is then associated with the object. If both
exist, then the style assigned directly to the object's representation
takes precedence. It is recommended to use materials and assign styles
to materials. This API function provides that capability.

:param material: The IfcMaterial which you want to assign the style to.
:param style: The IfcPresentationStyle (typically IfcSurfaceStyle) that
    you want to assign to the material. This will then be applied to all
    objects that have that material.
:param context: The IfcGeometricRepresentationSubContext at which this
    style should be used. Typically this is the Model BODY context.
:param should_use_presentation_style_assignment: This is a technical
    detail to accomodate a bug in Revit. This should always be left as
    the default of False, unless you are finding that colours aren't
    showing up in Revit. In that case, set it to True, but keep in mind
    that this is no longer a valid IFC. Blame Autodesk.
:return: None

Example:

.. code:: python

    # A model context is needed to store 3D geometry
    model3d = ifcopenshell.api.context.add_context(model, context_type="Model")

    # Specifically, we want to store body geometry
    body = ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Body", target_view="MODEL_VIEW", parent=model3d)

    # Let's create a new wall. The wall does not have any geometry yet.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # Let's use the "3D Body" representation we created earlier to add a
    # new wall-like body geometry, 5 meters long, 3 meters high, and
    # 200mm thick
    representation = ifcopenshell.api.geometry.add_wall_representation(model,
        context=body, length=5, height=3, thickness=0.2)

    # Assign our new body geometry back to our wall
    ifcopenshell.api.geometry.assign_representation(model,
        product=wall, representation=representation)

    # Place our wall at the origin
    ifcopenshell.api.geometry.edit_object_placement(model, product=wall)

    # Let's prepare a concrete material. Note that our concrete material
    # does not have any colours (styles) at this point.
    concrete = ifcopenshell.api.material.add_material(model, name="CON01", category="concrete")

    # Assign our concrete material to our wall
    ifcopenshell.api.material.assign_material(model,
        products=[wall], type="IfcMaterial", material=concrete)

    # Create a new surface style
    style = ifcopenshell.api.style.add_style(model)

    # Create a simple grey shading colour and transparency.
    ifcopenshell.api.style.add_surface_style(model,
        style=style, ifc_class="IfcSurfaceStyleShading", attributes={
            "SurfaceColour": { "Name": None, "Red": 0.5, "Green": 0.5, "Blue": 0.5 },
            "Transparency": 0., # 0 is opaque, 1 is transparent
        })

    # Now any element (like our wall) with a concrete material will have
    # a grey colour applied.
    ifcopenshell.api.style.assign_material_style(model, material=concrete, style=style, context=body)

#### assign_representation_styles
Assigns a style directly to an object representation

A style may either be assigned directly to an object's representation,
or to a material which is then associated with the object. If both
exist, then the style assigned directly to the object's representation
takes precedence. It is recommended to use materials and assign styles
to materials. However, sometimes you may want to assign colours directly
to the object representation as an override. This API function provides
that capability.

This function assigns styles in bulk in an ordered manner to every item in
the representation, so the order and total styles provided is significant.
If you want more granular control, use
:func:`ifcopenshell.api.style.assign_item_style`.

If you want to assign styles to a material instead (recommended), then
please see ifcopenshell.api.style.assign_material_style.

:param shape_representation: The IfcShapeRepresentation of the object
    that you want to assign styles to. This implicitly defines the
    context at which the styles should be used.
:param styles: A list of presentation styles, typically IfcSurfaceStyle.
    The number of items in the list should correlate with the number of
    items in the shape_representation's Items attribute. If you have
    more items than styles, the last style is used.
:param replace_previous_same_type_style: Remove previously assigned styles
    of the same type as currently assign style`. Defaults to `True`.
:param should_use_presentation_style_assignment: This is a technical
    detail to accomodate a bug in Revit. This should always be left as
    the default of False, unless you are finding that colours aren't
    showing up in Revit. In that case, set it to True, but keep in mind
    that this is no longer a valid IFC. Blame Autodesk.
:return: List of created IfcStyledItems

Example:

.. code:: python

    # A model context is needed to store 3D geometry
    model3d = ifcopenshell.api.context.add_context(model, context_type="Model")

    # Specifically, we want to store body geometry
    body = ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Body", target_view="MODEL_VIEW", parent=model3d)

    # Let's create a new wall. The wall does not have any geometry yet.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # Let's use the "3D Body" representation we created earlier to add a
    # new wall-like body geometry, 5 meters long, 3 meters high, and
    # 200mm thick
    representation = ifcopenshell.api.geometry.add_wall_representation(model,
        context=body, length=5, height=3, thickness=0.2)

    # Assign our new body geometry back to our wall
    ifcopenshell.api.geometry.assign_representation(model,
        product=wall, representation=representation)

    # Place our wall at the origin
    ifcopenshell.api.geometry.edit_object_placement(model, product=wall)

    # Create a new surface style
    style = ifcopenshell.api.style.add_style(model)

    # Create a simple grey shading colour and transparency.
    ifcopenshell.api.style.add_surface_style(model,
        style=style, ifc_class="IfcSurfaceStyleShading", attributes={
            "SurfaceColour": { "Name": None, "Red": 0.5, "Green": 0.5, "Blue": 0.5 },
            "Transparency": 0., # 0 is opaque, 1 is transparent
        })

    # Now specifically our wall only will be coloured grey.
    ifcopenshell.api.style.assign_representation_styles(model,
        shape_representation=representation, styles=[style])

#### edit_presentation_style
Edits the attributes of an IfcPresentationStyle

For more information about the attributes and data types of an
IfcPresentationStyle, consult the IFC documentation.

:param style: The IfcPresentationStyle entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Create a new surface style
    style = ifcopenshell.api.style.add_style(model)

    # Change the name of the style to "Foo"
    ifcopenshell.api.style.edit_presentation_style(model, style=style, attributes={"Name": "Foo"})

#### edit_surface_style
Edits the attributes of an IfcPresentationItem

For more information about the attributes and data types of an
IfcPresentationItem, consult the IFC documentation.

The IfcPresentationItem is expected to be one of IfcSurfaceStyleShading,
IfcSurfaceStyleRendering, IfcSurfaceStyleWithTextures,
IfcSurfaceStyleLighting, IfcSurfaceStyleReflectance, or
IfcExternallyDefinedSurfaceStyle.

To represent a colour, a nested dictionary should be used. See the
example below.

:param style: The IfcPresentationStyle entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Create a new surface style
    style = ifcopenshell.api.style.add_style(model)

    # Create a blank rendering style.
    rendering = ifcopenshell.api.style.add_surface_style(model,
        style=style, ifc_class="IfcSurfaceStyleRendering")

    # Edit the attributes of the rendering style.
    ifcopenshell.api.style.edit_surface_style(model,
        style=rendering, attributes={
            # A surface colour and transparency is still supplied for
            # viewport display only. This will supersede the shading
            # presentation item.
            "SurfaceColour": { "Name": None, "Red": 1.0, "Green": 0.8, "Blue": 0.8 },
            "Transparency": 0., # 0 is opaque, 1 is transparent

            # NOTDEFINED is assumed to be a PHYSICAL (PBR) lighting
            # model. In IFC4X3, you may choose PHYSICAL directly.
            "ReflectanceMethod": "NOTDEFINED",

            # For PBR shading, you may specify these parameters:
            "DiffuseColour": { "Name": None, "Red": 0.9, "Green": 0.8, "Blue": 0.8 },
            "SpecularColour": 0.1, # Metallic factor
            "SpecularHighlight": {"SpecularRoughness": 0.5}, # Roughness factor
        })

#### remove_style
Removes a presentation style

All of the presentation items of the style will also be removed.

:param style: The IfcPresentationStyle to remove.
:return: None

Example:

.. code:: python

    # Create a new surface style
    style = ifcopenshell.api.style.add_style(model)

    # Not anymore!
    ifcopenshell.api.style.remove_style(model, style=style)

#### remove_styled_representation
Removes a styled representation

Styled representations are typically associated with materials. This
removes the representation but not the underlying styles.

:param representation: The IfcStyledRepresentation to remove.
:return: None

Example:

.. code:: python

    # Remove a styled representation
    ifcopenshell.api.style.remove_styled_representation(model, representation=representation)

#### remove_surface_style
Removes a presentation item from a presentation style

:param style: The IfcPresentationItem to remove.
:return: None

Example:

.. code:: python

    # Create a new surface style
    style = ifcopenshell.api.style.add_style(model)

    # Create a simple shading colour and transparency.
    shading = ifcopenshell.api.style.add_surface_style(model,
        style=style, ifc_class="IfcSurfaceStyleShading", attributes={
            "SurfaceColour": { "Name": None, "Red": 1.0, "Green": 0.8, "Blue": 0.8 },
            "Transparency": 0., # 0 is opaque, 1 is transparent
        })

    # Remove the shading item
    ifcopenshell.api.style.remove_surface_style(model, style=shading)

#### unassign_material_style
Unassigns a style to a material

This does the inverse of assign_material_style.

:param material: The IfcMaterial which you want to unassign the style from.
:param style: The IfcPresentationStyle (typically IfcSurfaceStyle) that
    you want to unassign from material. This will then be applied to all
    objects that have that material.
:param context: The IfcGeometricRepresentationSubContext at which this
    style should be unassigned. Typically this is the Model BODY context.
:return: None

Example:

.. code:: python

    ifcopenshell.api.style.unassign_material_style(model, material=concrete, style=style, context=body)

#### unassign_representation_styles
Unassigns styles directly assigned to an object representation

This does the inverse of assign_representation_styles.

:param shape_representation: The IfcShapeRepresentation of the object
    that you want to unassign styles from.
:param styles: A list of presentation styles, typically IfcSurfaceStyle.
    The number of items in the list should correlate with the number of
    items in the shape_representation's Items attribute. If you have
    more items than styles, the last style is used.
:param should_use_presentation_style_assignment: This is a technical
    detail to accomodate a bug in Revit. This should always be left as
    the default of False, unless you are finding that colours aren't
    showing up in Revit. In that case, set it to True, but keep in mind
    that this is no longer a valid IFC. Blame Autodesk.
:return: None

Example:

.. code:: python

    ifcopenshell.api.style.unassign_representation_styles(model,
        shape_representation=representation, styles=[style])

## Module: system

### Description
Manage distribution systems and port connectivity

Service distribution systems (mechanical, electrical, hydraulic, fire,
logistical, etc) consist of connected distribution segments, fittings,
terminals, control equipment, and more. This module handles port connectivity
and relationships describing distribution flow.

### Available Functions
- add_port
- add_system
- assign_flow_control
- assign_port
- assign_system
- connect_port
- disconnect_port
- edit_system
- remove_system
- unassign_flow_control
- unassign_port
- unassign_system

### Function Docstrings
#### add_port
Adds a new distribution port to an element

A distribution port represents a connection point on an element, where
a distribution element may be connected to another distribution element.
For example, a duct segment will typically have two ports, one at either
end, because you can attach another segment or fitting to either end of
the duct segment.

This will both add a distribution port and automatically assign it to a
distribution element.

:param element: The IfcDistributionElement you want to add a
    distribution port to.
:return: The newly created IfcDistributionPort

Example:

.. code:: python

    # Create a duct
    duct = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcDuctSegment", predefined_type="RIGIDSEGMENT")

    # Create 2 ports, one for either end.
    port1 = ifcopenshell.api.system.add_port(model, element=duct)
    port2 = ifcopenshell.api.system.add_port(model, element=duct)

#### add_system
Add a new distribution system

A distribution system is a group of distribution elements, like ducts,
pipes, pumps, filters, fans, and so on that distribute a medium (air,
liquid, or electricity) throughout a facility. Systems may be
hierarchical, with larger systems composed of smaller subsystems.

:param ifc_class: The type of system, chosen from IfcDistributionSystem
    for mechanical, electrical, communications, plumbing, fire, or
    security systems. Alternatively you may choose IfcBuildingSystem for
    specialised building facade systems or similar. For IFC2X3, choose
    IfcSystem.
:return: The newly created IfcSystem.

Example:

.. code:: python

    # A completely empty distribution system
    system = ifcopenshell.api.system.add_system(model)

#### assign_flow_control
Assigns to the flow element control element that either sense or control
some aspect of the flow element.

Note that control can be assigned only to the one flow element.

:param related_flow_control: IfcDistributionControlElement
    which may be used to impart control on the flow element
:param relating_flow_element: The IfcDistributionFlowElement that is being controlled / sensed
:return: Matching or newly created IfcRelFlowControlElements. If control
    is already assigned to some other element method will return None.

Example:

.. code:: python

    flow_element = model.createIfcFlowSegment()
    flow_control = model.createIfcController()
    relation = ifcopenshell.api.system.assign_flow_control(
        model, related_flow_control=flow_control, relating_flow_element=flow_element
    )

#### assign_port
Assigns a port to an element

If you have an orphaned port, you may assign it to a distribution
element using this function. Ports should typically not be orphaned, but
it may be useful when patching up models.

:param element: The IfcDistributionElement to assign the port to.
:param port: The IfcDistributionPort you want to assign.
:return: The IfcRelNests relationship, or the
    IfcRelConnectsPortToElement for IFC2X3.

Example:

.. code:: python

    # Create a duct
    duct = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcDuctSegment", predefined_type="RIGIDSEGMENT")

    # Create 2 ports, one for either end.
    port1 = ifcopenshell.api.system.add_port(model, element=duct)
    port2 = ifcopenshell.api.system.add_port(model, element=duct)

    # Unassign one port for some weird reason.
    ifcopenshell.api.system.unassign_port(model, element=duct, port=port1)

    # Reassign it back
    ifcopenshell.api.system.assign_port(model, element=duct, port=port1)

#### assign_system
Assigns distribution elements to a system

Note that it is not necessary to assign distribution ports to a system.

:param products: The list of IfcDistributionElements to assign to the system.
:param system: The IfcSystem you want to assign the element to.
:return: The IfcRelAssignsToGroup relationship
    or `None` if `products` was empty list.

Example:

.. code:: python

    # A completely empty distribution system
    system = ifcopenshell.api.system.add_system(model)

    # Create a duct
    duct = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcDuctSegment", predefined_type="RIGIDSEGMENT")

    # This duct is part of the system
    ifcopenshell.api.system.assign_system(model, products=[duct], system=system)

#### connect_port
Connects two ports together

A distribution element (e.g. a duct) may be connected to another
distribution element (e.g. a fitting) by connecting a port at one of the
duct to a port at the same end of the fitting.

Ports may only have one connection, so you cannot have multiple things
connected to the same port. Nor can you have incompatible port
connections, such as an electrical port connected to an airflow port.

Port connectivity may be explicit or implicit. Explicit connections are
where the port connectivity is described for every single distribution
element in detail. For example, a duct segment would have port
connections to a duct fitting, which would have port connections to
another duct segment, all the way from a fan to an air terminal exactly
as constructed on site. Implicit connections only consider the key
distribution control elements (e.g. the fan and the terminal) and ignore
all of the details of the duct segments and fittings in between.
Generally, explicit connectivity is preferred for later detailed design,
and implicit connectivity is preferred for early phase design.

:param port1: The port of the first distribution element to connect.
:param port2: The port of the second distribution element to connect.
:param direction: The directionality of distribution flow through the
    port connection. NOTDEFINED means that the direction has not yet
    been determined. This is useful during preliminary system design.
    SOURCE means that the flow is from the first element to the second
    element. SINK means that the flow is from the second element to the
    first element. SOURCEANDSINK means that flow is bi-directional
    between the first and second element.  SOURCEANDSINK is a relatively
    rare scenario.
:param element: Optionally set an element through which the port
    connectivity is made, such as a segment or fitting. This is only to
    be used for implicit port connectivity where the segments and
    fittings are less important.

Example:

.. code:: python

    # A completely empty distribution system
    system = ifcopenshell.api.system.add_system(model)

    # Create a duct and a 90 degree bend fitting
    duct = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcDuctSegment", predefined_type="RIGIDSEGMENT")
    fitting = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcDuctFitting", predefined_type="BEND")

    # The duct and fitting is part of the system
    ifcopenshell.api.system.assign_system(model, products=[duct], system=system)
    ifcopenshell.api.system.assign_system(model, products=[fitting], system=system)

    # Create 2 ports, one for either end of both the duct and fitting.
    duct_port1 = ifcopenshell.api.system.add_port(model, element=duct)
    duct_port2 = ifcopenshell.api.system.add_port(model, element=duct)
    fitting_port1 = ifcopenshell.api.system.add_port(model, element=fitting)
    fitting_port2 = ifcopenshell.api.system.add_port(model, element=fitting)

    # Connect the duct and fitting together. At this point, we have not
    # yet determined the direction of the flow, so we leave direction as
    # NOTDEFINED.
    ifcopenshell.api.system.connect_port(model, port1=duct_port2, port2=fitting_port1)

#### disconnect_port
Disconnects a port from any other port

A port may only be connected to one other port, so the other port is not
needed to be specified.

:param port: The IfcDistributionPort to disconnect.
:return: None

Example:

.. code:: python

    # A completely empty distribution system
    system = ifcopenshell.api.system.add_system(model)

    # Create a duct and a 90 degree bend fitting
    duct = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcDuctSegment", predefined_type="RIGIDSEGMENT")
    fitting = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcDuctFitting", predefined_type="BEND")

    # The duct and fitting is part of the system
    ifcopenshell.api.system.assign_system(model, products=[duct], system=system)
    ifcopenshell.api.system.assign_system(model, products=[fitting], system=system)

    # Create 2 ports, one for either end of both the duct and fitting.
    duct_port1 = ifcopenshell.api.system.add_port(model, element=duct)
    duct_port2 = ifcopenshell.api.system.add_port(model, element=duct)
    fitting_port1 = ifcopenshell.api.system.add_port(model, element=fitting)
    fitting_port2 = ifcopenshell.api.system.add_port(model, element=fitting)

    # Connect the duct and fitting together. At this point, we have not
    # yet determined the direction of the flow, so we leave direction as
    # NOTDEFINED.
    ifcopenshell.api.system.connect_port(model, port1=duct_port2, port2=fitting_port1)

    # Disconnect the port. note we could've equally disconnected
    # fitting_port1 instead of duct_port2
    ifcopenshell.api.system.disconnect_port(model, port=duct_port2)

#### edit_system
Edits the attributes of an IfcSystem

For more information about the attributes and data types of an
IfcSystem, consult the IFC documentation.

:param system: The IfcSystem entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # A completely empty distribution system
    system = ifcopenshell.api.system.add_system(model)

    # Change the name of the system to "HW" for Hot Water
    ifcopenshell.api.system.edit_system(model, system=system, attributes={"Name": "HW"})

#### remove_system
Removes a distribution system

All the distribution elements within the system are retained.

:param system: The IfcSystem to remove.
:return: None

Example:

.. code:: python

    # A completely empty distribution system
    system = ifcopenshell.api.system.add_system(model)

    # Delete it.
    ifcopenshell.api.system.remove_system(model, system=system)

#### unassign_flow_control
Unassigns flow control element from the flow element.

:param related_flow_control: IfcDistributionControlElement controling the
    flow element
:param relating_flow_element: The IfcDistributionFlowElement that is being controlled
:return: None

Example:

.. code:: python

    # assign control to the flow element
    flow_element = file.createIfcFlowSegment()
    flow_control = file.createIfcController()
    relation = ifcopenshell.api.system.assign_flow_control(
        file, relating_control=flow_control, related_object=flow_element
    )

    # und unassign it
    ifcopenshell.api.system.unassign_flow_control(file,
        relating_control=flow_control, related_object=flow_element
    )

#### unassign_port
Unassigns a port to an element

Ports are typically always assigned to a distribution element, but in
some edge cases you may want to unassign the port to create an orphaned
port for cleaning or patchin purposes.

:param element: The IfcDistributionElement to unassign the port from.
:param port: The IfcDistributionPort you want to unassign.
:return: None

Example:

.. code:: python

    # Create a duct
    duct = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcDuctSegment", predefined_type="RIGIDSEGMENT")

    # Create 2 ports, one for either end.
    port1 = ifcopenshell.api.system.add_port(model, element=duct)
    port2 = ifcopenshell.api.system.add_port(model, element=duct)

    # Unassign one port for some weird reason.
    ifcopenshell.api.system.unassign_port(model, element=duct, port=port1)

#### unassign_system
Unassigns list of products from a system

:param products: The list of IfcDistributionElements to unassign from the system.
:param system: The IfcSystem you want to unassign the element from.
:return: None

Example:

.. code:: python

    # A completely empty distribution system
    system = ifcopenshell.api.system.add_system(model)

    # Create a duct
    duct = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcDuctSegment", predefined_type="RIGIDSEGMENT")

    # This duct is part of the system
    ifcopenshell.api.system.assign_system(model, products=[duct], system=system)

    # Not anymore!
    ifcopenshell.api.system.unassign_system(model, products=[duct], system=system)

## Module: type

### Description
Manage common construction types of physical elements

Almost all constructed elements may be grouped into "types". Types include wall
types, window types, column types, equipment types, and more.

Using types is critical to the success of any project.

### Available Functions
- assign_type
- map_type_representations
- unassign_type

### Function Docstrings
#### assign_type
Assigns a type to occurrences of an object

IFC supports the concept of occurrences and types. An occurrence is an
actual physical product in the real world: like a wall, a chair, a door,
a column, a pump, and so on.

Most occurrences have a corresponding type. A type describes either a
common shape and set of properties of a particular model of equipment,
or a construction typology. An occurrence may only have zero or one
type.

For example, architects would typically have a door schedule for
individual occurrences of doors and a door types schedule for a handful
of door types, described by the door hardware, frame, and panel. Other
examples might be window types or wall types. Structural engineers would
have a list of column types, beam types, slab types, etc, such as a 400
diameter column, a 500 diameter column, and so on. Services consultant
might nominate a particular type of sprinkler which have many
occurrences, or light fixture types, and so on.

Types are critical as they communicate to the procurement team what
types of equipment and products need to be procured. The individual
occurrences of that type tell them how many to procure. Types are also
critical in construction as they indicate succinctly how to manufacture
or construct something. For example, a wall type is enough information
for a builder to understand the build up and construction of a wall.
Types are used to help break down cost plans, or isolate portions of an
assembly process for construction scheduling. Types are also used in
facility maintenance, as occurrences sharing the same type can be
repaired in the same way or by replacing the same parts.

An occurrence of a type inherits all the properties and materials of the
type. For example, a 2HR fire rated wall type implies that all
wall occurrences of that wall type will also be 2HR fire rated.

A type may or may not have a geometric representation. If a type does
not have any representation, then the occurrences are free to have any
representation of their own. However, if a type has a representation,
all occurrences must have the same representation. For example, if a
light fixture downlight type has a representation of a cylinder, then
all occurrences must have exactly the same cylinder as its
representation. If you change the cylinder's shape of the type, then all
occurrence representations will also change.

If a type does not have any geometric representation, they may have a
parametric material representation. This may be either a parametric
layered material or parametric cross-sectional profile material. If this
is the case, the occurrence must be constructed out of the parametric
material. For example, if a wall type uses a list of parametric layers
indicating a thickness of 13mm plasterboard and 90mm stud, then the
thickness of every wall occurrence representation must be 103mm. The
length of each wall, however, may vary. Similarly, if a beam type has a
parametric profile material of an I-beam, then all beam occurrences must
also be this I-beam shape, though the length may vary.

It is highly recommended for every occurrence to have a type. There are
some exceptions to the rule, such as in heritage architecture or
as-built or dilapidation models, where existing conditions are
ambiguous, unknown or are so bespoke as to have no logical type.

:param related_objects: The IfcElement occurrences.
:param relating_type: The IfcElementType type.
:param should_map_representations: If a type has a representation map,
    IFC requires all occurrences to map those representations. Some IFC
    vendors might disobey this, or you might want to handle it
    yourusecase. In this scenario, you may set this to False.
    This also enabled adding material usages mapping.
:return: The IfcRelDefinesByType relationship
    or `None` if `related_objects` was empty list.

Example:

.. code:: python

    # A furniture type. This would correlate to a particular model in a
    # manufacturer's catalogue. Like an Ikea sofa :)
    furniture_type = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcFurnitureType", name="FUN01")

    # An individual occurrence of a that sofa.
    furniture = ifcopenshell.api.root.create_entity(model, ifc_class="IfcFurniture")

    # Assign the furniture to the furniture type.  If the furniture_type
    # had a representation, the furniture occurrence will also now have
    # the exact same representation. This is highly efficient as you
    # don't need to define the representation for every occurrence.
    ifcopenshell.api.type.assign_type(model, related_objects=[furniture], relating_type=furniture_type)

    # Let's imagine a parametric material layer set
    wall_type = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWallType", name="WAL01")

    # First, let's create a material set. This will later be assigned
    # to our wall type element.
    material_set = ifcopenshell.api.material.add_material_set(model,
        name="GYP-ST-GYP", set_type="IfcMaterialLayerSet")

    # Let's create a few materials, it's important to also give them
    # categories. This makes it easy for model recipients to do things
    # like "show me everything made out of aluminium / concrete / steel
    # / glass / etc". The IFC specification states a list of categories
    # you can use.
    gypsum = ifcopenshell.api.material.add_material(model, name="PB01", category="gypsum")
    steel = ifcopenshell.api.material.add_material(model, name="ST01", category="steel")

    # Now let's use those materials as three layers in our set, such
    # that the steel studs are sandwiched by the gypsum. Let's imagine
    # we're setting the layer thickness in millimeters.
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=gypsum)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": .013})
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=steel)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": .092})
    layer = ifcopenshell.api.material.add_layer(model, layer_set=material_set, material=gypsum)
    ifcopenshell.api.material.edit_layer(model, layer=layer, attributes={"LayerThickness": .013})

    # Great! Let's assign our material set to our wall type.
    ifcopenshell.api.material.assign_material(model, products=[wall_type], material=material_set)

    # Now, let's create a wall.
    wall = ifcopenshell.api.root.create_entity(model, ifc_class="IfcWall")

    # The wall is a WAL01 wall type.
    ifcopenshell.api.type.assign_type(model, related_objects=[wall], relating_type=wall_type)

    # A bit of preparation, let's create some geometric contexts since
    # we want to create some geometry for our wall.
    model3d = ifcopenshell.api.context.add_context(model, context_type="Model")
    body = ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Body", target_view="MODEL_VIEW", parent=model3d)

    # Notice how our thickness of 0.118 must equal .013 + .092 + .013 from our type
    representation = ifcopenshell.api.geometry.add_wall_representation(model,
        context=body, length=5, height=3, thickness=0.118)

    # Assign our new body geometry back to our wall
    ifcopenshell.api.geometry.assign_representation(model,
        product=wall, representation=representation)

    # Place our wall at the origin
    ifcopenshell.api.geometry.edit_object_placement(model, product=wall)

#### map_type_representations
Ensures that all occurrences has the same representation as the type

If a type has a representation, all occurrences must have the same
representation. If the type's representation changes, this function may
be used to ensure consistency of the occurrence's representations.

:param related_object: The IfcElement occurrence.
:param relating_type: The IfcElementType type.
:return: None

Example:

.. code:: python

    # A furniture type. This would correlate to a particular model in a
    # manufacturer's catalogue. Like an Ikea sofa :)
    furniture_type = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcFurnitureType", name="FUN01")

    # An individual occurrence of a that sofa.
    furniture = ifcopenshell.api.root.create_entity(model, ifc_class="IfcFurniture")

    # Place our furniture at the origin
    ifcopenshell.api.geometry.edit_object_placement(model, product=furniture)

    # Assign the furniture to the furniture type. Right now, the
    # furniture type has no representation, so the furniture may also
    # have no representation, or any arbitrary representation that may
    # vary from occurrence to occurrence.
    ifcopenshell.api.type.assign_type(model, related_objects=[furniture], relating_type=furniture_type)

    # A bit of preparation, let's create some geometric contexts since
    # we want to create some geometry for our furniture type.
    model3d = ifcopenshell.api.context.add_context(model, context_type="Model")
    body = ifcopenshell.api.context.add_context(model,
        context_type="Model", context_identifier="Body", target_view="MODEL_VIEW", parent=model3d)

    # Let's create a mesh representation of an arbitrary 2m cube.
    representation = ifcopenshell.api.geometry.add_sverchok_representation(model, context=body,
        vertices=[[(-1.0, -1.0, 0.0), (-1.0, -1.0, 2.0), (-1.0, 1.0, 0.0), (-1.0, 1.0, 2.0),
            (1.0, -1.0, 0.0), (1.0, -1.0, 2.0), (1.0, 1.0, 0.0), (1.0, 1.0, 2.0)]],
        faces=[[[0, 1, 3, 2], [2, 3, 7, 6], [6, 7, 5, 4], [4, 5, 1, 0], [2, 6, 4, 0], [7, 3, 1, 5]]])

    # Assign our new body geometry back to our furniture type. In this
    # case, since we use the API, all occurrences automatically get the
    # representation mapped, so there is nothing more we need to do.
    ifcopenshell.api.geometry.assign_representation(model,
        product=furniture_type, representation=representation)

    # However, if you were doing some sort of manual IFC patching, like
    # assigning furniture_type.RepresentationMaps directly, then you
    # might make this call:
    # ifcopenshell.api.type.map_type_representations(model,
    #     related_object=furniture, relating_type=furniture_type)

#### unassign_type
Unassigns a type from occurrences

Note that unassigning a type doesn't automatically remove mapped representations
and material usages associated with the previously assigned type.

:param related_objects: List of IfcElement occurrences.
:return: None

Example:

.. code:: python

    # A furniture type. This would correlate to a particular model in a
    # manufacturer's catalogue. Like an Ikea sofa :)
    furniture_type = ifcopenshell.api.root.create_entity(model,
        ifc_class="IfcFurnitureType", name="FUN01")

    # An individual occurrence of a that sofa.
    furniture = ifcopenshell.api.root.create_entity(model, ifc_class="IfcFurniture")

    # Assign the furniture to the furniture type.
    ifcopenshell.api.type.assign_type(model, related_objects=[furniture], relating_type=furniture_type)

    # Change our mind. Maybe it's a different type?
    ifcopenshell.api.type.unassign_type(model, related_objects=[furniture])

## Module: unit

### Description
Define units (length, area, monetary, pressure, etc)

Units can be defined as a default project unit or used specifically for certain
properties. Units may be especially complex when dealing with services and
equipment.

### Available Functions
- add_context_dependent_unit
- add_conversion_based_unit
- add_derived_unit
- add_monetary_unit
- add_si_unit
- assign_unit
- edit_derived_unit
- edit_monetary_unit
- edit_named_unit
- remove_unit
- unassign_unit

### Function Docstrings
#### add_context_dependent_unit
Add a new arbitrary unit that can only be interpreted in a project specific context

Occasionally the construction industry uses arbitrary units to quantify
objects, like "pairs" of door hardware, "palettes" or "boxes" of fixings
or equipment.

:param unit_type: Typically should be left as USERDEFINED, unless for
    some bizarre reason you are redefining something you could use a
    sensible normal unit for. In that case, firstly stop whatever you're
    doing and have a hard think about your life, and then if life really
    is going that badly for you, check out the IFC docs for IfcUnitEnum.
:param name: Give your unit a name. X what? X bananas?
:param dimensions: Units typically measure one of 7 fundamental physical
    dimensions: length, mass, time, electric current, temperature,
    substance amount, or luminous intensity. These are represented as a
    list of 7 integers, representing the exponents of each one of these
    dimensions. For example, a length unit is (1, 0, 0, 0, 0, 0, 0),
    where as an area unit is (2, 0, 0, 0, 0, 0, 0). A unit of meters per
    second is (1, 0, -1, 0, 0, 0, 0). For context dependent units, it is
    recommended to leave this as the default of (0, 0, 0, 0, 0, 0, 0).
:return: The new IfcContextDependentUnit

Example:

.. code:: python

    # Boxes of things
    ifcopenshell.api.unit.add_context_dependent_unit(model, name="BOXES")

#### add_conversion_based_unit
Add a conversion based unit

If you're in one of those countries who don't use SI units, you're
probably simply using SI units converted into another unit. If you want
to use _those_ units, you can create a conversion based unit with this
function. You can choose from one of: inch, foot, yard, mile, square
inch, square foot, square yard, acre, square mile, cubic inch, cubic
foot, cubic yard, litre, fluid ounce UK, fluid ounce US, pint UK, pint
US, gallon UK, gallon US, degree, ounce, pound, ton UK, ton US, lbf,
kip, psi, ksi, minute, hour, day, btu, and fahrenheit.

:param name: A converted name chosen from the list above.
:param conversion_offset: If you want to offset the conversion further
    by a set number, you may specify it here. For example, fahrenheit is
    1.8 * kelvin - 459.67. The -459.67 is the conversion offset. Note
    that this is just an example and you don't actually need to specify
    that for fahrenheit as it's built into this API function. For
    advanced users only.
:return: The new IfcConversionBasedUnit or
    IfcConversionBasedUnitWithOffset

Example:

.. code:: python

    # Some common imperial measurements
    length = ifcopenshell.api.unit.add_conversion_based_unit(model, name="inch")
    area = ifcopenshell.api.unit.add_conversion_based_unit(model, name="square foot")

    # Make it our default units, if we are doing an imperial building
    ifcopenshell.api.unit.assign_unit(model, units=[length, area])

#### add_derived_unit
Add a new Derive unit

The supported types are ANGULARVELOCITYUNIT, AREADENSITYUNIT, COMPOUNDPLANEANGLEUNIT,
DYNAMICVISCOSITYUNIT, HEATFLUXDENSITYUNIT, INTEGERCOUNTRATEUNIT, ISOTHERMALMOISTURECAPACITYUNIT,
KINEMATICVISCOSITYUNIT, LINEARVELOCITYUNIT, MASSDENSITYUNIT, MASSFLOWRATEUNIT, MOISTUREDIFFUSIVITYUNIT,
MOLECULARWEIGHTUNIT, SPECIFICHEATCAPACITYUNIT, THERMALADMITTANCEUNIT, THERMALCONDUCTANCEUNIT,
THERMALRESISTANCEUNIT, THERMALTRANSMITTANCEUNIT, VAPORPERMEABILITYUNIT, VOLUMETRICFLOWRATEUNIT,
ROTATIONALFREQUENCYUNIT, TORQUEUNIT, MOMENTOFINERTIAUNIT, LINEARMOMENTUNIT, LINEARFORCEUNIT,
PLANARFORCEUNIT, MODULUSOFELASTICITYUNIT, SHEARMODULUSUNIT, LINEARSTIFFNESSUNIT, ROTATIONALSTIFFNESSUNIT,
MODULUSOFSUBGRADEREACTIONUNIT, ACCELERATIONUNIT, CURVATUREUNIT, HEATINGVALUEUNIT, IONCONCENTRATIONUNIT,
LUMINOUSINTENSITYDISTRIBUTIONUNIT, MASSPERLENGTHUNIT, MODULUSOFLINEARSUBGRADEREACTIONUNIT,
MODULUSOFROTATIONALSUBGRADEREACTIONUNIT, PHUNIT, ROTATIONALMASSUNIT, SECTIONAREAINTEGRALUNIT,
SECTIONMODULUSUNIT, SOUNDPOWERLEVELUNIT, SOUNDPOWERUNIT, SOUNDPRESSURELEVELUNIT, SOUNDPRESSUREUNIT,
TEMPERATUREGRADIENTUNIT, TEMPERATURERATEOFCHANGEUNIT, THERMALEXPANSIONCOEFFICIENTUNIT, WARPINGCONSTANTUNIT,
WARPINGMOMENTUNIT, USERDEFINED.

In case of choosing USERDEFINED, the UserDefinedType parameter needs to be provided

:param unit_type: A type of unit chosen from the list above. For
    example, choosing THERMALCONDUCTANCEUNIT will give you a Thermal conductance.
:param userdefinedtype: The user defined type in case of choosing USERDEFINED, or None for no
    user defined type.
:param attributes: a dictionary of attribute names and values.
:return: The newly created IfcDerivedUnit

Example:

.. code:: python

    # Linear velocity in m/s
    length = ifcopenshell.api.unit.add_si_unit(model, unit_type="LENGTHUNIT")
    #2=IfcSIUnit(*,.LENGTHUNIT.,$,.METRE.)

    time = ifcopenshell.api.unit.add_si_unit(model, unit_type="TIMEUNIT")
    #4=IfcSIUnit(*,.TIMEUNIT.,$,.SECOND.)

    linear_velocity = ifcopenshell.api.unit.add_derived_unit(model, 'LINEARVELOCITY', None, {length : 1, time : -1})
    #10=IfcDerivedUnitElement(#2, 1)
    #11=IfcDerivedUnitElement(#4, -1)
    #12=IfcDerivedUnit((#10,#11),.LINEARVELOCITY.,$)

#### add_monetary_unit
Add a new currency

Currency units are useful in cost plans to know in what currency the
costs are calculated in. The currencies should follow ISO 4217, like
USD, GBP, AUD, MYR, etc.

:param currency: The currency code
:return: The newly created IfcMonetaryUnit

Example:

.. code:: python

    # If you do all your cost plans in Zimbabwean dollars then nobody
    # knows how accurate the numbers are.
    zwl = ifcopenshell.api.unit.add_monetary_unit(model, currency="ZWL")

    # Make it our default currency
    ifcopenshell.api.unit.assign_unit(model, units=[zwl])

#### add_si_unit
Add a new SI unit

The supported types are ABSORBEDDOSEUNIT, AMOUNTOFSUBSTANCEUNIT,
AREAUNIT, DOSEEQUIVALENTUNIT, ELECTRICCAPACITANCEUNIT,
ELECTRICCHARGEUNIT, ELECTRICCONDUCTANCEUNIT, ELECTRICCURRENTUNIT,
ELECTRICRESISTANCEUNIT, ELECTRICVOLTAGEUNIT, ENERGYUNIT, FORCEUNIT,
FREQUENCYUNIT, ILLUMINANCEUNIT, INDUCTANCEUNIT, LENGTHUNIT,
LUMINOUSFLUXUNIT, LUMINOUSINTENSITYUNIT, MAGNETICFLUXDENSITYUNIT,
MAGNETICFLUXUNIT, MASSUNIT, PLANEANGLEUNIT, POWERUNIT, PRESSUREUNIT,
RADIOACTIVITYUNIT, SOLIDANGLEUNIT, THERMODYNAMICTEMPERATUREUNIT,
TIMEUNIT, VOLUMEUNIT.

Prefixes supported are ATTO, CENTI, DECA, DECI, EXA, FEMTO, GIGA, HECTO,
KILO, MEGA, MICRO, MILLI, NANO, PETA, PICO, TERA.

:param unit_type: A type of unit chosen from the list above. For
    example, choosing LENGTHUNIT will give you a metre.
:param prefix: A prefix chosen from the list above, or None for no
    prefix.
:return: The newly created IfcSIUnit

Example:

.. code:: python

    # Millimeters and square meters
    length = ifcopenshell.api.unit.add_si_unit(model, unit_type="LENGTHUNIT", prefix="MILLI")
    area = ifcopenshell.api.unit.add_si_unit(model, unit_type="AREAUNIT")

    # Make it our default units, if we are doing a metric building
    ifcopenshell.api.unit.assign_unit(model, units=[length, area])

#### assign_unit
Assign default project units

Whenever a unitised quantity is specified, such as a length, area,
voltage, pressure, etc, these project units are used by default.

It is also possible to override units for specific properties. For
example, generally you might want square metres for area measurements,
but you might want square millimeters for the measurements of the cross
sectional area of cables in cable trays. However, this function only
deals with the default project units.

:param units: A list of units to assign as project defaults. See
    ifcopenshell.api.unit.add_si_unit, unit.add_conversion_based_unit,
    and unit.add_monetary_unit for information on how to create units.
:return: The IfcUnitAssignment element

Example:

.. code:: python

    # You need a project before you can assign units.
    ifcopenshell.api.root.create_entity(model, ifc_class="IfcProject")

    # Millimeters and square meters
    length = ifcopenshell.api.unit.add_si_unit(model, unit_type="LENGTHUNIT", prefix="MILLI")
    area = ifcopenshell.api.unit.add_si_unit(model, unit_type="AREAUNIT")

    # Make it our default units, if we are doing a metric building
    ifcopenshell.api.unit.assign_unit(model, units=[length, area])

    # Alternatively, you may specify without any arguments to
    # automatically create millimeters, square meters, and cubic meters
    # as a convenience for testing purposes. Sorry imperial folks, we
    # prioritise metric here.
    ifcopenshell.api.unit.assign_unit(model)

#### edit_derived_unit
Edits the attributes of an IfcDerivedUnit

For more information about the attributes and data types of an
IfcDerivedUnit, consult the IFC documentation.

:param unit: The IfcDerivedUnit entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

#### edit_monetary_unit
Edits the attributes of an IfcMonetaryUnit

For more information about the attributes and data types of an
IfcMonetaryUnit, consult the IFC documentation.

:param unit: The IfcMonetaryUnit entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # If you do all your cost plans in Zimbabwean dollars then nobody
    # knows how accurate the numbers are.
    zwl = ifcopenshell.api.unit.add_monetary_unit(model, currency="ZWL")

    # Ah who are we kidding
    ifcopenshell.api.unit.edit_monetary_unit(model, unit=zwl, attributes={"Currency": "USD"})

#### edit_named_unit
Edits the attributes of an IfcNamedUnit

Named units include SI units, conversion based units (imperial units),
and context dependent units.

For more information about the attributes and data types of an
IfcNamedUnit, consult the IFC documentation.

:param unit: The IfcNamedUnit entity you want to edit
:param attributes: a dictionary of attribute names and values.
:return: None

Example:

.. code:: python

    # Boxes of things
    unit = ifcopenshell.api.unit.add_context_dependent_unit(model, name="BOXES")

    # Uh, crates? Boxes? Whatever.
    ifcopenshell.api.unit.edit_named_unit(model, unit=unit, attibutes={"Name": "CRATES"})

#### remove_unit
Remove a unit

Be very careful when a unit is removed, as it may mean that previously
defined quantities in the model completely lose their meaning.

:param unit: The unit element to remove
:return: None

Example:

.. code:: python

    # What?
    unit = ifcopenshell.api.unit.add_context_dependent_unit(model, name="HANDFULS")

    # Yeah maybe not.
    ifcopenshell.api.unit.remove_unit(model, unit=unit)

#### unassign_unit
Unassigns units as default units for the project

:param units: A list of units to unassign as project defaults.
:return: None

Example:

.. code:: python

    # You need a project before you can assign units.
    ifcopenshell.api.root.create_entity(model, ifc_class="IfcProject")

    # Millimeters and square meters
    length = ifcopenshell.api.unit.add_si_unit(model, unit_type="LENGTHUNIT", prefix="MILLI")
    area = ifcopenshell.api.unit.add_si_unit(model, unit_type="AREAUNIT")

    # Make it our default units, if we are doing a metric building
    ifcopenshell.api.unit.assign_unit(model, units=[length, area])

    # Actually, we don't need areas.
    ifcopenshell.api.unit.unassign_unit(model, units=[area])

